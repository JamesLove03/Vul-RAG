{
    "vul_data": [
        {
            "id": 1626,
            "cve_id": "CVE-2018-1093",
            "code_snippet": "static struct buffer_head *\next4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tbitmap_blk = ext4_inode_bitmap(sb, desc);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t    block_group, bitmap_blk);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\tmemset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\ttrace_ext4_load_inode_bitmap(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\tput_bh(bh);\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t   \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\nverify:\n\terr = ext4_validate_inode_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}",
                        "code_after_change": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group) >= sb->s_blocksize)\n\t\treturn blk;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}",
                        "cve_id": "CVE-2018-1093"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic struct buffer_head *\next4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct buffer_head *bh = NULL;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tbitmap_blk = ext4_inode_bitmap(sb, desc);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t    block_group, bitmap_blk);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\tmemset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\ttrace_ext4_load_inode_bitmap(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\tput_bh(bh);\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t   \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\nverify:\n\terr = ext4_validate_inode_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group) >= sb->s_blocksize)\n\t\treturn blk;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1625,
            "cve_id": "CVE-2018-1093",
            "code_snippet": "struct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Failed to init block bitmap for group \"\n\t\t\t\t   \"%u: %d\", block_group, err);\n\t\t\tgoto out;\n\t\t}\n\t\tgoto verify;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\terr = ext4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}",
                        "code_after_change": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group) >= sb->s_blocksize)\n\t\treturn blk;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}",
                        "cve_id": "CVE-2018-1093"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstruct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Failed to init block bitmap for group \"\n\t\t\t\t   \"%u: %d\", block_group, err);\n\t\t\tgoto out;\n\t\t}\n\t\tgoto verify;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\terr = ext4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group) >= sb->s_blocksize)\n\t\treturn blk;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 4306,
            "cve_id": "CVE-2023-6610",
            "code_snippet": "static void\nsmb2_dump_detail(void *buf, struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\n\tcifs_server_dbg(VFS, \"Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\\n\",\n\t\t shdr->Command, shdr->Status, shdr->Flags, shdr->MessageId,\n\t\t shdr->Id.SyncId.ProcessId);\n\tcifs_server_dbg(VFS, \"smb buf %p len %u\\n\", buf,\n\t\t server->ops->calc_smb_size(buf));\n#endif\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len; /* calculated length */\n\t__u64 mid;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t/* decrypt frame now that it is completely read in */\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t/* For SMB2_IOCTL, OutputOffset and OutputLength are optional, so might\n\t * be 0, and not a real miscalculation */\n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Some windows servers also pad up to 8 bytes when compounding.\n\t\t */\n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t/* Only log a message if len was really miscalculated */\n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
                        "code_after_change": "int\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len; /* calculated length */\n\t__u64 mid;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t/* decrypt frame now that it is completely read in */\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t/* For SMB2_IOCTL, OutputOffset and OutputLength are optional, so might\n\t * be 0, and not a real miscalculation */\n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Some windows servers also pad up to 8 bytes when compounding.\n\t\t */\n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t/* Only log a message if len was really miscalculated */\n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
                        "cve_id": "CVE-2023-6610"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void\nsmb2_dump_detail(void *buf, struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\n\tcifs_server_dbg(VFS, \"Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\\n\",\n\t\t shdr->Command, shdr->Status, shdr->Flags, shdr->MessageId,\n\t\t shdr->Id.SyncId.ProcessId);\n\tcifs_server_dbg(VFS, \"smb buf %p len %u\\n\", buf,\n\t\t server->ops->calc_smb_size(buf));\n#endif\n}\n'''\nRelated vulnerability code snippet:\n'''\nint\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len; /* calculated length */\n\t__u64 mid;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t/* decrypt frame now that it is completely read in */\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t/* For SMB2_IOCTL, OutputOffset and OutputLength are optional, so might\n\t * be 0, and not a real miscalculation */\n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Some windows servers also pad up to 8 bytes when compounding.\n\t\t */\n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t/* Only log a message if len was really miscalculated */\n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len; /* calculated length */\n\t__u64 mid;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t/* decrypt frame now that it is completely read in */\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t/* For SMB2_IOCTL, OutputOffset and OutputLength are optional, so might\n\t * be 0, and not a real miscalculation */\n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Some windows servers also pad up to 8 bytes when compounding.\n\t\t */\n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t/* Only log a message if len was really miscalculated */\n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int\ncheckSMB(char *buf, unsigned int total_read, struct TCP_Server_Info *server)\n{\n\tstruct smb_hdr *smb = (struct smb_hdr *)buf;\n\t__u32 rfclen = be32_to_cpu(smb->smb_buf_length);\n\t__u32 clc_len;  /* calculated length */\n\tcifs_dbg(FYI, \"checkSMB Length: 0x%x, smb_buf_length: 0x%x\\n\",\n\t\t total_read, rfclen);\n\n\t/* is this frame too small to even get to a BCC? */\n\tif (total_read < 2 + sizeof(struct smb_hdr)) {\n\t\tif ((total_read >= sizeof(struct smb_hdr) - 1)\n\t\t\t    && (smb->Status.CifsError != 0)) {\n\t\t\t/* it's an error return */\n\t\t\tsmb->WordCount = 0;\n\t\t\t/* some error cases do not return wct and bcc */\n\t\t\treturn 0;\n\t\t} else if ((total_read == sizeof(struct smb_hdr) + 1) &&\n\t\t\t\t(smb->WordCount == 0)) {\n\t\t\tchar *tmp = (char *)smb;\n\t\t\t/* Need to work around a bug in two servers here */\n\t\t\t/* First, check if the part of bcc they sent was zero */\n\t\t\tif (tmp[sizeof(struct smb_hdr)] == 0) {\n\t\t\t\t/* some servers return only half of bcc\n\t\t\t\t * on simple responses (wct, bcc both zero)\n\t\t\t\t * in particular have seen this on\n\t\t\t\t * ulogoffX and FindClose. This leaves\n\t\t\t\t * one byte of bcc potentially unitialized\n\t\t\t\t */\n\t\t\t\t/* zero rest of bcc */\n\t\t\t\ttmp[sizeof(struct smb_hdr)+1] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcifs_dbg(VFS, \"rcvd invalid byte count (bcc)\\n\");\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than smb header size\\n\");\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\t/* otherwise, there is enough to get to the BCC */\n\tif (check_smb_hdr(smb))\n\t\treturn -EIO;\n\tclc_len = smbCalcSize(smb);\n\n\tif (4 + rfclen != total_read) {\n\t\tcifs_dbg(VFS, \"Length read does not match RFC1001 length %d\\n\",\n\t\t\t rfclen);\n\t\treturn -EIO;\n\t}\n\n\tif (4 + rfclen != clc_len) {\n\t\t__u16 mid = get_mid(smb);\n\t\t/* check if bcc wrapped around for large read responses */\n\t\tif ((rfclen > 64 * 1024) && (rfclen > clc_len)) {\n\t\t\t/* check if lengths match mod 64K */\n\t\t\tif (((4 + rfclen) & 0xFFFF) == (clc_len & 0xFFFF))\n\t\t\t\treturn 0; /* bcc wrapped */\n\t\t}\n\t\tcifs_dbg(FYI, \"Calculated size %u vs length %u mismatch for mid=%u\\n\",\n\t\t\t clc_len, 4 + rfclen, mid);\n\n\t\tif (4 + rfclen < clc_len) {\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u smaller than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t} else if (rfclen > clc_len + 512) {\n\t\t\t/*\n\t\t\t * Some servers (Windows XP in particular) send more\n\t\t\t * data than the lengths in the SMB packet would\n\t\t\t * indicate on certain calls (byte range locks and\n\t\t\t * trans2 find first calls in particular). While the\n\t\t\t * client can handle such a frame by ignoring the\n\t\t\t * trailing data, we choose limit the amount of extra\n\t\t\t * data to 512 bytes.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u more than 512 bytes larger than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}",
                        "code_after_change": "int\ncheckSMB(char *buf, unsigned int total_read, struct TCP_Server_Info *server)\n{\n\tstruct smb_hdr *smb = (struct smb_hdr *)buf;\n\t__u32 rfclen = be32_to_cpu(smb->smb_buf_length);\n\t__u32 clc_len;  /* calculated length */\n\tcifs_dbg(FYI, \"checkSMB Length: 0x%x, smb_buf_length: 0x%x\\n\",\n\t\t total_read, rfclen);\n\n\t/* is this frame too small to even get to a BCC? */\n\tif (total_read < 2 + sizeof(struct smb_hdr)) {\n\t\tif ((total_read >= sizeof(struct smb_hdr) - 1)\n\t\t\t    && (smb->Status.CifsError != 0)) {\n\t\t\t/* it's an error return */\n\t\t\tsmb->WordCount = 0;\n\t\t\t/* some error cases do not return wct and bcc */\n\t\t\treturn 0;\n\t\t} else if ((total_read == sizeof(struct smb_hdr) + 1) &&\n\t\t\t\t(smb->WordCount == 0)) {\n\t\t\tchar *tmp = (char *)smb;\n\t\t\t/* Need to work around a bug in two servers here */\n\t\t\t/* First, check if the part of bcc they sent was zero */\n\t\t\tif (tmp[sizeof(struct smb_hdr)] == 0) {\n\t\t\t\t/* some servers return only half of bcc\n\t\t\t\t * on simple responses (wct, bcc both zero)\n\t\t\t\t * in particular have seen this on\n\t\t\t\t * ulogoffX and FindClose. This leaves\n\t\t\t\t * one byte of bcc potentially unitialized\n\t\t\t\t */\n\t\t\t\t/* zero rest of bcc */\n\t\t\t\ttmp[sizeof(struct smb_hdr)+1] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcifs_dbg(VFS, \"rcvd invalid byte count (bcc)\\n\");\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than smb header size\\n\");\n\t\t}\n\t\treturn -EIO;\n\t} else if (total_read < sizeof(*smb) + 2 * smb->WordCount) {\n\t\tcifs_dbg(VFS, \"%s: can't read BCC due to invalid WordCount(%u)\\n\",\n\t\t\t __func__, smb->WordCount);\n\t\treturn -EIO;\n\t}\n\n\t/* otherwise, there is enough to get to the BCC */\n\tif (check_smb_hdr(smb))\n\t\treturn -EIO;\n\tclc_len = smbCalcSize(smb);\n\n\tif (4 + rfclen != total_read) {\n\t\tcifs_dbg(VFS, \"Length read does not match RFC1001 length %d\\n\",\n\t\t\t rfclen);\n\t\treturn -EIO;\n\t}\n\n\tif (4 + rfclen != clc_len) {\n\t\t__u16 mid = get_mid(smb);\n\t\t/* check if bcc wrapped around for large read responses */\n\t\tif ((rfclen > 64 * 1024) && (rfclen > clc_len)) {\n\t\t\t/* check if lengths match mod 64K */\n\t\t\tif (((4 + rfclen) & 0xFFFF) == (clc_len & 0xFFFF))\n\t\t\t\treturn 0; /* bcc wrapped */\n\t\t}\n\t\tcifs_dbg(FYI, \"Calculated size %u vs length %u mismatch for mid=%u\\n\",\n\t\t\t clc_len, 4 + rfclen, mid);\n\n\t\tif (4 + rfclen < clc_len) {\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u smaller than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t} else if (rfclen > clc_len + 512) {\n\t\t\t/*\n\t\t\t * Some servers (Windows XP in particular) send more\n\t\t\t * data than the lengths in the SMB packet would\n\t\t\t * indicate on certain calls (byte range locks and\n\t\t\t * trans2 find first calls in particular). While the\n\t\t\t * client can handle such a frame by ignoring the\n\t\t\t * trailing data, we choose limit the amount of extra\n\t\t\t * data to 512 bytes.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u more than 512 bytes larger than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}",
                        "cve_id": "CVE-2023-6606"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void\nsmb2_dump_detail(void *buf, struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\n\tcifs_server_dbg(VFS, \"Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\\n\",\n\t\t shdr->Command, shdr->Status, shdr->Flags, shdr->MessageId,\n\t\t shdr->Id.SyncId.ProcessId);\n\tcifs_server_dbg(VFS, \"smb buf %p len %u\\n\", buf,\n\t\t server->ops->calc_smb_size(buf));\n#endif\n}\n'''\nRelated vulnerability code snippet:\n'''\nint\ncheckSMB(char *buf, unsigned int total_read, struct TCP_Server_Info *server)\n{\n\tstruct smb_hdr *smb = (struct smb_hdr *)buf;\n\t__u32 rfclen = be32_to_cpu(smb->smb_buf_length);\n\t__u32 clc_len;  /* calculated length */\n\tcifs_dbg(FYI, \"checkSMB Length: 0x%x, smb_buf_length: 0x%x\\n\",\n\t\t total_read, rfclen);\n\n\t/* is this frame too small to even get to a BCC? */\n\tif (total_read < 2 + sizeof(struct smb_hdr)) {\n\t\tif ((total_read >= sizeof(struct smb_hdr) - 1)\n\t\t\t    && (smb->Status.CifsError != 0)) {\n\t\t\t/* it's an error return */\n\t\t\tsmb->WordCount = 0;\n\t\t\t/* some error cases do not return wct and bcc */\n\t\t\treturn 0;\n\t\t} else if ((total_read == sizeof(struct smb_hdr) + 1) &&\n\t\t\t\t(smb->WordCount == 0)) {\n\t\t\tchar *tmp = (char *)smb;\n\t\t\t/* Need to work around a bug in two servers here */\n\t\t\t/* First, check if the part of bcc they sent was zero */\n\t\t\tif (tmp[sizeof(struct smb_hdr)] == 0) {\n\t\t\t\t/* some servers return only half of bcc\n\t\t\t\t * on simple responses (wct, bcc both zero)\n\t\t\t\t * in particular have seen this on\n\t\t\t\t * ulogoffX and FindClose. This leaves\n\t\t\t\t * one byte of bcc potentially unitialized\n\t\t\t\t */\n\t\t\t\t/* zero rest of bcc */\n\t\t\t\ttmp[sizeof(struct smb_hdr)+1] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcifs_dbg(VFS, \"rcvd invalid byte count (bcc)\\n\");\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than smb header size\\n\");\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\t/* otherwise, there is enough to get to the BCC */\n\tif (check_smb_hdr(smb))\n\t\treturn -EIO;\n\tclc_len = smbCalcSize(smb);\n\n\tif (4 + rfclen != total_read) {\n\t\tcifs_dbg(VFS, \"Length read does not match RFC1001 length %d\\n\",\n\t\t\t rfclen);\n\t\treturn -EIO;\n\t}\n\n\tif (4 + rfclen != clc_len) {\n\t\t__u16 mid = get_mid(smb);\n\t\t/* check if bcc wrapped around for large read responses */\n\t\tif ((rfclen > 64 * 1024) && (rfclen > clc_len)) {\n\t\t\t/* check if lengths match mod 64K */\n\t\t\tif (((4 + rfclen) & 0xFFFF) == (clc_len & 0xFFFF))\n\t\t\t\treturn 0; /* bcc wrapped */\n\t\t}\n\t\tcifs_dbg(FYI, \"Calculated size %u vs length %u mismatch for mid=%u\\n\",\n\t\t\t clc_len, 4 + rfclen, mid);\n\n\t\tif (4 + rfclen < clc_len) {\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u smaller than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t} else if (rfclen > clc_len + 512) {\n\t\t\t/*\n\t\t\t * Some servers (Windows XP in particular) send more\n\t\t\t * data than the lengths in the SMB packet would\n\t\t\t * indicate on certain calls (byte range locks and\n\t\t\t * trans2 find first calls in particular). While the\n\t\t\t * client can handle such a frame by ignoring the\n\t\t\t * trailing data, we choose limit the amount of extra\n\t\t\t * data to 512 bytes.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u more than 512 bytes larger than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint\ncheckSMB(char *buf, unsigned int total_read, struct TCP_Server_Info *server)\n{\n\tstruct smb_hdr *smb = (struct smb_hdr *)buf;\n\t__u32 rfclen = be32_to_cpu(smb->smb_buf_length);\n\t__u32 clc_len;  /* calculated length */\n\tcifs_dbg(FYI, \"checkSMB Length: 0x%x, smb_buf_length: 0x%x\\n\",\n\t\t total_read, rfclen);\n\n\t/* is this frame too small to even get to a BCC? */\n\tif (total_read < 2 + sizeof(struct smb_hdr)) {\n\t\tif ((total_read >= sizeof(struct smb_hdr) - 1)\n\t\t\t    && (smb->Status.CifsError != 0)) {\n\t\t\t/* it's an error return */\n\t\t\tsmb->WordCount = 0;\n\t\t\t/* some error cases do not return wct and bcc */\n\t\t\treturn 0;\n\t\t} else if ((total_read == sizeof(struct smb_hdr) + 1) &&\n\t\t\t\t(smb->WordCount == 0)) {\n\t\t\tchar *tmp = (char *)smb;\n\t\t\t/* Need to work around a bug in two servers here */\n\t\t\t/* First, check if the part of bcc they sent was zero */\n\t\t\tif (tmp[sizeof(struct smb_hdr)] == 0) {\n\t\t\t\t/* some servers return only half of bcc\n\t\t\t\t * on simple responses (wct, bcc both zero)\n\t\t\t\t * in particular have seen this on\n\t\t\t\t * ulogoffX and FindClose. This leaves\n\t\t\t\t * one byte of bcc potentially unitialized\n\t\t\t\t */\n\t\t\t\t/* zero rest of bcc */\n\t\t\t\ttmp[sizeof(struct smb_hdr)+1] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcifs_dbg(VFS, \"rcvd invalid byte count (bcc)\\n\");\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than smb header size\\n\");\n\t\t}\n\t\treturn -EIO;\n\t} else if (total_read < sizeof(*smb) + 2 * smb->WordCount) {\n\t\tcifs_dbg(VFS, \"%s: can't read BCC due to invalid WordCount(%u)\\n\",\n\t\t\t __func__, smb->WordCount);\n\t\treturn -EIO;\n\t}\n\n\t/* otherwise, there is enough to get to the BCC */\n\tif (check_smb_hdr(smb))\n\t\treturn -EIO;\n\tclc_len = smbCalcSize(smb);\n\n\tif (4 + rfclen != total_read) {\n\t\tcifs_dbg(VFS, \"Length read does not match RFC1001 length %d\\n\",\n\t\t\t rfclen);\n\t\treturn -EIO;\n\t}\n\n\tif (4 + rfclen != clc_len) {\n\t\t__u16 mid = get_mid(smb);\n\t\t/* check if bcc wrapped around for large read responses */\n\t\tif ((rfclen > 64 * 1024) && (rfclen > clc_len)) {\n\t\t\t/* check if lengths match mod 64K */\n\t\t\tif (((4 + rfclen) & 0xFFFF) == (clc_len & 0xFFFF))\n\t\t\t\treturn 0; /* bcc wrapped */\n\t\t}\n\t\tcifs_dbg(FYI, \"Calculated size %u vs length %u mismatch for mid=%u\\n\",\n\t\t\t clc_len, 4 + rfclen, mid);\n\n\t\tif (4 + rfclen < clc_len) {\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u smaller than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t} else if (rfclen > clc_len + 512) {\n\t\t\t/*\n\t\t\t * Some servers (Windows XP in particular) send more\n\t\t\t * data than the lengths in the SMB packet would\n\t\t\t * indicate on certain calls (byte range locks and\n\t\t\t * trans2 find first calls in particular). While the\n\t\t\t * client can handle such a frame by ignoring the\n\t\t\t * trailing data, we choose limit the amount of extra\n\t\t\t * data to 512 bytes.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"RFC1001 size %u more than 512 bytes larger than SMB for mid=%u\\n\",\n\t\t\t\t rfclen, mid);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = ses->server;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb2_plain_req_init(SMB2_NEGOTIATE, NULL, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->sync_hdr.SessionId = 0;\n\n\tmemset(server->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\tmemset(ses->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\n\tif (strcmp(ses->server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(2);\n\t\ttotal_len += 4;\n\t} else if (strcmp(ses->server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB21_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[2] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->Dialects[3] = cpu_to_le16(SMB311_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(4);\n\t\ttotal_len += 8;\n\t} else {\n\t\t/* otherwise send specific dialect */\n\t\treq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\n\t\treq->DialectCount = cpu_to_le16(1);\n\t\ttotal_len += 2;\n\t}\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (ses->server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse {\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\t\tif ((ses->server->vals->protocol_id == SMB311_PROT_ID) ||\n\t\t    (strcmp(ses->server->vals->version_string,\n\t\t     SMBDEFAULT_VERSION_STRING) == 0))\n\t\t\tassemble_neg_contexts(req, &total_len);\n\t}\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_negotiate_rsp *)rsp_iov.iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc == -EOPNOTSUPP) {\n\t\tcifs_dbg(VFS, \"Dialect not supported by server. Consider \"\n\t\t\t\"specifying vers=1.0 or vers=2.0 on mount for accessing\"\n\t\t\t\" older servers\\n\");\n\t\tgoto neg_exit;\n\t} else if (rc != 0)\n\t\tgoto neg_exit;\n\n\tif (strcmp(ses->server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2.1 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else if (strcmp(ses->server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\t/* ops set to 3.0 by default for default so update */\n\t\t\tses->server->ops = &smb21_operations;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\n\t\t\tses->server->ops = &smb311_operations;\n\t} else if (le16_to_cpu(rsp->DialectRevision) !=\n\t\t\t\tses->server->vals->protocol_id) {\n\t\t/* if requested single dialect ensure returned dialect matched */\n\t\tcifs_dbg(VFS, \"Illegal 0x%x dialect returned: not requested\\n\",\n\t\t\tle16_to_cpu(rsp->DialectRevision));\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.1.1 dialect\\n\");\n\telse {\n\t\tcifs_dbg(VFS, \"Illegal dialect returned by server 0x%x\\n\",\n\t\t\t le16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/*\n\t * Keep a copy of the hash after negprot. This hash will be\n\t * the starting hash value for all sessions made from this\n\t * server.\n\t */\n\tmemcpy(server->preauth_sha_hash, ses->preauth_sha_hash,\n\t       SMB2_PREAUTH_HASH_SIZE);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tif ((server->sec_mode & SMB2_SEC_MODE_FLAGS_ALL) != server->sec_mode)\n\t\tcifs_dbg(FYI, \"Server returned unexpected security mode 0x%x\\n\",\n\t\t\t\tserver->sec_mode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       (struct smb2_sync_hdr *)rsp);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0) {\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\t\tserver->sec_ntlmssp = true;\n\t}\n\n\trc = cifs_enable_signing(server, ses->sign);\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length) {\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\t\tif (rc == 1)\n\t\t\trc = 0;\n\t\telse if (rc == 0)\n\t\t\trc = -EIO;\n\t}\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\tif (rsp->NegotiateContextCount)\n\t\t\trc = smb311_decode_neg_context(rsp, server,\n\t\t\t\t\t\t       rsp_iov.iov_len);\n\t\telse\n\t\t\tcifs_dbg(VFS, \"Missing expected negotiate contexts\\n\");\n\t}\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
                        "code_after_change": "int\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = ses->server;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb2_plain_req_init(SMB2_NEGOTIATE, NULL, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->sync_hdr.SessionId = 0;\n\n\tmemset(server->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\tmemset(ses->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\n\tif (strcmp(ses->server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(2);\n\t\ttotal_len += 4;\n\t} else if (strcmp(ses->server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB21_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[2] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->Dialects[3] = cpu_to_le16(SMB311_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(4);\n\t\ttotal_len += 8;\n\t} else {\n\t\t/* otherwise send specific dialect */\n\t\treq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\n\t\treq->DialectCount = cpu_to_le16(1);\n\t\ttotal_len += 2;\n\t}\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (ses->server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse {\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\t\tif ((ses->server->vals->protocol_id == SMB311_PROT_ID) ||\n\t\t    (strcmp(ses->server->vals->version_string,\n\t\t     SMBDEFAULT_VERSION_STRING) == 0))\n\t\t\tassemble_neg_contexts(req, &total_len);\n\t}\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_negotiate_rsp *)rsp_iov.iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc == -EOPNOTSUPP) {\n\t\tcifs_dbg(VFS, \"Dialect not supported by server. Consider \"\n\t\t\t\"specifying vers=1.0 or vers=2.0 on mount for accessing\"\n\t\t\t\" older servers\\n\");\n\t\tgoto neg_exit;\n\t} else if (rc != 0)\n\t\tgoto neg_exit;\n\n\tif (strcmp(ses->server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2.1 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else if (strcmp(ses->server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\t/* ops set to 3.0 by default for default so update */\n\t\t\tses->server->ops = &smb21_operations;\n\t\t\tses->server->vals = &smb21_values;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\t\tses->server->ops = &smb311_operations;\n\t\t\tses->server->vals = &smb311_values;\n\t\t}\n\t} else if (le16_to_cpu(rsp->DialectRevision) !=\n\t\t\t\tses->server->vals->protocol_id) {\n\t\t/* if requested single dialect ensure returned dialect matched */\n\t\tcifs_dbg(VFS, \"Illegal 0x%x dialect returned: not requested\\n\",\n\t\t\tle16_to_cpu(rsp->DialectRevision));\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.1.1 dialect\\n\");\n\telse {\n\t\tcifs_dbg(VFS, \"Illegal dialect returned by server 0x%x\\n\",\n\t\t\t le16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/*\n\t * Keep a copy of the hash after negprot. This hash will be\n\t * the starting hash value for all sessions made from this\n\t * server.\n\t */\n\tmemcpy(server->preauth_sha_hash, ses->preauth_sha_hash,\n\t       SMB2_PREAUTH_HASH_SIZE);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tif ((server->sec_mode & SMB2_SEC_MODE_FLAGS_ALL) != server->sec_mode)\n\t\tcifs_dbg(FYI, \"Server returned unexpected security mode 0x%x\\n\",\n\t\t\t\tserver->sec_mode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       (struct smb2_sync_hdr *)rsp);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0) {\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\t\tserver->sec_ntlmssp = true;\n\t}\n\n\trc = cifs_enable_signing(server, ses->sign);\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length) {\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\t\tif (rc == 1)\n\t\t\trc = 0;\n\t\telse if (rc == 0)\n\t\t\trc = -EIO;\n\t}\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\tif (rsp->NegotiateContextCount)\n\t\t\trc = smb311_decode_neg_context(rsp, server,\n\t\t\t\t\t\t       rsp_iov.iov_len);\n\t\telse\n\t\t\tcifs_dbg(VFS, \"Missing expected negotiate contexts\\n\");\n\t}\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
                        "cve_id": "CVE-2019-15918"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void\nsmb2_dump_detail(void *buf, struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\n\tcifs_server_dbg(VFS, \"Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\\n\",\n\t\t shdr->Command, shdr->Status, shdr->Flags, shdr->MessageId,\n\t\t shdr->Id.SyncId.ProcessId);\n\tcifs_server_dbg(VFS, \"smb buf %p len %u\\n\", buf,\n\t\t server->ops->calc_smb_size(buf));\n#endif\n}\n'''\nRelated vulnerability code snippet:\n'''\nint\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = ses->server;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb2_plain_req_init(SMB2_NEGOTIATE, NULL, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->sync_hdr.SessionId = 0;\n\n\tmemset(server->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\tmemset(ses->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\n\tif (strcmp(ses->server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(2);\n\t\ttotal_len += 4;\n\t} else if (strcmp(ses->server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB21_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[2] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->Dialects[3] = cpu_to_le16(SMB311_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(4);\n\t\ttotal_len += 8;\n\t} else {\n\t\t/* otherwise send specific dialect */\n\t\treq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\n\t\treq->DialectCount = cpu_to_le16(1);\n\t\ttotal_len += 2;\n\t}\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (ses->server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse {\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\t\tif ((ses->server->vals->protocol_id == SMB311_PROT_ID) ||\n\t\t    (strcmp(ses->server->vals->version_string,\n\t\t     SMBDEFAULT_VERSION_STRING) == 0))\n\t\t\tassemble_neg_contexts(req, &total_len);\n\t}\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_negotiate_rsp *)rsp_iov.iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc == -EOPNOTSUPP) {\n\t\tcifs_dbg(VFS, \"Dialect not supported by server. Consider \"\n\t\t\t\"specifying vers=1.0 or vers=2.0 on mount for accessing\"\n\t\t\t\" older servers\\n\");\n\t\tgoto neg_exit;\n\t} else if (rc != 0)\n\t\tgoto neg_exit;\n\n\tif (strcmp(ses->server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2.1 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else if (strcmp(ses->server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\t/* ops set to 3.0 by default for default so update */\n\t\t\tses->server->ops = &smb21_operations;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\n\t\t\tses->server->ops = &smb311_operations;\n\t} else if (le16_to_cpu(rsp->DialectRevision) !=\n\t\t\t\tses->server->vals->protocol_id) {\n\t\t/* if requested single dialect ensure returned dialect matched */\n\t\tcifs_dbg(VFS, \"Illegal 0x%x dialect returned: not requested\\n\",\n\t\t\tle16_to_cpu(rsp->DialectRevision));\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.1.1 dialect\\n\");\n\telse {\n\t\tcifs_dbg(VFS, \"Illegal dialect returned by server 0x%x\\n\",\n\t\t\t le16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/*\n\t * Keep a copy of the hash after negprot. This hash will be\n\t * the starting hash value for all sessions made from this\n\t * server.\n\t */\n\tmemcpy(server->preauth_sha_hash, ses->preauth_sha_hash,\n\t       SMB2_PREAUTH_HASH_SIZE);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tif ((server->sec_mode & SMB2_SEC_MODE_FLAGS_ALL) != server->sec_mode)\n\t\tcifs_dbg(FYI, \"Server returned unexpected security mode 0x%x\\n\",\n\t\t\t\tserver->sec_mode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       (struct smb2_sync_hdr *)rsp);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0) {\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\t\tserver->sec_ntlmssp = true;\n\t}\n\n\trc = cifs_enable_signing(server, ses->sign);\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length) {\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\t\tif (rc == 1)\n\t\t\trc = 0;\n\t\telse if (rc == 0)\n\t\t\trc = -EIO;\n\t}\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\tif (rsp->NegotiateContextCount)\n\t\t\trc = smb311_decode_neg_context(rsp, server,\n\t\t\t\t\t\t       rsp_iov.iov_len);\n\t\telse\n\t\t\tcifs_dbg(VFS, \"Missing expected negotiate contexts\\n\");\n\t}\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = ses->server;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\tunsigned int total_len;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb2_plain_req_init(SMB2_NEGOTIATE, NULL, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->sync_hdr.SessionId = 0;\n\n\tmemset(server->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\tmemset(ses->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE);\n\n\tif (strcmp(ses->server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(2);\n\t\ttotal_len += 4;\n\t} else if (strcmp(ses->server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\treq->Dialects[0] = cpu_to_le16(SMB21_PROT_ID);\n\t\treq->Dialects[1] = cpu_to_le16(SMB30_PROT_ID);\n\t\treq->Dialects[2] = cpu_to_le16(SMB302_PROT_ID);\n\t\treq->Dialects[3] = cpu_to_le16(SMB311_PROT_ID);\n\t\treq->DialectCount = cpu_to_le16(4);\n\t\ttotal_len += 8;\n\t} else {\n\t\t/* otherwise send specific dialect */\n\t\treq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\n\t\treq->DialectCount = cpu_to_le16(1);\n\t\ttotal_len += 2;\n\t}\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (ses->server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse {\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\t\tif ((ses->server->vals->protocol_id == SMB311_PROT_ID) ||\n\t\t    (strcmp(ses->server->vals->version_string,\n\t\t     SMBDEFAULT_VERSION_STRING) == 0))\n\t\t\tassemble_neg_contexts(req, &total_len);\n\t}\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_negotiate_rsp *)rsp_iov.iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc == -EOPNOTSUPP) {\n\t\tcifs_dbg(VFS, \"Dialect not supported by server. Consider \"\n\t\t\t\"specifying vers=1.0 or vers=2.0 on mount for accessing\"\n\t\t\t\" older servers\\n\");\n\t\tgoto neg_exit;\n\t} else if (rc != 0)\n\t\tgoto neg_exit;\n\n\tif (strcmp(ses->server->vals->version_string,\n\t\t   SMB3ANY_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2.1 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else if (strcmp(ses->server->vals->version_string,\n\t\t   SMBDEFAULT_VERSION_STRING) == 0) {\n\t\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) {\n\t\t\tcifs_dbg(VFS,\n\t\t\t\t\"SMB2 dialect returned but not requested\\n\");\n\t\t\treturn -EIO;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {\n\t\t\t/* ops set to 3.0 by default for default so update */\n\t\t\tses->server->ops = &smb21_operations;\n\t\t\tses->server->vals = &smb21_values;\n\t\t} else if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\t\tses->server->ops = &smb311_operations;\n\t\t\tses->server->vals = &smb311_values;\n\t\t}\n\t} else if (le16_to_cpu(rsp->DialectRevision) !=\n\t\t\t\tses->server->vals->protocol_id) {\n\t\t/* if requested single dialect ensure returned dialect matched */\n\t\tcifs_dbg(VFS, \"Illegal 0x%x dialect returned: not requested\\n\",\n\t\t\tle16_to_cpu(rsp->DialectRevision));\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.1.1 dialect\\n\");\n\telse {\n\t\tcifs_dbg(VFS, \"Illegal dialect returned by server 0x%x\\n\",\n\t\t\t le16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/*\n\t * Keep a copy of the hash after negprot. This hash will be\n\t * the starting hash value for all sessions made from this\n\t * server.\n\t */\n\tmemcpy(server->preauth_sha_hash, ses->preauth_sha_hash,\n\t       SMB2_PREAUTH_HASH_SIZE);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tif ((server->sec_mode & SMB2_SEC_MODE_FLAGS_ALL) != server->sec_mode)\n\t\tcifs_dbg(FYI, \"Server returned unexpected security mode 0x%x\\n\",\n\t\t\t\tserver->sec_mode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       (struct smb2_sync_hdr *)rsp);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0) {\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\t\tserver->sec_ntlmssp = true;\n\t}\n\n\trc = cifs_enable_signing(server, ses->sign);\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length) {\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\t\tif (rc == 1)\n\t\t\trc = 0;\n\t\telse if (rc == 0)\n\t\t\trc = -EIO;\n\t}\n\n\tif (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {\n\t\tif (rsp->NegotiateContextCount)\n\t\t\trc = smb311_decode_neg_context(rsp, server,\n\t\t\t\t\t\t       rsp_iov.iov_len);\n\t\telse\n\t\t\tcifs_dbg(VFS, \"Missing expected negotiate contexts\\n\");\n\t}\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 776,
            "cve_id": "CVE-2015-5327",
            "code_snippet": "int x509_decode_time(time64_t *_t,  size_t hdrlen,\n\t\t     unsigned char tag,\n\t\t     const unsigned char *value, size_t vlen)\n{\n\tstatic const unsigned char month_lengths[] = { 31, 29, 31, 30, 31, 30,\n\t\t\t\t\t\t       31, 31, 30, 31, 30, 31 };\n\tconst unsigned char *p = value;\n\tunsigned year, mon, day, hour, min, sec, mon_len;\n\n#define dec2bin(X) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })\n#define DD2bin(P) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })\n\n\tif (tag == ASN1_UNITIM) {\n\t\t/* UTCTime: YYMMDDHHMMSSZ */\n\t\tif (vlen != 13)\n\t\t\tgoto unsupported_time;\n\t\tyear = DD2bin(p);\n\t\tif (year >= 50)\n\t\t\tyear += 1900;\n\t\telse\n\t\t\tyear += 2000;\n\t} else if (tag == ASN1_GENTIM) {\n\t\t/* GenTime: YYYYMMDDHHMMSSZ */\n\t\tif (vlen != 15)\n\t\t\tgoto unsupported_time;\n\t\tyear = DD2bin(p) * 100 + DD2bin(p);\n\t\tif (year >= 1950 && year <= 2049)\n\t\t\tgoto invalid_time;\n\t} else {\n\t\tgoto unsupported_time;\n\t}\n\n\tmon  = DD2bin(p);\n\tday = DD2bin(p);\n\thour = DD2bin(p);\n\tmin  = DD2bin(p);\n\tsec  = DD2bin(p);\n\n\tif (*p != 'Z')\n\t\tgoto unsupported_time;\n\n\tmon_len = month_lengths[mon];\n\tif (mon == 2) {\n\t\tif (year % 4 == 0) {\n\t\t\tmon_len = 29;\n\t\t\tif (year % 100 == 0) {\n\t\t\t\tyear /= 100;\n\t\t\t\tif (year % 4 != 0)\n\t\t\t\t\tmon_len = 28;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (year < 1970 ||\n\t    mon < 1 || mon > 12 ||\n\t    day < 1 || day > mon_len ||\n\t    hour > 23 ||\n\t    min > 59 ||\n\t    sec > 59)\n\t\tgoto invalid_time;\n\n\t*_t = mktime64(year, mon, day, hour, min, sec);\n\treturn 0;\n\nunsupported_time:\n\tpr_debug(\"Got unsupported time [tag %02x]: '%*phN'\\n\",\n\t\t tag, (int)vlen, value);\n\treturn -EBADMSG;\ninvalid_time:\n\tpr_debug(\"Got invalid time [tag %02x]: '%*phN'\\n\",\n\t\t tag, (int)vlen, value);\n\treturn -EBADMSG;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}",
                        "code_after_change": "static ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tif (use_unicode(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}",
                        "cve_id": "CVE-2019-19252"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint x509_decode_time(time64_t *_t,  size_t hdrlen,\n\t\t     unsigned char tag,\n\t\t     const unsigned char *value, size_t vlen)\n{\n\tstatic const unsigned char month_lengths[] = { 31, 29, 31, 30, 31, 30,\n\t\t\t\t\t\t       31, 31, 30, 31, 30, 31 };\n\tconst unsigned char *p = value;\n\tunsigned year, mon, day, hour, min, sec, mon_len;\n\n#define dec2bin(X) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })\n#define DD2bin(P) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })\n\n\tif (tag == ASN1_UNITIM) {\n\t\t/* UTCTime: YYMMDDHHMMSSZ */\n\t\tif (vlen != 13)\n\t\t\tgoto unsupported_time;\n\t\tyear = DD2bin(p);\n\t\tif (year >= 50)\n\t\t\tyear += 1900;\n\t\telse\n\t\t\tyear += 2000;\n\t} else if (tag == ASN1_GENTIM) {\n\t\t/* GenTime: YYYYMMDDHHMMSSZ */\n\t\tif (vlen != 15)\n\t\t\tgoto unsupported_time;\n\t\tyear = DD2bin(p) * 100 + DD2bin(p);\n\t\tif (year >= 1950 && year <= 2049)\n\t\t\tgoto invalid_time;\n\t} else {\n\t\tgoto unsupported_time;\n\t}\n\n\tmon  = DD2bin(p);\n\tday = DD2bin(p);\n\thour = DD2bin(p);\n\tmin  = DD2bin(p);\n\tsec  = DD2bin(p);\n\n\tif (*p != 'Z')\n\t\tgoto unsupported_time;\n\n\tmon_len = month_lengths[mon];\n\tif (mon == 2) {\n\t\tif (year % 4 == 0) {\n\t\t\tmon_len = 29;\n\t\t\tif (year % 100 == 0) {\n\t\t\t\tyear /= 100;\n\t\t\t\tif (year % 4 != 0)\n\t\t\t\t\tmon_len = 28;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (year < 1970 ||\n\t    mon < 1 || mon > 12 ||\n\t    day < 1 || day > mon_len ||\n\t    hour > 23 ||\n\t    min > 59 ||\n\t    sec > 59)\n\t\tgoto invalid_time;\n\n\t*_t = mktime64(year, mon, day, hour, min, sec);\n\treturn 0;\n\nunsupported_time:\n\tpr_debug(\"Got unsupported time [tag %02x]: '%*phN'\\n\",\n\t\t tag, (int)vlen, value);\n\treturn -EBADMSG;\ninvalid_time:\n\tpr_debug(\"Got invalid time [tag %02x]: '%*phN'\\n\",\n\t\t tag, (int)vlen, value);\n\treturn -EBADMSG;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tif (use_unicode(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3799,
            "cve_id": "CVE-2022-48502",
            "code_snippet": "static int ntfs_read_ea(struct ntfs_inode *ni, struct EA_FULL **ea,\n\t\t\tsize_t add_bytes, const struct EA_INFO **info)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct ATTRIB *attr_info, *attr_ea;\n\tvoid *ea_p;\n\tu32 size;\n\n\tstatic_assert(le32_to_cpu(ATTR_EA_INFO) < le32_to_cpu(ATTR_EA));\n\n\t*ea = NULL;\n\t*info = NULL;\n\n\tattr_info =\n\t\tni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, NULL);\n\tattr_ea =\n\t\tni_find_attr(ni, attr_info, &le, ATTR_EA, NULL, 0, NULL, NULL);\n\n\tif (!attr_ea || !attr_info)\n\t\treturn 0;\n\n\t*info = resident_data_ex(attr_info, sizeof(struct EA_INFO));\n\tif (!*info)\n\t\treturn -EINVAL;\n\n\t/* Check Ea limit. */\n\tsize = le32_to_cpu((*info)->size);\n\tif (size > sbi->ea_max_size)\n\t\treturn -EFBIG;\n\n\tif (attr_size(attr_ea) > sbi->ea_max_size)\n\t\treturn -EFBIG;\n\n\t/* Allocate memory for packed Ea. */\n\tea_p = kmalloc(size_add(size, add_bytes), GFP_NOFS);\n\tif (!ea_p)\n\t\treturn -ENOMEM;\n\n\tif (!size) {\n\t\t/* EA info persists, but xattr is empty. Looks like EA problem. */\n\t} else if (attr_ea->non_res) {\n\t\tstruct runs_tree run;\n\n\t\trun_init(&run);\n\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &run, 0, size);\n\t\tif (!err)\n\t\t\terr = ntfs_read_run_nb(sbi, &run, 0, ea_p, size, NULL);\n\t\trun_close(&run);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tvoid *p = resident_data_ex(attr_ea, size);\n\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(ea_p, p, size);\n\t}\n\n\tmemset(Add2Ptr(ea_p, size), 0, add_bytes);\n\t*ea = ea_p;\n\treturn 0;\n\nout:\n\tkfree(ea_p);\n\t*ea = NULL;\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off)) {\n\t\tstruct EA_FULL *ea;\n\t\tsize_t ea_sz;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tea_sz = unpacked_ea_size(ea);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}",
                        "code_after_change": "static noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int ntfs_read_ea(struct ntfs_inode *ni, struct EA_FULL **ea,\n\t\t\tsize_t add_bytes, const struct EA_INFO **info)\n{\n\tint err;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct ATTRIB *attr_info, *attr_ea;\n\tvoid *ea_p;\n\tu32 size;\n\n\tstatic_assert(le32_to_cpu(ATTR_EA_INFO) < le32_to_cpu(ATTR_EA));\n\n\t*ea = NULL;\n\t*info = NULL;\n\n\tattr_info =\n\t\tni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, NULL);\n\tattr_ea =\n\t\tni_find_attr(ni, attr_info, &le, ATTR_EA, NULL, 0, NULL, NULL);\n\n\tif (!attr_ea || !attr_info)\n\t\treturn 0;\n\n\t*info = resident_data_ex(attr_info, sizeof(struct EA_INFO));\n\tif (!*info)\n\t\treturn -EINVAL;\n\n\t/* Check Ea limit. */\n\tsize = le32_to_cpu((*info)->size);\n\tif (size > sbi->ea_max_size)\n\t\treturn -EFBIG;\n\n\tif (attr_size(attr_ea) > sbi->ea_max_size)\n\t\treturn -EFBIG;\n\n\t/* Allocate memory for packed Ea. */\n\tea_p = kmalloc(size_add(size, add_bytes), GFP_NOFS);\n\tif (!ea_p)\n\t\treturn -ENOMEM;\n\n\tif (!size) {\n\t\t/* EA info persists, but xattr is empty. Looks like EA problem. */\n\t} else if (attr_ea->non_res) {\n\t\tstruct runs_tree run;\n\n\t\trun_init(&run);\n\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &run, 0, size);\n\t\tif (!err)\n\t\t\terr = ntfs_read_run_nb(sbi, &run, 0, ea_p, size, NULL);\n\t\trun_close(&run);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tvoid *p = resident_data_ex(attr_ea, size);\n\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(ea_p, p, size);\n\t}\n\n\tmemset(Add2Ptr(ea_p, size), 0, add_bytes);\n\t*ea = ea_p;\n\treturn 0;\n\nout:\n\tkfree(ea_p);\n\t*ea = NULL;\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off)) {\n\t\tstruct EA_FULL *ea;\n\t\tsize_t ea_sz;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tea_sz = unpacked_ea_size(ea);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3801,
            "cve_id": "CVE-2022-48502",
            "code_snippet": "static ssize_t ntfs_list_ea(struct ntfs_inode *ni, char *buffer,\n\t\t\t    size_t bytes_per_buffer)\n{\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, size;\n\tint err;\n\tsize_t ret;\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\treturn err;\n\n\tif (!info || !ea_all)\n\t\treturn 0;\n\n\tsize = le32_to_cpu(info->size);\n\n\t/* Enumerate all xattrs. */\n\tfor (ret = 0, off = 0; off < size; off += unpacked_ea_size(ea)) {\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\tif (buffer) {\n\t\t\tif (ret + ea->name_len + 1 > bytes_per_buffer) {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(buffer + ret, ea->name, ea->name_len);\n\t\t\tbuffer[ret + ea->name_len] = 0;\n\t\t}\n\n\t\tret += ea->name_len + 1;\n\t}\n\nout:\n\tkfree(ea_all);\n\treturn err ? err : ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ntfs_get_ea(struct inode *inode, const char *name, size_t name_len,\n\t\t       void *buffer, size_t size, size_t *required)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, len;\n\tint err;\n\n\tif (!(ni->ni_flags & NI_FLAG_EA))\n\t\treturn -ENODATA;\n\n\tif (!required)\n\t\tni_lock(ni);\n\n\tlen = 0;\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info)\n\t\tgoto out;\n\n\t/* Enumerate all xattrs. */\n\tif (!find_ea(ea_all, le32_to_cpu(info->size), name, name_len, &off)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\tea = Add2Ptr(ea_all, off);\n\n\tlen = le16_to_cpu(ea->elength);\n\tif (!buffer) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (len > size) {\n\t\terr = -ERANGE;\n\t\tif (required)\n\t\t\t*required = len;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buffer, ea->name + ea->name_len + 1, len);\n\terr = 0;\n\nout:\n\tkfree(ea_all);\n\tif (!required)\n\t\tni_unlock(ni);\n\n\treturn err ? err : len;\n}",
                        "code_after_change": "static int ntfs_get_ea(struct inode *inode, const char *name, size_t name_len,\n\t\t       void *buffer, size_t size, size_t *required)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, len;\n\tint err;\n\n\tif (!(ni->ni_flags & NI_FLAG_EA))\n\t\treturn -ENODATA;\n\n\tif (!required)\n\t\tni_lock(ni);\n\n\tlen = 0;\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info)\n\t\tgoto out;\n\n\t/* Enumerate all xattrs. */\n\tif (!find_ea(ea_all, le32_to_cpu(info->size), name, name_len, &off,\n\t\t     NULL)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\tea = Add2Ptr(ea_all, off);\n\n\tlen = le16_to_cpu(ea->elength);\n\tif (!buffer) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (len > size) {\n\t\terr = -ERANGE;\n\t\tif (required)\n\t\t\t*required = len;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buffer, ea->name + ea->name_len + 1, len);\n\terr = 0;\n\nout:\n\tkfree(ea_all);\n\tif (!required)\n\t\tni_unlock(ni);\n\n\treturn err ? err : len;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic ssize_t ntfs_list_ea(struct ntfs_inode *ni, char *buffer,\n\t\t\t    size_t bytes_per_buffer)\n{\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, size;\n\tint err;\n\tsize_t ret;\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\treturn err;\n\n\tif (!info || !ea_all)\n\t\treturn 0;\n\n\tsize = le32_to_cpu(info->size);\n\n\t/* Enumerate all xattrs. */\n\tfor (ret = 0, off = 0; off < size; off += unpacked_ea_size(ea)) {\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\tif (buffer) {\n\t\t\tif (ret + ea->name_len + 1 > bytes_per_buffer) {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(buffer + ret, ea->name, ea->name_len);\n\t\t\tbuffer[ret + ea->name_len] = 0;\n\t\t}\n\n\t\tret += ea->name_len + 1;\n\t}\n\nout:\n\tkfree(ea_all);\n\treturn err ? err : ret;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int ntfs_get_ea(struct inode *inode, const char *name, size_t name_len,\n\t\t       void *buffer, size_t size, size_t *required)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, len;\n\tint err;\n\n\tif (!(ni->ni_flags & NI_FLAG_EA))\n\t\treturn -ENODATA;\n\n\tif (!required)\n\t\tni_lock(ni);\n\n\tlen = 0;\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info)\n\t\tgoto out;\n\n\t/* Enumerate all xattrs. */\n\tif (!find_ea(ea_all, le32_to_cpu(info->size), name, name_len, &off)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\tea = Add2Ptr(ea_all, off);\n\n\tlen = le16_to_cpu(ea->elength);\n\tif (!buffer) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (len > size) {\n\t\terr = -ERANGE;\n\t\tif (required)\n\t\t\t*required = len;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buffer, ea->name + ea->name_len + 1, len);\n\terr = 0;\n\nout:\n\tkfree(ea_all);\n\tif (!required)\n\t\tni_unlock(ni);\n\n\treturn err ? err : len;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int ntfs_get_ea(struct inode *inode, const char *name, size_t name_len,\n\t\t       void *buffer, size_t size, size_t *required)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, len;\n\tint err;\n\n\tif (!(ni->ni_flags & NI_FLAG_EA))\n\t\treturn -ENODATA;\n\n\tif (!required)\n\t\tni_lock(ni);\n\n\tlen = 0;\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info)\n\t\tgoto out;\n\n\t/* Enumerate all xattrs. */\n\tif (!find_ea(ea_all, le32_to_cpu(info->size), name, name_len, &off,\n\t\t     NULL)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\tea = Add2Ptr(ea_all, off);\n\n\tlen = le16_to_cpu(ea->elength);\n\tif (!buffer) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (len > size) {\n\t\terr = -ERANGE;\n\t\tif (required)\n\t\t\t*required = len;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buffer, ea->name + ea->name_len + 1, len);\n\terr = 0;\n\nout:\n\tkfree(ea_all);\n\tif (!required)\n\t\tni_unlock(ni);\n\n\treturn err ? err : len;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2711,
            "cve_id": "CVE-2020-35519",
            "code_snippet": "static int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check for the null_x25_address */\n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int x25_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tstruct x25_route *rt;\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out; /* Connect completed during a ERESTARTSYS event */\n\t}\n\n\trc = -ECONNREFUSED;\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\t}\n\n\trc = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tgoto out;\n\n\trc = -EALREADY;\t/* Do nothing if call is already in progress */\n\tif (sk->sk_state == TCP_SYN_SENT)\n\t\tgoto out;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trc = -EINVAL;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25)\n\t\tgoto out;\n\n\trc = -ENETUNREACH;\n\trt = x25_get_route(&addr->sx25_addr);\n\tif (!rt)\n\t\tgoto out;\n\n\tx25->neighbour = x25_get_neigh(rt->dev);\n\tif (!x25->neighbour)\n\t\tgoto out_put_route;\n\n\tx25_limit_facilities(&x25->facilities, x25->neighbour);\n\n\tx25->lci = x25_new_lci(x25->neighbour);\n\tif (!x25->lci)\n\t\tgoto out_put_neigh;\n\n\trc = -EINVAL;\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\tgoto out_put_neigh;\n\n\tif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\n\t\tmemset(&x25->source_addr, '\\0', X25_ADDR_LEN);\n\n\tx25->dest_addr = addr->sx25_addr;\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state  = TCP_SYN_SENT;\n\n\tx25->state = X25_STATE_1;\n\n\tx25_write_internal(sk, X25_CALL_REQUEST);\n\n\tx25_start_heartbeat(sk);\n\tx25_start_t21timer(sk);\n\n\t/* Now the loop */\n\trc = -EINPROGRESS;\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\n\t\tgoto out;\n\n\trc = x25_wait_for_connection_establishment(sk);\n\tif (rc)\n\t\tgoto out_put_neigh;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout_put_neigh:\n\tif (rc && x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t\tx25->state = X25_STATE_0;\n\t}\nout_put_route:\n\tx25_route_put(rt);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}",
                        "code_after_change": "static int x25_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tstruct x25_route *rt;\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out; /* Connect completed during a ERESTARTSYS event */\n\t}\n\n\trc = -ECONNREFUSED;\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\t}\n\n\trc = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tgoto out;\n\n\trc = -EALREADY;\t/* Do nothing if call is already in progress */\n\tif (sk->sk_state == TCP_SYN_SENT)\n\t\tgoto out;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trc = -EINVAL;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN)\n\t\tgoto out;\n\n\trc = -ENETUNREACH;\n\trt = x25_get_route(&addr->sx25_addr);\n\tif (!rt)\n\t\tgoto out;\n\n\tx25->neighbour = x25_get_neigh(rt->dev);\n\tif (!x25->neighbour)\n\t\tgoto out_put_route;\n\n\tx25_limit_facilities(&x25->facilities, x25->neighbour);\n\n\tx25->lci = x25_new_lci(x25->neighbour);\n\tif (!x25->lci)\n\t\tgoto out_put_neigh;\n\n\trc = -EINVAL;\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\tgoto out_put_neigh;\n\n\tif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\n\t\tmemset(&x25->source_addr, '\\0', X25_ADDR_LEN);\n\n\tx25->dest_addr = addr->sx25_addr;\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state  = TCP_SYN_SENT;\n\n\tx25->state = X25_STATE_1;\n\n\tx25_write_internal(sk, X25_CALL_REQUEST);\n\n\tx25_start_heartbeat(sk);\n\tx25_start_t21timer(sk);\n\n\t/* Now the loop */\n\trc = -EINPROGRESS;\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\n\t\tgoto out;\n\n\trc = x25_wait_for_connection_establishment(sk);\n\tif (rc)\n\t\tgoto out_put_neigh;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout_put_neigh:\n\tif (rc && x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t\tx25->state = X25_STATE_0;\n\t}\nout_put_route:\n\tx25_route_put(rt);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}",
                        "cve_id": "CVE-2020-35519"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check for the null_x25_address */\n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int x25_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tstruct x25_route *rt;\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out; /* Connect completed during a ERESTARTSYS event */\n\t}\n\n\trc = -ECONNREFUSED;\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\t}\n\n\trc = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tgoto out;\n\n\trc = -EALREADY;\t/* Do nothing if call is already in progress */\n\tif (sk->sk_state == TCP_SYN_SENT)\n\t\tgoto out;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trc = -EINVAL;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25)\n\t\tgoto out;\n\n\trc = -ENETUNREACH;\n\trt = x25_get_route(&addr->sx25_addr);\n\tif (!rt)\n\t\tgoto out;\n\n\tx25->neighbour = x25_get_neigh(rt->dev);\n\tif (!x25->neighbour)\n\t\tgoto out_put_route;\n\n\tx25_limit_facilities(&x25->facilities, x25->neighbour);\n\n\tx25->lci = x25_new_lci(x25->neighbour);\n\tif (!x25->lci)\n\t\tgoto out_put_neigh;\n\n\trc = -EINVAL;\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\tgoto out_put_neigh;\n\n\tif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\n\t\tmemset(&x25->source_addr, '\\0', X25_ADDR_LEN);\n\n\tx25->dest_addr = addr->sx25_addr;\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state  = TCP_SYN_SENT;\n\n\tx25->state = X25_STATE_1;\n\n\tx25_write_internal(sk, X25_CALL_REQUEST);\n\n\tx25_start_heartbeat(sk);\n\tx25_start_t21timer(sk);\n\n\t/* Now the loop */\n\trc = -EINPROGRESS;\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\n\t\tgoto out;\n\n\trc = x25_wait_for_connection_establishment(sk);\n\tif (rc)\n\t\tgoto out_put_neigh;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout_put_neigh:\n\tif (rc && x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t\tx25->state = X25_STATE_0;\n\t}\nout_put_route:\n\tx25_route_put(rt);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int x25_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tstruct x25_route *rt;\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out; /* Connect completed during a ERESTARTSYS event */\n\t}\n\n\trc = -ECONNREFUSED;\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\t}\n\n\trc = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tgoto out;\n\n\trc = -EALREADY;\t/* Do nothing if call is already in progress */\n\tif (sk->sk_state == TCP_SYN_SENT)\n\t\tgoto out;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trc = -EINVAL;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN)\n\t\tgoto out;\n\n\trc = -ENETUNREACH;\n\trt = x25_get_route(&addr->sx25_addr);\n\tif (!rt)\n\t\tgoto out;\n\n\tx25->neighbour = x25_get_neigh(rt->dev);\n\tif (!x25->neighbour)\n\t\tgoto out_put_route;\n\n\tx25_limit_facilities(&x25->facilities, x25->neighbour);\n\n\tx25->lci = x25_new_lci(x25->neighbour);\n\tif (!x25->lci)\n\t\tgoto out_put_neigh;\n\n\trc = -EINVAL;\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\tgoto out_put_neigh;\n\n\tif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\n\t\tmemset(&x25->source_addr, '\\0', X25_ADDR_LEN);\n\n\tx25->dest_addr = addr->sx25_addr;\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state  = TCP_SYN_SENT;\n\n\tx25->state = X25_STATE_1;\n\n\tx25_write_internal(sk, X25_CALL_REQUEST);\n\n\tx25_start_heartbeat(sk);\n\tx25_start_t21timer(sk);\n\n\t/* Now the loop */\n\trc = -EINPROGRESS;\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\n\t\tgoto out;\n\n\trc = x25_wait_for_connection_establishment(sk);\n\tif (rc)\n\t\tgoto out_put_neigh;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout_put_neigh:\n\tif (rc && x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t\tx25->state = X25_STATE_0;\n\t}\nout_put_route:\n\tx25_route_put(rt);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3796,
            "cve_id": "CVE-2022-48502",
            "code_snippet": "struct inode *ntfs_iget5(struct super_block *sb, const struct MFT_REF *ref,\n\t\t\t const struct cpu_str *name)\n{\n\tstruct inode *inode;\n\n\tinode = iget5_locked(sb, ino_get(ref), ntfs_test_inode, ntfs_set_inode,\n\t\t\t     (void *)ref);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (inode->i_state & I_NEW)\n\t\tinode = ntfs_read_mft(inode, name, ref);\n\telse if (ref->seq != ntfs_i(inode)->mi.mrec->seq) {\n\t\t/* Inode overlaps? */\n\t\t_ntfs_bad_inode(inode);\n\t}\n\n\treturn inode;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstruct inode *ntfs_iget5(struct super_block *sb, const struct MFT_REF *ref,\n\t\t\t const struct cpu_str *name)\n{\n\tstruct inode *inode;\n\n\tinode = iget5_locked(sb, ino_get(ref), ntfs_test_inode, ntfs_set_inode,\n\t\t\t     (void *)ref);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (inode->i_state & I_NEW)\n\t\tinode = ntfs_read_mft(inode, name, ref);\n\telse if (ref->seq != ntfs_i(inode)->mi.mrec->seq) {\n\t\t/* Inode overlaps? */\n\t\t_ntfs_bad_inode(inode);\n\t}\n\n\treturn inode;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,\n\t\t\t\tstruct inode *dir, struct dentry *dentry,\n\t\t\t\tconst struct cpu_str *uni, umode_t mode,\n\t\t\t\tdev_t dev, const char *symname, u32 size,\n\t\t\t\tstruct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tconst struct qstr *name = &dentry->d_name;\n\tCLST ino = 0;\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct ntfs_inode *ni = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_STD_INFO5 *std5;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct MFT_REC *rec;\n\tu32 asize, dsize, sd_size;\n\tenum FILE_ATTRIBUTE fa;\n\t__le32 security_id = SECURITY_ID_INVALID;\n\tCLST vcn;\n\tconst void *sd;\n\tu16 t16, nsize = 0, aid = 0;\n\tstruct INDEX_ROOT *root, *dir_root;\n\tstruct NTFS_DE *e, *new_de = NULL;\n\tstruct REPARSE_DATA_BUFFER *rp = NULL;\n\tbool rp_inserted = false;\n\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\n\tdir_root = indx_get_root(&dir_ni->dir, dir_ni, NULL, NULL);\n\tif (!dir_root) {\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\t/* Use parent's directory attributes. */\n\t\tfa = dir_ni->std_fa | FILE_ATTRIBUTE_DIRECTORY |\n\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t/*\n\t\t * By default child directory inherits parent attributes.\n\t\t * Root directory is hidden + system.\n\t\t * Make an exception for children in root.\n\t\t */\n\t\tif (dir->i_ino == MFT_REC_ROOT)\n\t\t\tfa &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);\n\t} else if (S_ISLNK(mode)) {\n\t\t/* It is good idea that link should be the same type (file/dir) as target */\n\t\tfa = FILE_ATTRIBUTE_REPARSE_POINT;\n\n\t\t/*\n\t\t * Linux: there are dir/file/symlink and so on.\n\t\t * NTFS: symlinks are \"dir + reparse\" or \"file + reparse\"\n\t\t * It is good idea to create:\n\t\t * dir + reparse if 'symname' points to directory\n\t\t * or\n\t\t * file + reparse if 'symname' points to file\n\t\t * Unfortunately kern_path hangs if symname contains 'dir'.\n\t\t */\n\n\t\t/*\n\t\t *\tstruct path path;\n\t\t *\n\t\t *\tif (!kern_path(symname, LOOKUP_FOLLOW, &path)){\n\t\t *\t\tstruct inode *target = d_inode(path.dentry);\n\t\t *\n\t\t *\t\tif (S_ISDIR(target->i_mode))\n\t\t *\t\t\tfa |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t *\t\t// if ( target->i_sb == sb ){\n\t\t *\t\t//\tuse relative path?\n\t\t *\t\t// }\n\t\t *\t\tpath_put(&path);\n\t\t *\t}\n\t\t */\n\t} else if (S_ISREG(mode)) {\n\t\tif (sbi->options->sparse) {\n\t\t\t/* Sparsed regular file, cause option 'sparse'. */\n\t\t\tfa = FILE_ATTRIBUTE_SPARSE_FILE |\n\t\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\t/* Compressed regular file, if parent is compressed. */\n\t\t\tfa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else {\n\t\t\t/* Regular file, default attributes. */\n\t\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t\t}\n\t} else {\n\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t}\n\n\t/* If option \"hide_dot_files\" then set hidden attribute for dot files. */\n\tif (sbi->options->hide_dot_files && name->name[0] == '.')\n\t\tfa |= FILE_ATTRIBUTE_HIDDEN;\n\n\tif (!(mode & 0222))\n\t\tfa |= FILE_ATTRIBUTE_READONLY;\n\n\t/* Allocate PATH_MAX bytes. */\n\tnew_de = __getname();\n\tif (!new_de) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Mark rw ntfs as dirty. it will be cleared at umount. */\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t/* Step 1: allocate and fill new mft record. */\n\terr = ntfs_look_free_mft(sbi, &ino, false, NULL, NULL);\n\tif (err)\n\t\tgoto out2;\n\n\tni = ntfs_new_inode(sbi, ino, fa & FILE_ATTRIBUTE_DIRECTORY);\n\tif (IS_ERR(ni)) {\n\t\terr = PTR_ERR(ni);\n\t\tni = NULL;\n\t\tgoto out3;\n\t}\n\tinode = &ni->vfs_inode;\n\tinode_init_owner(mnt_userns, inode, dir, mode);\n\tmode = inode->i_mode;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = ni->i_crtime =\n\t\tcurrent_time(inode);\n\n\trec = ni->mi.mrec;\n\trec->hard_links = cpu_to_le16(1);\n\tattr = Add2Ptr(rec, le16_to_cpu(rec->attr_off));\n\n\t/* Get default security id. */\n\tsd = s_default_security;\n\tsd_size = sizeof(s_default_security);\n\n\tif (is_ntfs3(sbi)) {\n\t\tsecurity_id = dir_ni->std_security_id;\n\t\tif (le32_to_cpu(security_id) < SECURITY_ID_FIRST) {\n\t\t\tsecurity_id = sbi->security.def_security_id;\n\n\t\t\tif (security_id == SECURITY_ID_INVALID &&\n\t\t\t    !ntfs_insert_security(sbi, sd, sd_size,\n\t\t\t\t\t\t  &security_id, NULL))\n\t\t\t\tsbi->security.def_security_id = security_id;\n\t\t}\n\t}\n\n\t/* Insert standard info. */\n\tstd5 = Add2Ptr(attr, SIZEOF_RESIDENT);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\tdsize = sizeof(struct ATTR_STD_INFO);\n\t} else {\n\t\tdsize = sizeof(struct ATTR_STD_INFO5);\n\t\tstd5->security_id = security_id;\n\t\tni->std_security_id = security_id;\n\t}\n\tasize = SIZEOF_RESIDENT + dsize;\n\n\tattr->type = ATTR_STD;\n\tattr->size = cpu_to_le32(asize);\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.data_size = cpu_to_le32(dsize);\n\n\tstd5->cr_time = std5->m_time = std5->c_time = std5->a_time =\n\t\tkernel2nt(&inode->i_atime);\n\n\tni->std_fa = fa;\n\tstd5->fa = fa;\n\n\tattr = Add2Ptr(attr, asize);\n\n\t/* Insert file name. */\n\terr = fill_name_de(sbi, new_de, name, uni);\n\tif (err)\n\t\tgoto out4;\n\n\tmi_get_ref(&ni->mi, &new_de->ref);\n\n\tfname = (struct ATTR_FILE_NAME *)(new_de + 1);\n\n\tif (sbi->options->windows_names &&\n\t    !valid_windows_name(sbi, (struct le_str *)&fname->name_len)) {\n\t\terr = -EINVAL;\n\t\tgoto out4;\n\t}\n\n\tmi_get_ref(&dir_ni->mi, &fname->home);\n\tfname->dup.cr_time = fname->dup.m_time = fname->dup.c_time =\n\t\tfname->dup.a_time = std5->cr_time;\n\tfname->dup.alloc_size = fname->dup.data_size = 0;\n\tfname->dup.fa = std5->fa;\n\tfname->dup.ea_size = fname->dup.reparse = 0;\n\n\tdsize = le16_to_cpu(new_de->key_size);\n\tasize = ALIGN(SIZEOF_RESIDENT + dsize, 8);\n\n\tattr->type = ATTR_NAME;\n\tattr->size = cpu_to_le32(asize);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.flags = RESIDENT_FLAG_INDEXED;\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_size = cpu_to_le32(dsize);\n\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), fname, dsize);\n\n\tattr = Add2Ptr(attr, asize);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\t/* Insert security attribute. */\n\t\tasize = SIZEOF_RESIDENT + ALIGN(sd_size, 8);\n\n\t\tattr->type = ATTR_SECURE;\n\t\tattr->size = cpu_to_le32(asize);\n\t\tattr->id = cpu_to_le16(aid++);\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_size = cpu_to_le32(sd_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), sd, sd_size);\n\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\tattr->id = cpu_to_le16(aid++);\n\tif (fa & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t/*\n\t\t * Regular directory or symlink to directory.\n\t\t * Create root attribute.\n\t\t */\n\t\tdsize = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE);\n\t\tasize = sizeof(I30_NAME) + SIZEOF_RESIDENT + dsize;\n\n\t\tattr->type = ATTR_ROOT;\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\tattr->name_len = ARRAY_SIZE(I30_NAME);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off =\n\t\t\tcpu_to_le16(sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tattr->res.data_size = cpu_to_le32(dsize);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), I30_NAME,\n\t\t       sizeof(I30_NAME));\n\n\t\troot = Add2Ptr(attr, sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tmemcpy(root, dir_root, offsetof(struct INDEX_ROOT, ihdr));\n\t\troot->ihdr.de_off =\n\t\t\tcpu_to_le32(sizeof(struct INDEX_HDR)); // 0x10\n\t\troot->ihdr.used = cpu_to_le32(sizeof(struct INDEX_HDR) +\n\t\t\t\t\t      sizeof(struct NTFS_DE));\n\t\troot->ihdr.total = root->ihdr.used;\n\n\t\te = Add2Ptr(root, sizeof(struct INDEX_ROOT));\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST;\n\t} else if (S_ISLNK(mode)) {\n\t\t/*\n\t\t * Symlink to file.\n\t\t * Create empty resident data attribute.\n\t\t */\n\t\tasize = SIZEOF_RESIDENT;\n\n\t\t/* Insert empty ATTR_DATA */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t} else if (S_ISREG(mode)) {\n\t\t/*\n\t\t * Regular file. Create empty non resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->non_res = 1;\n\t\tattr->nres.evcn = cpu_to_le64(-1ll);\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tasize = SIZEOF_NONRESIDENT + 8;\n\t\t}\n\t\tattr->nres.run_off = attr->name_off;\n\t} else {\n\t\t/*\n\t\t * Node. Create empty resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\telse if (fa & FILE_ATTRIBUTE_COMPRESSED)\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tasize = SIZEOF_RESIDENT;\n\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out4;\n\t} else if (S_ISLNK(mode)) {\n\t\trp = ntfs_create_reparse_buffer(sbi, symname, size, &nsize);\n\n\t\tif (IS_ERR(rp)) {\n\t\t\terr = PTR_ERR(rp);\n\t\t\trp = NULL;\n\t\t\tgoto out4;\n\t\t}\n\n\t\t/*\n\t\t * Insert ATTR_REPARSE.\n\t\t */\n\t\tattr = Add2Ptr(attr, asize);\n\t\tattr->type = ATTR_REPARSE;\n\t\tattr->id = cpu_to_le16(aid++);\n\n\t\t/* Resident or non resident? */\n\t\tasize = ALIGN(SIZEOF_RESIDENT + nsize, 8);\n\t\tt16 = PtrOffset(rec, attr);\n\n\t\t/*\n\t\t * Below function 'ntfs_save_wsl_perm' requires 0x78 bytes.\n\t\t * It is good idea to keep extened attributes resident.\n\t\t */\n\t\tif (asize + t16 + 0x78 + 8 > sbi->record_size) {\n\t\t\tCLST alen;\n\t\t\tCLST clst = bytes_to_cluster(sbi, nsize);\n\n\t\t\t/* Bytes per runs. */\n\t\t\tt16 = sbi->record_size - t16 - SIZEOF_NONRESIDENT;\n\n\t\t\tattr->non_res = 1;\n\t\t\tattr->nres.evcn = cpu_to_le64(clst - 1);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tattr->nres.run_off = attr->name_off;\n\t\t\tattr->nres.data_size = cpu_to_le64(nsize);\n\t\t\tattr->nres.valid_size = attr->nres.data_size;\n\t\t\tattr->nres.alloc_size =\n\t\t\t\tcpu_to_le64(ntfs_up_cluster(sbi, nsize));\n\n\t\t\terr = attr_allocate_clusters(sbi, &ni->file.run, 0, 0,\n\t\t\t\t\t\t     clst, NULL, ALLOCATE_DEF,\n\t\t\t\t\t\t     &alen, 0, NULL, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out5;\n\n\t\t\terr = run_pack(&ni->file.run, 0, clst,\n\t\t\t\t       Add2Ptr(attr, SIZEOF_NONRESIDENT), t16,\n\t\t\t\t       &vcn);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out5;\n\n\t\t\tif (vcn != clst) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out5;\n\t\t\t}\n\n\t\t\tasize = SIZEOF_NONRESIDENT + ALIGN(err, 8);\n\t\t} else {\n\t\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\t\tattr->res.data_size = cpu_to_le32(nsize);\n\t\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), rp, nsize);\n\t\t\tnsize = 0;\n\t\t}\n\t\t/* Size of symlink equals the length of input string. */\n\t\tinode->i_size = size;\n\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\terr = ntfs_insert_reparse(sbi, IO_REPARSE_TAG_SYMLINK,\n\t\t\t\t\t  &new_de->ref);\n\t\tif (err)\n\t\t\tgoto out5;\n\n\t\trp_inserted = true;\n\t}\n\n\tattr = Add2Ptr(attr, asize);\n\tattr->type = ATTR_END;\n\n\trec->used = cpu_to_le32(PtrOffset(rec, attr) + 8);\n\trec->next_attr_id = cpu_to_le16(aid);\n\n\t/* Step 2: Add new name in index. */\n\terr = indx_insert_entry(&dir_ni->dir, dir_ni, new_de, sbi, fnd, 0);\n\tif (err)\n\t\tgoto out6;\n\n\t/* Unlock parent directory before ntfs_init_acl. */\n\tif (!fnd)\n\t\tni_unlock(dir_ni);\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\tdir->i_mtime = dir->i_ctime = inode->i_atime;\n\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode->i_mapping->a_ops = &ntfs_aops;\n\t\tinode->i_size = size;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tinit_rwsem(&ni->file.run_lock);\n\t} else {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, dev);\n\t}\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\tif (!S_ISLNK(mode) && (sb->s_flags & SB_POSIXACL)) {\n\t\terr = ntfs_init_acl(mnt_userns, inode, dir);\n\t\tif (err)\n\t\t\tgoto out7;\n\t} else\n#endif\n\t{\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\t/* Write non resident data. */\n\tif (nsize) {\n\t\terr = ntfs_sb_write_run(sbi, &ni->file.run, 0, rp, nsize, 0);\n\t\tif (err)\n\t\t\tgoto out7;\n\t}\n\n\t/*\n\t * Call 'd_instantiate' after inode->i_op is set\n\t * but before finish_open.\n\t */\n\td_instantiate(dentry, inode);\n\n\tntfs_save_wsl_perm(inode);\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\t/* Normal exit. */\n\tgoto out2;\n\nout7:\n\n\t/* Undo 'indx_insert_entry'. */\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\tindx_delete_entry(&dir_ni->dir, dir_ni, new_de + 1,\n\t\t\t  le16_to_cpu(new_de->key_size), sbi);\n\t/* ni_unlock(dir_ni); will be called later. */\nout6:\n\tif (rp_inserted)\n\t\tntfs_remove_reparse(sbi, IO_REPARSE_TAG_SYMLINK, &new_de->ref);\n\nout5:\n\tif (S_ISDIR(mode) || run_is_empty(&ni->file.run))\n\t\tgoto out4;\n\n\trun_deallocate(sbi, &ni->file.run, false);\n\nout4:\n\tclear_rec_inuse(rec);\n\tclear_nlink(inode);\n\tni->mi.dirty = false;\n\tdiscard_new_inode(inode);\nout3:\n\tntfs_mark_rec_free(sbi, ino, false);\n\nout2:\n\t__putname(new_de);\n\tkfree(rp);\n\nout1:\n\tif (err) {\n\t\tif (!fnd)\n\t\t\tni_unlock(dir_ni);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
                        "code_after_change": "struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,\n\t\t\t\tstruct inode *dir, struct dentry *dentry,\n\t\t\t\tconst struct cpu_str *uni, umode_t mode,\n\t\t\t\tdev_t dev, const char *symname, u32 size,\n\t\t\t\tstruct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tconst struct qstr *name = &dentry->d_name;\n\tCLST ino = 0;\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct ntfs_inode *ni = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_STD_INFO5 *std5;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct MFT_REC *rec;\n\tu32 asize, dsize, sd_size;\n\tenum FILE_ATTRIBUTE fa;\n\t__le32 security_id = SECURITY_ID_INVALID;\n\tCLST vcn;\n\tconst void *sd;\n\tu16 t16, nsize = 0, aid = 0;\n\tstruct INDEX_ROOT *root, *dir_root;\n\tstruct NTFS_DE *e, *new_de = NULL;\n\tstruct REPARSE_DATA_BUFFER *rp = NULL;\n\tbool rp_inserted = false;\n\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\n\tdir_root = indx_get_root(&dir_ni->dir, dir_ni, NULL, NULL);\n\tif (!dir_root) {\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\t/* Use parent's directory attributes. */\n\t\tfa = dir_ni->std_fa | FILE_ATTRIBUTE_DIRECTORY |\n\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t/*\n\t\t * By default child directory inherits parent attributes.\n\t\t * Root directory is hidden + system.\n\t\t * Make an exception for children in root.\n\t\t */\n\t\tif (dir->i_ino == MFT_REC_ROOT)\n\t\t\tfa &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);\n\t} else if (S_ISLNK(mode)) {\n\t\t/* It is good idea that link should be the same type (file/dir) as target */\n\t\tfa = FILE_ATTRIBUTE_REPARSE_POINT;\n\n\t\t/*\n\t\t * Linux: there are dir/file/symlink and so on.\n\t\t * NTFS: symlinks are \"dir + reparse\" or \"file + reparse\"\n\t\t * It is good idea to create:\n\t\t * dir + reparse if 'symname' points to directory\n\t\t * or\n\t\t * file + reparse if 'symname' points to file\n\t\t * Unfortunately kern_path hangs if symname contains 'dir'.\n\t\t */\n\n\t\t/*\n\t\t *\tstruct path path;\n\t\t *\n\t\t *\tif (!kern_path(symname, LOOKUP_FOLLOW, &path)){\n\t\t *\t\tstruct inode *target = d_inode(path.dentry);\n\t\t *\n\t\t *\t\tif (S_ISDIR(target->i_mode))\n\t\t *\t\t\tfa |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t *\t\t// if ( target->i_sb == sb ){\n\t\t *\t\t//\tuse relative path?\n\t\t *\t\t// }\n\t\t *\t\tpath_put(&path);\n\t\t *\t}\n\t\t */\n\t} else if (S_ISREG(mode)) {\n\t\tif (sbi->options->sparse) {\n\t\t\t/* Sparsed regular file, cause option 'sparse'. */\n\t\t\tfa = FILE_ATTRIBUTE_SPARSE_FILE |\n\t\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\t/* Compressed regular file, if parent is compressed. */\n\t\t\tfa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else {\n\t\t\t/* Regular file, default attributes. */\n\t\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t\t}\n\t} else {\n\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t}\n\n\t/* If option \"hide_dot_files\" then set hidden attribute for dot files. */\n\tif (sbi->options->hide_dot_files && name->name[0] == '.')\n\t\tfa |= FILE_ATTRIBUTE_HIDDEN;\n\n\tif (!(mode & 0222))\n\t\tfa |= FILE_ATTRIBUTE_READONLY;\n\n\t/* Allocate PATH_MAX bytes. */\n\tnew_de = __getname();\n\tif (!new_de) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Mark rw ntfs as dirty. it will be cleared at umount. */\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t/* Step 1: allocate and fill new mft record. */\n\terr = ntfs_look_free_mft(sbi, &ino, false, NULL, NULL);\n\tif (err)\n\t\tgoto out2;\n\n\tni = ntfs_new_inode(sbi, ino, fa & FILE_ATTRIBUTE_DIRECTORY);\n\tif (IS_ERR(ni)) {\n\t\terr = PTR_ERR(ni);\n\t\tni = NULL;\n\t\tgoto out3;\n\t}\n\tinode = &ni->vfs_inode;\n\tinode_init_owner(mnt_userns, inode, dir, mode);\n\tmode = inode->i_mode;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = ni->i_crtime =\n\t\tcurrent_time(inode);\n\n\trec = ni->mi.mrec;\n\trec->hard_links = cpu_to_le16(1);\n\tattr = Add2Ptr(rec, le16_to_cpu(rec->attr_off));\n\n\t/* Get default security id. */\n\tsd = s_default_security;\n\tsd_size = sizeof(s_default_security);\n\n\tif (is_ntfs3(sbi)) {\n\t\tsecurity_id = dir_ni->std_security_id;\n\t\tif (le32_to_cpu(security_id) < SECURITY_ID_FIRST) {\n\t\t\tsecurity_id = sbi->security.def_security_id;\n\n\t\t\tif (security_id == SECURITY_ID_INVALID &&\n\t\t\t    !ntfs_insert_security(sbi, sd, sd_size,\n\t\t\t\t\t\t  &security_id, NULL))\n\t\t\t\tsbi->security.def_security_id = security_id;\n\t\t}\n\t}\n\n\t/* Insert standard info. */\n\tstd5 = Add2Ptr(attr, SIZEOF_RESIDENT);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\tdsize = sizeof(struct ATTR_STD_INFO);\n\t} else {\n\t\tdsize = sizeof(struct ATTR_STD_INFO5);\n\t\tstd5->security_id = security_id;\n\t\tni->std_security_id = security_id;\n\t}\n\tasize = SIZEOF_RESIDENT + dsize;\n\n\tattr->type = ATTR_STD;\n\tattr->size = cpu_to_le32(asize);\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.data_size = cpu_to_le32(dsize);\n\n\tstd5->cr_time = std5->m_time = std5->c_time = std5->a_time =\n\t\tkernel2nt(&inode->i_atime);\n\n\tni->std_fa = fa;\n\tstd5->fa = fa;\n\n\tattr = Add2Ptr(attr, asize);\n\n\t/* Insert file name. */\n\terr = fill_name_de(sbi, new_de, name, uni);\n\tif (err)\n\t\tgoto out4;\n\n\tmi_get_ref(&ni->mi, &new_de->ref);\n\n\tfname = (struct ATTR_FILE_NAME *)(new_de + 1);\n\n\tif (sbi->options->windows_names &&\n\t    !valid_windows_name(sbi, (struct le_str *)&fname->name_len)) {\n\t\terr = -EINVAL;\n\t\tgoto out4;\n\t}\n\n\tmi_get_ref(&dir_ni->mi, &fname->home);\n\tfname->dup.cr_time = fname->dup.m_time = fname->dup.c_time =\n\t\tfname->dup.a_time = std5->cr_time;\n\tfname->dup.alloc_size = fname->dup.data_size = 0;\n\tfname->dup.fa = std5->fa;\n\tfname->dup.ea_size = fname->dup.reparse = 0;\n\n\tdsize = le16_to_cpu(new_de->key_size);\n\tasize = ALIGN(SIZEOF_RESIDENT + dsize, 8);\n\n\tattr->type = ATTR_NAME;\n\tattr->size = cpu_to_le32(asize);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.flags = RESIDENT_FLAG_INDEXED;\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_size = cpu_to_le32(dsize);\n\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), fname, dsize);\n\n\tattr = Add2Ptr(attr, asize);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\t/* Insert security attribute. */\n\t\tasize = SIZEOF_RESIDENT + ALIGN(sd_size, 8);\n\n\t\tattr->type = ATTR_SECURE;\n\t\tattr->size = cpu_to_le32(asize);\n\t\tattr->id = cpu_to_le16(aid++);\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_size = cpu_to_le32(sd_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), sd, sd_size);\n\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\tattr->id = cpu_to_le16(aid++);\n\tif (fa & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t/*\n\t\t * Regular directory or symlink to directory.\n\t\t * Create root attribute.\n\t\t */\n\t\tdsize = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE);\n\t\tasize = sizeof(I30_NAME) + SIZEOF_RESIDENT + dsize;\n\n\t\tattr->type = ATTR_ROOT;\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\tattr->name_len = ARRAY_SIZE(I30_NAME);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off =\n\t\t\tcpu_to_le16(sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tattr->res.data_size = cpu_to_le32(dsize);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), I30_NAME,\n\t\t       sizeof(I30_NAME));\n\n\t\troot = Add2Ptr(attr, sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tmemcpy(root, dir_root, offsetof(struct INDEX_ROOT, ihdr));\n\t\troot->ihdr.de_off =\n\t\t\tcpu_to_le32(sizeof(struct INDEX_HDR)); // 0x10\n\t\troot->ihdr.used = cpu_to_le32(sizeof(struct INDEX_HDR) +\n\t\t\t\t\t      sizeof(struct NTFS_DE));\n\t\troot->ihdr.total = root->ihdr.used;\n\n\t\te = Add2Ptr(root, sizeof(struct INDEX_ROOT));\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST;\n\t} else if (S_ISLNK(mode)) {\n\t\t/*\n\t\t * Symlink to file.\n\t\t * Create empty resident data attribute.\n\t\t */\n\t\tasize = SIZEOF_RESIDENT;\n\n\t\t/* Insert empty ATTR_DATA */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t} else if (S_ISREG(mode)) {\n\t\t/*\n\t\t * Regular file. Create empty non resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->non_res = 1;\n\t\tattr->nres.evcn = cpu_to_le64(-1ll);\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tasize = SIZEOF_NONRESIDENT + 8;\n\t\t}\n\t\tattr->nres.run_off = attr->name_off;\n\t} else {\n\t\t/*\n\t\t * Node. Create empty resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\telse if (fa & FILE_ATTRIBUTE_COMPRESSED)\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tasize = SIZEOF_RESIDENT;\n\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out4;\n\t} else if (S_ISLNK(mode)) {\n\t\trp = ntfs_create_reparse_buffer(sbi, symname, size, &nsize);\n\n\t\tif (IS_ERR(rp)) {\n\t\t\terr = PTR_ERR(rp);\n\t\t\trp = NULL;\n\t\t\tgoto out4;\n\t\t}\n\n\t\t/*\n\t\t * Insert ATTR_REPARSE.\n\t\t */\n\t\tattr = Add2Ptr(attr, asize);\n\t\tattr->type = ATTR_REPARSE;\n\t\tattr->id = cpu_to_le16(aid++);\n\n\t\t/* Resident or non resident? */\n\t\tasize = ALIGN(SIZEOF_RESIDENT + nsize, 8);\n\t\tt16 = PtrOffset(rec, attr);\n\n\t\t/*\n\t\t * Below function 'ntfs_save_wsl_perm' requires 0x78 bytes.\n\t\t * It is good idea to keep extened attributes resident.\n\t\t */\n\t\tif (asize + t16 + 0x78 + 8 > sbi->record_size) {\n\t\t\tCLST alen;\n\t\t\tCLST clst = bytes_to_cluster(sbi, nsize);\n\n\t\t\t/* Bytes per runs. */\n\t\t\tt16 = sbi->record_size - t16 - SIZEOF_NONRESIDENT;\n\n\t\t\tattr->non_res = 1;\n\t\t\tattr->nres.evcn = cpu_to_le64(clst - 1);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tattr->nres.run_off = attr->name_off;\n\t\t\tattr->nres.data_size = cpu_to_le64(nsize);\n\t\t\tattr->nres.valid_size = attr->nres.data_size;\n\t\t\tattr->nres.alloc_size =\n\t\t\t\tcpu_to_le64(ntfs_up_cluster(sbi, nsize));\n\n\t\t\terr = attr_allocate_clusters(sbi, &ni->file.run, 0, 0,\n\t\t\t\t\t\t     clst, NULL, ALLOCATE_DEF,\n\t\t\t\t\t\t     &alen, 0, NULL, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out5;\n\n\t\t\terr = run_pack(&ni->file.run, 0, clst,\n\t\t\t\t       Add2Ptr(attr, SIZEOF_NONRESIDENT), t16,\n\t\t\t\t       &vcn);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out5;\n\n\t\t\tif (vcn != clst) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out5;\n\t\t\t}\n\n\t\t\tasize = SIZEOF_NONRESIDENT + ALIGN(err, 8);\n\t\t} else {\n\t\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\t\tattr->res.data_size = cpu_to_le32(nsize);\n\t\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), rp, nsize);\n\t\t\tnsize = 0;\n\t\t}\n\t\t/* Size of symlink equals the length of input string. */\n\t\tinode->i_size = size;\n\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\terr = ntfs_insert_reparse(sbi, IO_REPARSE_TAG_SYMLINK,\n\t\t\t\t\t  &new_de->ref);\n\t\tif (err)\n\t\t\tgoto out5;\n\n\t\trp_inserted = true;\n\t}\n\n\tattr = Add2Ptr(attr, asize);\n\tattr->type = ATTR_END;\n\n\trec->used = cpu_to_le32(PtrOffset(rec, attr) + 8);\n\trec->next_attr_id = cpu_to_le16(aid);\n\n\t/* Step 2: Add new name in index. */\n\terr = indx_insert_entry(&dir_ni->dir, dir_ni, new_de, sbi, fnd, 0);\n\tif (err)\n\t\tgoto out6;\n\n\t/* Unlock parent directory before ntfs_init_acl. */\n\tif (!fnd)\n\t\tni_unlock(dir_ni);\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\tdir->i_mtime = dir->i_ctime = inode->i_atime;\n\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode->i_mapping->a_ops = &ntfs_aops;\n\t\tinode->i_size = size;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tinit_rwsem(&ni->file.run_lock);\n\t} else {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, dev);\n\t}\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\tif (!S_ISLNK(mode) && (sb->s_flags & SB_POSIXACL)) {\n\t\terr = ntfs_init_acl(mnt_userns, inode, dir);\n\t\tif (err)\n\t\t\tgoto out7;\n\t} else\n#endif\n\t{\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\t/* Write non resident data. */\n\tif (nsize) {\n\t\terr = ntfs_sb_write_run(sbi, &ni->file.run, 0, rp, nsize, 0);\n\t\tif (err)\n\t\t\tgoto out7;\n\t}\n\n\t/*\n\t * Call 'd_instantiate' after inode->i_op is set\n\t * but before finish_open.\n\t */\n\td_instantiate(dentry, inode);\n\n\tntfs_save_wsl_perm(inode);\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\t/* Normal exit. */\n\tgoto out2;\n\nout7:\n\n\t/* Undo 'indx_insert_entry'. */\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\tindx_delete_entry(&dir_ni->dir, dir_ni, new_de + 1,\n\t\t\t  le16_to_cpu(new_de->key_size), sbi);\n\t/* ni_unlock(dir_ni); will be called later. */\nout6:\n\tif (rp_inserted)\n\t\tntfs_remove_reparse(sbi, IO_REPARSE_TAG_SYMLINK, &new_de->ref);\n\nout5:\n\tif (!S_ISDIR(mode))\n\t\trun_deallocate(sbi, &ni->file.run, false);\n\nout4:\n\tclear_rec_inuse(rec);\n\tclear_nlink(inode);\n\tni->mi.dirty = false;\n\tdiscard_new_inode(inode);\nout3:\n\tntfs_mark_rec_free(sbi, ino, false);\n\nout2:\n\t__putname(new_de);\n\tkfree(rp);\n\nout1:\n\tif (err) {\n\t\tif (!fnd)\n\t\t\tni_unlock(dir_ni);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstruct inode *ntfs_iget5(struct super_block *sb, const struct MFT_REF *ref,\n\t\t\t const struct cpu_str *name)\n{\n\tstruct inode *inode;\n\n\tinode = iget5_locked(sb, ino_get(ref), ntfs_test_inode, ntfs_set_inode,\n\t\t\t     (void *)ref);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (inode->i_state & I_NEW)\n\t\tinode = ntfs_read_mft(inode, name, ref);\n\telse if (ref->seq != ntfs_i(inode)->mi.mrec->seq) {\n\t\t/* Inode overlaps? */\n\t\t_ntfs_bad_inode(inode);\n\t}\n\n\treturn inode;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstruct inode *ntfs_create_inode(struct user_namespace *mnt_userns,\n\t\t\t\tstruct inode *dir, struct dentry *dentry,\n\t\t\t\tconst struct cpu_str *uni, umode_t mode,\n\t\t\t\tdev_t dev, const char *symname, u32 size,\n\t\t\t\tstruct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tconst struct qstr *name = &dentry->d_name;\n\tCLST ino = 0;\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct ntfs_inode *ni = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_STD_INFO5 *std5;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct MFT_REC *rec;\n\tu32 asize, dsize, sd_size;\n\tenum FILE_ATTRIBUTE fa;\n\t__le32 security_id = SECURITY_ID_INVALID;\n\tCLST vcn;\n\tconst void *sd;\n\tu16 t16, nsize = 0, aid = 0;\n\tstruct INDEX_ROOT *root, *dir_root;\n\tstruct NTFS_DE *e, *new_de = NULL;\n\tstruct REPARSE_DATA_BUFFER *rp = NULL;\n\tbool rp_inserted = false;\n\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\n\tdir_root = indx_get_root(&dir_ni->dir, dir_ni, NULL, NULL);\n\tif (!dir_root) {\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\t/* Use parent's directory attributes. */\n\t\tfa = dir_ni->std_fa | FILE_ATTRIBUTE_DIRECTORY |\n\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t/*\n\t\t * By default child directory inherits parent attributes.\n\t\t * Root directory is hidden + system.\n\t\t * Make an exception for children in root.\n\t\t */\n\t\tif (dir->i_ino == MFT_REC_ROOT)\n\t\t\tfa &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);\n\t} else if (S_ISLNK(mode)) {\n\t\t/* It is good idea that link should be the same type (file/dir) as target */\n\t\tfa = FILE_ATTRIBUTE_REPARSE_POINT;\n\n\t\t/*\n\t\t * Linux: there are dir/file/symlink and so on.\n\t\t * NTFS: symlinks are \"dir + reparse\" or \"file + reparse\"\n\t\t * It is good idea to create:\n\t\t * dir + reparse if 'symname' points to directory\n\t\t * or\n\t\t * file + reparse if 'symname' points to file\n\t\t * Unfortunately kern_path hangs if symname contains 'dir'.\n\t\t */\n\n\t\t/*\n\t\t *\tstruct path path;\n\t\t *\n\t\t *\tif (!kern_path(symname, LOOKUP_FOLLOW, &path)){\n\t\t *\t\tstruct inode *target = d_inode(path.dentry);\n\t\t *\n\t\t *\t\tif (S_ISDIR(target->i_mode))\n\t\t *\t\t\tfa |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t *\t\t// if ( target->i_sb == sb ){\n\t\t *\t\t//\tuse relative path?\n\t\t *\t\t// }\n\t\t *\t\tpath_put(&path);\n\t\t *\t}\n\t\t */\n\t} else if (S_ISREG(mode)) {\n\t\tif (sbi->options->sparse) {\n\t\t\t/* Sparsed regular file, cause option 'sparse'. */\n\t\t\tfa = FILE_ATTRIBUTE_SPARSE_FILE |\n\t\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\t/* Compressed regular file, if parent is compressed. */\n\t\t\tfa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else {\n\t\t\t/* Regular file, default attributes. */\n\t\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t\t}\n\t} else {\n\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t}\n\n\t/* If option \"hide_dot_files\" then set hidden attribute for dot files. */\n\tif (sbi->options->hide_dot_files && name->name[0] == '.')\n\t\tfa |= FILE_ATTRIBUTE_HIDDEN;\n\n\tif (!(mode & 0222))\n\t\tfa |= FILE_ATTRIBUTE_READONLY;\n\n\t/* Allocate PATH_MAX bytes. */\n\tnew_de = __getname();\n\tif (!new_de) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Mark rw ntfs as dirty. it will be cleared at umount. */\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t/* Step 1: allocate and fill new mft record. */\n\terr = ntfs_look_free_mft(sbi, &ino, false, NULL, NULL);\n\tif (err)\n\t\tgoto out2;\n\n\tni = ntfs_new_inode(sbi, ino, fa & FILE_ATTRIBUTE_DIRECTORY);\n\tif (IS_ERR(ni)) {\n\t\terr = PTR_ERR(ni);\n\t\tni = NULL;\n\t\tgoto out3;\n\t}\n\tinode = &ni->vfs_inode;\n\tinode_init_owner(mnt_userns, inode, dir, mode);\n\tmode = inode->i_mode;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = ni->i_crtime =\n\t\tcurrent_time(inode);\n\n\trec = ni->mi.mrec;\n\trec->hard_links = cpu_to_le16(1);\n\tattr = Add2Ptr(rec, le16_to_cpu(rec->attr_off));\n\n\t/* Get default security id. */\n\tsd = s_default_security;\n\tsd_size = sizeof(s_default_security);\n\n\tif (is_ntfs3(sbi)) {\n\t\tsecurity_id = dir_ni->std_security_id;\n\t\tif (le32_to_cpu(security_id) < SECURITY_ID_FIRST) {\n\t\t\tsecurity_id = sbi->security.def_security_id;\n\n\t\t\tif (security_id == SECURITY_ID_INVALID &&\n\t\t\t    !ntfs_insert_security(sbi, sd, sd_size,\n\t\t\t\t\t\t  &security_id, NULL))\n\t\t\t\tsbi->security.def_security_id = security_id;\n\t\t}\n\t}\n\n\t/* Insert standard info. */\n\tstd5 = Add2Ptr(attr, SIZEOF_RESIDENT);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\tdsize = sizeof(struct ATTR_STD_INFO);\n\t} else {\n\t\tdsize = sizeof(struct ATTR_STD_INFO5);\n\t\tstd5->security_id = security_id;\n\t\tni->std_security_id = security_id;\n\t}\n\tasize = SIZEOF_RESIDENT + dsize;\n\n\tattr->type = ATTR_STD;\n\tattr->size = cpu_to_le32(asize);\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.data_size = cpu_to_le32(dsize);\n\n\tstd5->cr_time = std5->m_time = std5->c_time = std5->a_time =\n\t\tkernel2nt(&inode->i_atime);\n\n\tni->std_fa = fa;\n\tstd5->fa = fa;\n\n\tattr = Add2Ptr(attr, asize);\n\n\t/* Insert file name. */\n\terr = fill_name_de(sbi, new_de, name, uni);\n\tif (err)\n\t\tgoto out4;\n\n\tmi_get_ref(&ni->mi, &new_de->ref);\n\n\tfname = (struct ATTR_FILE_NAME *)(new_de + 1);\n\n\tif (sbi->options->windows_names &&\n\t    !valid_windows_name(sbi, (struct le_str *)&fname->name_len)) {\n\t\terr = -EINVAL;\n\t\tgoto out4;\n\t}\n\n\tmi_get_ref(&dir_ni->mi, &fname->home);\n\tfname->dup.cr_time = fname->dup.m_time = fname->dup.c_time =\n\t\tfname->dup.a_time = std5->cr_time;\n\tfname->dup.alloc_size = fname->dup.data_size = 0;\n\tfname->dup.fa = std5->fa;\n\tfname->dup.ea_size = fname->dup.reparse = 0;\n\n\tdsize = le16_to_cpu(new_de->key_size);\n\tasize = ALIGN(SIZEOF_RESIDENT + dsize, 8);\n\n\tattr->type = ATTR_NAME;\n\tattr->size = cpu_to_le32(asize);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.flags = RESIDENT_FLAG_INDEXED;\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_size = cpu_to_le32(dsize);\n\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), fname, dsize);\n\n\tattr = Add2Ptr(attr, asize);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\t/* Insert security attribute. */\n\t\tasize = SIZEOF_RESIDENT + ALIGN(sd_size, 8);\n\n\t\tattr->type = ATTR_SECURE;\n\t\tattr->size = cpu_to_le32(asize);\n\t\tattr->id = cpu_to_le16(aid++);\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_size = cpu_to_le32(sd_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), sd, sd_size);\n\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\tattr->id = cpu_to_le16(aid++);\n\tif (fa & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t/*\n\t\t * Regular directory or symlink to directory.\n\t\t * Create root attribute.\n\t\t */\n\t\tdsize = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE);\n\t\tasize = sizeof(I30_NAME) + SIZEOF_RESIDENT + dsize;\n\n\t\tattr->type = ATTR_ROOT;\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\tattr->name_len = ARRAY_SIZE(I30_NAME);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off =\n\t\t\tcpu_to_le16(sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tattr->res.data_size = cpu_to_le32(dsize);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), I30_NAME,\n\t\t       sizeof(I30_NAME));\n\n\t\troot = Add2Ptr(attr, sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tmemcpy(root, dir_root, offsetof(struct INDEX_ROOT, ihdr));\n\t\troot->ihdr.de_off =\n\t\t\tcpu_to_le32(sizeof(struct INDEX_HDR)); // 0x10\n\t\troot->ihdr.used = cpu_to_le32(sizeof(struct INDEX_HDR) +\n\t\t\t\t\t      sizeof(struct NTFS_DE));\n\t\troot->ihdr.total = root->ihdr.used;\n\n\t\te = Add2Ptr(root, sizeof(struct INDEX_ROOT));\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST;\n\t} else if (S_ISLNK(mode)) {\n\t\t/*\n\t\t * Symlink to file.\n\t\t * Create empty resident data attribute.\n\t\t */\n\t\tasize = SIZEOF_RESIDENT;\n\n\t\t/* Insert empty ATTR_DATA */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t} else if (S_ISREG(mode)) {\n\t\t/*\n\t\t * Regular file. Create empty non resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->non_res = 1;\n\t\tattr->nres.evcn = cpu_to_le64(-1ll);\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tasize = SIZEOF_NONRESIDENT + 8;\n\t\t}\n\t\tattr->nres.run_off = attr->name_off;\n\t} else {\n\t\t/*\n\t\t * Node. Create empty resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\telse if (fa & FILE_ATTRIBUTE_COMPRESSED)\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tasize = SIZEOF_RESIDENT;\n\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out4;\n\t} else if (S_ISLNK(mode)) {\n\t\trp = ntfs_create_reparse_buffer(sbi, symname, size, &nsize);\n\n\t\tif (IS_ERR(rp)) {\n\t\t\terr = PTR_ERR(rp);\n\t\t\trp = NULL;\n\t\t\tgoto out4;\n\t\t}\n\n\t\t/*\n\t\t * Insert ATTR_REPARSE.\n\t\t */\n\t\tattr = Add2Ptr(attr, asize);\n\t\tattr->type = ATTR_REPARSE;\n\t\tattr->id = cpu_to_le16(aid++);\n\n\t\t/* Resident or non resident? */\n\t\tasize = ALIGN(SIZEOF_RESIDENT + nsize, 8);\n\t\tt16 = PtrOffset(rec, attr);\n\n\t\t/*\n\t\t * Below function 'ntfs_save_wsl_perm' requires 0x78 bytes.\n\t\t * It is good idea to keep extened attributes resident.\n\t\t */\n\t\tif (asize + t16 + 0x78 + 8 > sbi->record_size) {\n\t\t\tCLST alen;\n\t\t\tCLST clst = bytes_to_cluster(sbi, nsize);\n\n\t\t\t/* Bytes per runs. */\n\t\t\tt16 = sbi->record_size - t16 - SIZEOF_NONRESIDENT;\n\n\t\t\tattr->non_res = 1;\n\t\t\tattr->nres.evcn = cpu_to_le64(clst - 1);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tattr->nres.run_off = attr->name_off;\n\t\t\tattr->nres.data_size = cpu_to_le64(nsize);\n\t\t\tattr->nres.valid_size = attr->nres.data_size;\n\t\t\tattr->nres.alloc_size =\n\t\t\t\tcpu_to_le64(ntfs_up_cluster(sbi, nsize));\n\n\t\t\terr = attr_allocate_clusters(sbi, &ni->file.run, 0, 0,\n\t\t\t\t\t\t     clst, NULL, ALLOCATE_DEF,\n\t\t\t\t\t\t     &alen, 0, NULL, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out5;\n\n\t\t\terr = run_pack(&ni->file.run, 0, clst,\n\t\t\t\t       Add2Ptr(attr, SIZEOF_NONRESIDENT), t16,\n\t\t\t\t       &vcn);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out5;\n\n\t\t\tif (vcn != clst) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out5;\n\t\t\t}\n\n\t\t\tasize = SIZEOF_NONRESIDENT + ALIGN(err, 8);\n\t\t} else {\n\t\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\t\tattr->res.data_size = cpu_to_le32(nsize);\n\t\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), rp, nsize);\n\t\t\tnsize = 0;\n\t\t}\n\t\t/* Size of symlink equals the length of input string. */\n\t\tinode->i_size = size;\n\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\terr = ntfs_insert_reparse(sbi, IO_REPARSE_TAG_SYMLINK,\n\t\t\t\t\t  &new_de->ref);\n\t\tif (err)\n\t\t\tgoto out5;\n\n\t\trp_inserted = true;\n\t}\n\n\tattr = Add2Ptr(attr, asize);\n\tattr->type = ATTR_END;\n\n\trec->used = cpu_to_le32(PtrOffset(rec, attr) + 8);\n\trec->next_attr_id = cpu_to_le16(aid);\n\n\t/* Step 2: Add new name in index. */\n\terr = indx_insert_entry(&dir_ni->dir, dir_ni, new_de, sbi, fnd, 0);\n\tif (err)\n\t\tgoto out6;\n\n\t/* Unlock parent directory before ntfs_init_acl. */\n\tif (!fnd)\n\t\tni_unlock(dir_ni);\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\tdir->i_mtime = dir->i_ctime = inode->i_atime;\n\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode->i_mapping->a_ops = &ntfs_aops;\n\t\tinode->i_size = size;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tinit_rwsem(&ni->file.run_lock);\n\t} else {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, dev);\n\t}\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\tif (!S_ISLNK(mode) && (sb->s_flags & SB_POSIXACL)) {\n\t\terr = ntfs_init_acl(mnt_userns, inode, dir);\n\t\tif (err)\n\t\t\tgoto out7;\n\t} else\n#endif\n\t{\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\t/* Write non resident data. */\n\tif (nsize) {\n\t\terr = ntfs_sb_write_run(sbi, &ni->file.run, 0, rp, nsize, 0);\n\t\tif (err)\n\t\t\tgoto out7;\n\t}\n\n\t/*\n\t * Call 'd_instantiate' after inode->i_op is set\n\t * but before finish_open.\n\t */\n\td_instantiate(dentry, inode);\n\n\tntfs_save_wsl_perm(inode);\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\t/* Normal exit. */\n\tgoto out2;\n\nout7:\n\n\t/* Undo 'indx_insert_entry'. */\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\tindx_delete_entry(&dir_ni->dir, dir_ni, new_de + 1,\n\t\t\t  le16_to_cpu(new_de->key_size), sbi);\n\t/* ni_unlock(dir_ni); will be called later. */\nout6:\n\tif (rp_inserted)\n\t\tntfs_remove_reparse(sbi, IO_REPARSE_TAG_SYMLINK, &new_de->ref);\n\nout5:\n\tif (S_ISDIR(mode) || run_is_empty(&ni->file.run))\n\t\tgoto out4;\n\n\trun_deallocate(sbi, &ni->file.run, false);\n\nout4:\n\tclear_rec_inuse(rec);\n\tclear_nlink(inode);\n\tni->mi.dirty = false;\n\tdiscard_new_inode(inode);\nout3:\n\tntfs_mark_rec_free(sbi, ino, false);\n\nout2:\n\t__putname(new_de);\n\tkfree(rp);\n\nout1:\n\tif (err) {\n\t\tif (!fnd)\n\t\t\tni_unlock(dir_ni);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstruct inode *ntfs_create_inode(struct user_namespace *mnt_userns,\n\t\t\t\tstruct inode *dir, struct dentry *dentry,\n\t\t\t\tconst struct cpu_str *uni, umode_t mode,\n\t\t\t\tdev_t dev, const char *symname, u32 size,\n\t\t\t\tstruct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tconst struct qstr *name = &dentry->d_name;\n\tCLST ino = 0;\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct ntfs_inode *ni = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_STD_INFO5 *std5;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct MFT_REC *rec;\n\tu32 asize, dsize, sd_size;\n\tenum FILE_ATTRIBUTE fa;\n\t__le32 security_id = SECURITY_ID_INVALID;\n\tCLST vcn;\n\tconst void *sd;\n\tu16 t16, nsize = 0, aid = 0;\n\tstruct INDEX_ROOT *root, *dir_root;\n\tstruct NTFS_DE *e, *new_de = NULL;\n\tstruct REPARSE_DATA_BUFFER *rp = NULL;\n\tbool rp_inserted = false;\n\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\n\tdir_root = indx_get_root(&dir_ni->dir, dir_ni, NULL, NULL);\n\tif (!dir_root) {\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\t/* Use parent's directory attributes. */\n\t\tfa = dir_ni->std_fa | FILE_ATTRIBUTE_DIRECTORY |\n\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t/*\n\t\t * By default child directory inherits parent attributes.\n\t\t * Root directory is hidden + system.\n\t\t * Make an exception for children in root.\n\t\t */\n\t\tif (dir->i_ino == MFT_REC_ROOT)\n\t\t\tfa &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);\n\t} else if (S_ISLNK(mode)) {\n\t\t/* It is good idea that link should be the same type (file/dir) as target */\n\t\tfa = FILE_ATTRIBUTE_REPARSE_POINT;\n\n\t\t/*\n\t\t * Linux: there are dir/file/symlink and so on.\n\t\t * NTFS: symlinks are \"dir + reparse\" or \"file + reparse\"\n\t\t * It is good idea to create:\n\t\t * dir + reparse if 'symname' points to directory\n\t\t * or\n\t\t * file + reparse if 'symname' points to file\n\t\t * Unfortunately kern_path hangs if symname contains 'dir'.\n\t\t */\n\n\t\t/*\n\t\t *\tstruct path path;\n\t\t *\n\t\t *\tif (!kern_path(symname, LOOKUP_FOLLOW, &path)){\n\t\t *\t\tstruct inode *target = d_inode(path.dentry);\n\t\t *\n\t\t *\t\tif (S_ISDIR(target->i_mode))\n\t\t *\t\t\tfa |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t *\t\t// if ( target->i_sb == sb ){\n\t\t *\t\t//\tuse relative path?\n\t\t *\t\t// }\n\t\t *\t\tpath_put(&path);\n\t\t *\t}\n\t\t */\n\t} else if (S_ISREG(mode)) {\n\t\tif (sbi->options->sparse) {\n\t\t\t/* Sparsed regular file, cause option 'sparse'. */\n\t\t\tfa = FILE_ATTRIBUTE_SPARSE_FILE |\n\t\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\t/* Compressed regular file, if parent is compressed. */\n\t\t\tfa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else {\n\t\t\t/* Regular file, default attributes. */\n\t\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t\t}\n\t} else {\n\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t}\n\n\t/* If option \"hide_dot_files\" then set hidden attribute for dot files. */\n\tif (sbi->options->hide_dot_files && name->name[0] == '.')\n\t\tfa |= FILE_ATTRIBUTE_HIDDEN;\n\n\tif (!(mode & 0222))\n\t\tfa |= FILE_ATTRIBUTE_READONLY;\n\n\t/* Allocate PATH_MAX bytes. */\n\tnew_de = __getname();\n\tif (!new_de) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Mark rw ntfs as dirty. it will be cleared at umount. */\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t/* Step 1: allocate and fill new mft record. */\n\terr = ntfs_look_free_mft(sbi, &ino, false, NULL, NULL);\n\tif (err)\n\t\tgoto out2;\n\n\tni = ntfs_new_inode(sbi, ino, fa & FILE_ATTRIBUTE_DIRECTORY);\n\tif (IS_ERR(ni)) {\n\t\terr = PTR_ERR(ni);\n\t\tni = NULL;\n\t\tgoto out3;\n\t}\n\tinode = &ni->vfs_inode;\n\tinode_init_owner(mnt_userns, inode, dir, mode);\n\tmode = inode->i_mode;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = ni->i_crtime =\n\t\tcurrent_time(inode);\n\n\trec = ni->mi.mrec;\n\trec->hard_links = cpu_to_le16(1);\n\tattr = Add2Ptr(rec, le16_to_cpu(rec->attr_off));\n\n\t/* Get default security id. */\n\tsd = s_default_security;\n\tsd_size = sizeof(s_default_security);\n\n\tif (is_ntfs3(sbi)) {\n\t\tsecurity_id = dir_ni->std_security_id;\n\t\tif (le32_to_cpu(security_id) < SECURITY_ID_FIRST) {\n\t\t\tsecurity_id = sbi->security.def_security_id;\n\n\t\t\tif (security_id == SECURITY_ID_INVALID &&\n\t\t\t    !ntfs_insert_security(sbi, sd, sd_size,\n\t\t\t\t\t\t  &security_id, NULL))\n\t\t\t\tsbi->security.def_security_id = security_id;\n\t\t}\n\t}\n\n\t/* Insert standard info. */\n\tstd5 = Add2Ptr(attr, SIZEOF_RESIDENT);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\tdsize = sizeof(struct ATTR_STD_INFO);\n\t} else {\n\t\tdsize = sizeof(struct ATTR_STD_INFO5);\n\t\tstd5->security_id = security_id;\n\t\tni->std_security_id = security_id;\n\t}\n\tasize = SIZEOF_RESIDENT + dsize;\n\n\tattr->type = ATTR_STD;\n\tattr->size = cpu_to_le32(asize);\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.data_size = cpu_to_le32(dsize);\n\n\tstd5->cr_time = std5->m_time = std5->c_time = std5->a_time =\n\t\tkernel2nt(&inode->i_atime);\n\n\tni->std_fa = fa;\n\tstd5->fa = fa;\n\n\tattr = Add2Ptr(attr, asize);\n\n\t/* Insert file name. */\n\terr = fill_name_de(sbi, new_de, name, uni);\n\tif (err)\n\t\tgoto out4;\n\n\tmi_get_ref(&ni->mi, &new_de->ref);\n\n\tfname = (struct ATTR_FILE_NAME *)(new_de + 1);\n\n\tif (sbi->options->windows_names &&\n\t    !valid_windows_name(sbi, (struct le_str *)&fname->name_len)) {\n\t\terr = -EINVAL;\n\t\tgoto out4;\n\t}\n\n\tmi_get_ref(&dir_ni->mi, &fname->home);\n\tfname->dup.cr_time = fname->dup.m_time = fname->dup.c_time =\n\t\tfname->dup.a_time = std5->cr_time;\n\tfname->dup.alloc_size = fname->dup.data_size = 0;\n\tfname->dup.fa = std5->fa;\n\tfname->dup.ea_size = fname->dup.reparse = 0;\n\n\tdsize = le16_to_cpu(new_de->key_size);\n\tasize = ALIGN(SIZEOF_RESIDENT + dsize, 8);\n\n\tattr->type = ATTR_NAME;\n\tattr->size = cpu_to_le32(asize);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.flags = RESIDENT_FLAG_INDEXED;\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_size = cpu_to_le32(dsize);\n\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), fname, dsize);\n\n\tattr = Add2Ptr(attr, asize);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\t/* Insert security attribute. */\n\t\tasize = SIZEOF_RESIDENT + ALIGN(sd_size, 8);\n\n\t\tattr->type = ATTR_SECURE;\n\t\tattr->size = cpu_to_le32(asize);\n\t\tattr->id = cpu_to_le16(aid++);\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_size = cpu_to_le32(sd_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), sd, sd_size);\n\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\tattr->id = cpu_to_le16(aid++);\n\tif (fa & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t/*\n\t\t * Regular directory or symlink to directory.\n\t\t * Create root attribute.\n\t\t */\n\t\tdsize = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE);\n\t\tasize = sizeof(I30_NAME) + SIZEOF_RESIDENT + dsize;\n\n\t\tattr->type = ATTR_ROOT;\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\tattr->name_len = ARRAY_SIZE(I30_NAME);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off =\n\t\t\tcpu_to_le16(sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tattr->res.data_size = cpu_to_le32(dsize);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), I30_NAME,\n\t\t       sizeof(I30_NAME));\n\n\t\troot = Add2Ptr(attr, sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tmemcpy(root, dir_root, offsetof(struct INDEX_ROOT, ihdr));\n\t\troot->ihdr.de_off =\n\t\t\tcpu_to_le32(sizeof(struct INDEX_HDR)); // 0x10\n\t\troot->ihdr.used = cpu_to_le32(sizeof(struct INDEX_HDR) +\n\t\t\t\t\t      sizeof(struct NTFS_DE));\n\t\troot->ihdr.total = root->ihdr.used;\n\n\t\te = Add2Ptr(root, sizeof(struct INDEX_ROOT));\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST;\n\t} else if (S_ISLNK(mode)) {\n\t\t/*\n\t\t * Symlink to file.\n\t\t * Create empty resident data attribute.\n\t\t */\n\t\tasize = SIZEOF_RESIDENT;\n\n\t\t/* Insert empty ATTR_DATA */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t} else if (S_ISREG(mode)) {\n\t\t/*\n\t\t * Regular file. Create empty non resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->non_res = 1;\n\t\tattr->nres.evcn = cpu_to_le64(-1ll);\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tasize = SIZEOF_NONRESIDENT + 8;\n\t\t}\n\t\tattr->nres.run_off = attr->name_off;\n\t} else {\n\t\t/*\n\t\t * Node. Create empty resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\telse if (fa & FILE_ATTRIBUTE_COMPRESSED)\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tasize = SIZEOF_RESIDENT;\n\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out4;\n\t} else if (S_ISLNK(mode)) {\n\t\trp = ntfs_create_reparse_buffer(sbi, symname, size, &nsize);\n\n\t\tif (IS_ERR(rp)) {\n\t\t\terr = PTR_ERR(rp);\n\t\t\trp = NULL;\n\t\t\tgoto out4;\n\t\t}\n\n\t\t/*\n\t\t * Insert ATTR_REPARSE.\n\t\t */\n\t\tattr = Add2Ptr(attr, asize);\n\t\tattr->type = ATTR_REPARSE;\n\t\tattr->id = cpu_to_le16(aid++);\n\n\t\t/* Resident or non resident? */\n\t\tasize = ALIGN(SIZEOF_RESIDENT + nsize, 8);\n\t\tt16 = PtrOffset(rec, attr);\n\n\t\t/*\n\t\t * Below function 'ntfs_save_wsl_perm' requires 0x78 bytes.\n\t\t * It is good idea to keep extened attributes resident.\n\t\t */\n\t\tif (asize + t16 + 0x78 + 8 > sbi->record_size) {\n\t\t\tCLST alen;\n\t\t\tCLST clst = bytes_to_cluster(sbi, nsize);\n\n\t\t\t/* Bytes per runs. */\n\t\t\tt16 = sbi->record_size - t16 - SIZEOF_NONRESIDENT;\n\n\t\t\tattr->non_res = 1;\n\t\t\tattr->nres.evcn = cpu_to_le64(clst - 1);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tattr->nres.run_off = attr->name_off;\n\t\t\tattr->nres.data_size = cpu_to_le64(nsize);\n\t\t\tattr->nres.valid_size = attr->nres.data_size;\n\t\t\tattr->nres.alloc_size =\n\t\t\t\tcpu_to_le64(ntfs_up_cluster(sbi, nsize));\n\n\t\t\terr = attr_allocate_clusters(sbi, &ni->file.run, 0, 0,\n\t\t\t\t\t\t     clst, NULL, ALLOCATE_DEF,\n\t\t\t\t\t\t     &alen, 0, NULL, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out5;\n\n\t\t\terr = run_pack(&ni->file.run, 0, clst,\n\t\t\t\t       Add2Ptr(attr, SIZEOF_NONRESIDENT), t16,\n\t\t\t\t       &vcn);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out5;\n\n\t\t\tif (vcn != clst) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out5;\n\t\t\t}\n\n\t\t\tasize = SIZEOF_NONRESIDENT + ALIGN(err, 8);\n\t\t} else {\n\t\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\t\tattr->res.data_size = cpu_to_le32(nsize);\n\t\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), rp, nsize);\n\t\t\tnsize = 0;\n\t\t}\n\t\t/* Size of symlink equals the length of input string. */\n\t\tinode->i_size = size;\n\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\terr = ntfs_insert_reparse(sbi, IO_REPARSE_TAG_SYMLINK,\n\t\t\t\t\t  &new_de->ref);\n\t\tif (err)\n\t\t\tgoto out5;\n\n\t\trp_inserted = true;\n\t}\n\n\tattr = Add2Ptr(attr, asize);\n\tattr->type = ATTR_END;\n\n\trec->used = cpu_to_le32(PtrOffset(rec, attr) + 8);\n\trec->next_attr_id = cpu_to_le16(aid);\n\n\t/* Step 2: Add new name in index. */\n\terr = indx_insert_entry(&dir_ni->dir, dir_ni, new_de, sbi, fnd, 0);\n\tif (err)\n\t\tgoto out6;\n\n\t/* Unlock parent directory before ntfs_init_acl. */\n\tif (!fnd)\n\t\tni_unlock(dir_ni);\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\tdir->i_mtime = dir->i_ctime = inode->i_atime;\n\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode->i_mapping->a_ops = &ntfs_aops;\n\t\tinode->i_size = size;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tinit_rwsem(&ni->file.run_lock);\n\t} else {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, dev);\n\t}\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\tif (!S_ISLNK(mode) && (sb->s_flags & SB_POSIXACL)) {\n\t\terr = ntfs_init_acl(mnt_userns, inode, dir);\n\t\tif (err)\n\t\t\tgoto out7;\n\t} else\n#endif\n\t{\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\t/* Write non resident data. */\n\tif (nsize) {\n\t\terr = ntfs_sb_write_run(sbi, &ni->file.run, 0, rp, nsize, 0);\n\t\tif (err)\n\t\t\tgoto out7;\n\t}\n\n\t/*\n\t * Call 'd_instantiate' after inode->i_op is set\n\t * but before finish_open.\n\t */\n\td_instantiate(dentry, inode);\n\n\tntfs_save_wsl_perm(inode);\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\t/* Normal exit. */\n\tgoto out2;\n\nout7:\n\n\t/* Undo 'indx_insert_entry'. */\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\tindx_delete_entry(&dir_ni->dir, dir_ni, new_de + 1,\n\t\t\t  le16_to_cpu(new_de->key_size), sbi);\n\t/* ni_unlock(dir_ni); will be called later. */\nout6:\n\tif (rp_inserted)\n\t\tntfs_remove_reparse(sbi, IO_REPARSE_TAG_SYMLINK, &new_de->ref);\n\nout5:\n\tif (!S_ISDIR(mode))\n\t\trun_deallocate(sbi, &ni->file.run, false);\n\nout4:\n\tclear_rec_inuse(rec);\n\tclear_nlink(inode);\n\tni->mi.dirty = false;\n\tdiscard_new_inode(inode);\nout3:\n\tntfs_mark_rec_free(sbi, ino, false);\n\nout2:\n\t__putname(new_de);\n\tkfree(rp);\n\nout1:\n\tif (err) {\n\t\tif (!fnd)\n\t\t\tni_unlock(dir_ni);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\n\tif (!sanity_check_inode(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto bad_inode;\n\t}\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (f2fs_encrypted_inode(inode))\n\t\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tf2fs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
                        "code_after_change": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (f2fs_encrypted_inode(inode))\n\t\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tf2fs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
                        "cve_id": "CVE-2018-13098"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstruct inode *ntfs_iget5(struct super_block *sb, const struct MFT_REF *ref,\n\t\t\t const struct cpu_str *name)\n{\n\tstruct inode *inode;\n\n\tinode = iget5_locked(sb, ino_get(ref), ntfs_test_inode, ntfs_set_inode,\n\t\t\t     (void *)ref);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (inode->i_state & I_NEW)\n\t\tinode = ntfs_read_mft(inode, name, ref);\n\telse if (ref->seq != ntfs_i(inode)->mi.mrec->seq) {\n\t\t/* Inode overlaps? */\n\t\t_ntfs_bad_inode(inode);\n\t}\n\n\treturn inode;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\n\tif (!sanity_check_inode(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto bad_inode;\n\t}\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (f2fs_encrypted_inode(inode))\n\t\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tf2fs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (f2fs_encrypted_inode(inode))\n\t\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tf2fs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2309,
            "cve_id": "CVE-2019-3459",
            "code_snippet": "static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,\n\t\t\t\tvoid *data, size_t size, u16 *result)\n{\n\tstruct l2cap_conf_req *req = data;\n\tvoid *ptr = req->data;\n\tvoid *endptr = data + size;\n\tint type, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\n\tBT_DBG(\"chan %p, rsp %p, len %d, req %p\", chan, rsp, len, data);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (val < L2CAP_DEFAULT_MIN_MTU) {\n\t\t\t\t*result = L2CAP_CONF_UNACCEPT;\n\t\t\t\tchan->imtu = L2CAP_DEFAULT_MIN_MTU;\n\t\t\t} else\n\t\t\t\tchan->imtu = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu,\n\t\t\t\t\t   endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2,\n\t\t\t\t\t   chan->flush_to, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&\n\t\t\t    rfc.mode != chan->mode)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tchan->fcs = 0;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->ack_win = min_t(u16, val, chan->ack_win);\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\n\t\t\t\t\t   chan->tx_win, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&efs, (void *)val, olen);\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs),\n\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (*result == L2CAP_CONF_PENDING)\n\t\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\t\tset_bit(CONF_RECV_NO_FCS,\n\t\t\t\t\t\t&chan->conf_state);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)\n\t\treturn -ECONNREFUSED;\n\n\tchan->mode = rfc.mode;\n\n\tif (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tif (!test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t\t      rfc.txwin_size);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->local_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->local_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tchan->local_acc_lat = le32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->local_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t}\n\t}\n\n\treq->dcid   = cpu_to_le16(chan->dcid);\n\treq->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}",
                        "code_after_change": "static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}",
                        "cve_id": "CVE-2019-3459"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,\n\t\t\t\tvoid *data, size_t size, u16 *result)\n{\n\tstruct l2cap_conf_req *req = data;\n\tvoid *ptr = req->data;\n\tvoid *endptr = data + size;\n\tint type, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\n\tBT_DBG(\"chan %p, rsp %p, len %d, req %p\", chan, rsp, len, data);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (val < L2CAP_DEFAULT_MIN_MTU) {\n\t\t\t\t*result = L2CAP_CONF_UNACCEPT;\n\t\t\t\tchan->imtu = L2CAP_DEFAULT_MIN_MTU;\n\t\t\t} else\n\t\t\t\tchan->imtu = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu,\n\t\t\t\t\t   endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2,\n\t\t\t\t\t   chan->flush_to, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&\n\t\t\t    rfc.mode != chan->mode)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tchan->fcs = 0;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->ack_win = min_t(u16, val, chan->ack_win);\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\n\t\t\t\t\t   chan->tx_win, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&efs, (void *)val, olen);\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs),\n\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (*result == L2CAP_CONF_PENDING)\n\t\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\t\tset_bit(CONF_RECV_NO_FCS,\n\t\t\t\t\t\t&chan->conf_state);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)\n\t\treturn -ECONNREFUSED;\n\n\tchan->mode = rfc.mode;\n\n\tif (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tif (!test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t\t      rfc.txwin_size);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->local_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->local_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tchan->local_acc_lat = le32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->local_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t}\n\t}\n\n\treq->dcid   = cpu_to_le16(chan->dcid);\n\treq->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 4182,
            "cve_id": "CVE-2023-39194",
            "code_snippet": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t\t     xfrma_policy, cb->extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg) ||\n\t\t    skb->len < nlh->nlmsg_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}",
                        "code_after_change": "static void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t\t    skb->len < nlh->nlmsg_len ||\n\t\t    nlmsg_len(nlh) < sizeof(struct nfgenmsg)) {\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}",
                        "cve_id": "CVE-2016-7917"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t\t     xfrma_policy, cb->extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg) ||\n\t\t    skb->len < nlh->nlmsg_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t\t    skb->len < nlh->nlmsg_len ||\n\t\t    nlmsg_len(nlh) < sizeof(struct nfgenmsg)) {\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int qrtr_endpoint_post(struct qrtr_endpoint *ep, const void *data, size_t len)\n{\n\tstruct qrtr_node *node = ep->node;\n\tconst struct qrtr_hdr_v1 *v1;\n\tconst struct qrtr_hdr_v2 *v2;\n\tstruct qrtr_sock *ipc;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tunsigned int size;\n\tunsigned int ver;\n\tsize_t hdrlen;\n\n\tif (len == 0 || len & 3)\n\t\treturn -EINVAL;\n\n\tskb = __netdev_alloc_skb(NULL, len, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcb = (struct qrtr_cb *)skb->cb;\n\n\t/* Version field in v1 is little endian, so this works for both cases */\n\tver = *(u8*)data;\n\n\tswitch (ver) {\n\tcase QRTR_PROTO_VER_1:\n\t\tif (len < sizeof(*v1))\n\t\t\tgoto err;\n\t\tv1 = data;\n\t\thdrlen = sizeof(*v1);\n\n\t\tcb->type = le32_to_cpu(v1->type);\n\t\tcb->src_node = le32_to_cpu(v1->src_node_id);\n\t\tcb->src_port = le32_to_cpu(v1->src_port_id);\n\t\tcb->confirm_rx = !!v1->confirm_rx;\n\t\tcb->dst_node = le32_to_cpu(v1->dst_node_id);\n\t\tcb->dst_port = le32_to_cpu(v1->dst_port_id);\n\n\t\tsize = le32_to_cpu(v1->size);\n\t\tbreak;\n\tcase QRTR_PROTO_VER_2:\n\t\tif (len < sizeof(*v2))\n\t\t\tgoto err;\n\t\tv2 = data;\n\t\thdrlen = sizeof(*v2) + v2->optlen;\n\n\t\tcb->type = v2->type;\n\t\tcb->confirm_rx = !!(v2->flags & QRTR_FLAGS_CONFIRM_RX);\n\t\tcb->src_node = le16_to_cpu(v2->src_node_id);\n\t\tcb->src_port = le16_to_cpu(v2->src_port_id);\n\t\tcb->dst_node = le16_to_cpu(v2->dst_node_id);\n\t\tcb->dst_port = le16_to_cpu(v2->dst_port_id);\n\n\t\tif (cb->src_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->src_port = QRTR_PORT_CTRL;\n\t\tif (cb->dst_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->dst_port = QRTR_PORT_CTRL;\n\n\t\tsize = le32_to_cpu(v2->size);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"qrtr: Invalid version %d\\n\", ver);\n\t\tgoto err;\n\t}\n\n\tif (len != ALIGN(size, 4) + hdrlen)\n\t\tgoto err;\n\n\tif (cb->dst_port != QRTR_PORT_CTRL && cb->type != QRTR_TYPE_DATA &&\n\t    cb->type != QRTR_TYPE_RESUME_TX)\n\t\tgoto err;\n\n\tskb_put_data(skb, data + hdrlen, size);\n\n\tqrtr_node_assign(node, cb->src_node);\n\n\tif (cb->type == QRTR_TYPE_NEW_SERVER) {\n\t\t/* Remote node endpoint can bridge other distant nodes */\n\t\tconst struct qrtr_ctrl_pkt *pkt = data + hdrlen;\n\n\t\tqrtr_node_assign(node, le32_to_cpu(pkt->server.node));\n\t}\n\n\tif (cb->type == QRTR_TYPE_RESUME_TX) {\n\t\tqrtr_tx_resume(node, skb);\n\t} else {\n\t\tipc = qrtr_port_lookup(cb->dst_port);\n\t\tif (!ipc)\n\t\t\tgoto err;\n\n\t\tif (sock_queue_rcv_skb(&ipc->sk, skb))\n\t\t\tgoto err;\n\n\t\tqrtr_port_put(ipc);\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n\n}",
                        "code_after_change": "int qrtr_endpoint_post(struct qrtr_endpoint *ep, const void *data, size_t len)\n{\n\tstruct qrtr_node *node = ep->node;\n\tconst struct qrtr_hdr_v1 *v1;\n\tconst struct qrtr_hdr_v2 *v2;\n\tstruct qrtr_sock *ipc;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tsize_t size;\n\tunsigned int ver;\n\tsize_t hdrlen;\n\n\tif (len == 0 || len & 3)\n\t\treturn -EINVAL;\n\n\tskb = __netdev_alloc_skb(NULL, len, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcb = (struct qrtr_cb *)skb->cb;\n\n\t/* Version field in v1 is little endian, so this works for both cases */\n\tver = *(u8*)data;\n\n\tswitch (ver) {\n\tcase QRTR_PROTO_VER_1:\n\t\tif (len < sizeof(*v1))\n\t\t\tgoto err;\n\t\tv1 = data;\n\t\thdrlen = sizeof(*v1);\n\n\t\tcb->type = le32_to_cpu(v1->type);\n\t\tcb->src_node = le32_to_cpu(v1->src_node_id);\n\t\tcb->src_port = le32_to_cpu(v1->src_port_id);\n\t\tcb->confirm_rx = !!v1->confirm_rx;\n\t\tcb->dst_node = le32_to_cpu(v1->dst_node_id);\n\t\tcb->dst_port = le32_to_cpu(v1->dst_port_id);\n\n\t\tsize = le32_to_cpu(v1->size);\n\t\tbreak;\n\tcase QRTR_PROTO_VER_2:\n\t\tif (len < sizeof(*v2))\n\t\t\tgoto err;\n\t\tv2 = data;\n\t\thdrlen = sizeof(*v2) + v2->optlen;\n\n\t\tcb->type = v2->type;\n\t\tcb->confirm_rx = !!(v2->flags & QRTR_FLAGS_CONFIRM_RX);\n\t\tcb->src_node = le16_to_cpu(v2->src_node_id);\n\t\tcb->src_port = le16_to_cpu(v2->src_port_id);\n\t\tcb->dst_node = le16_to_cpu(v2->dst_node_id);\n\t\tcb->dst_port = le16_to_cpu(v2->dst_port_id);\n\n\t\tif (cb->src_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->src_port = QRTR_PORT_CTRL;\n\t\tif (cb->dst_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->dst_port = QRTR_PORT_CTRL;\n\n\t\tsize = le32_to_cpu(v2->size);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"qrtr: Invalid version %d\\n\", ver);\n\t\tgoto err;\n\t}\n\n\tif (len != ALIGN(size, 4) + hdrlen)\n\t\tgoto err;\n\n\tif (cb->dst_port != QRTR_PORT_CTRL && cb->type != QRTR_TYPE_DATA &&\n\t    cb->type != QRTR_TYPE_RESUME_TX)\n\t\tgoto err;\n\n\tskb_put_data(skb, data + hdrlen, size);\n\n\tqrtr_node_assign(node, cb->src_node);\n\n\tif (cb->type == QRTR_TYPE_NEW_SERVER) {\n\t\t/* Remote node endpoint can bridge other distant nodes */\n\t\tconst struct qrtr_ctrl_pkt *pkt = data + hdrlen;\n\n\t\tqrtr_node_assign(node, le32_to_cpu(pkt->server.node));\n\t}\n\n\tif (cb->type == QRTR_TYPE_RESUME_TX) {\n\t\tqrtr_tx_resume(node, skb);\n\t} else {\n\t\tipc = qrtr_port_lookup(cb->dst_port);\n\t\tif (!ipc)\n\t\t\tgoto err;\n\n\t\tif (sock_queue_rcv_skb(&ipc->sk, skb))\n\t\t\tgoto err;\n\n\t\tqrtr_port_put(ipc);\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n\n}",
                        "cve_id": "CVE-2021-3743"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t\t     xfrma_policy, cb->extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}\n'''\nRelated vulnerability code snippet:\n'''\nint qrtr_endpoint_post(struct qrtr_endpoint *ep, const void *data, size_t len)\n{\n\tstruct qrtr_node *node = ep->node;\n\tconst struct qrtr_hdr_v1 *v1;\n\tconst struct qrtr_hdr_v2 *v2;\n\tstruct qrtr_sock *ipc;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tunsigned int size;\n\tunsigned int ver;\n\tsize_t hdrlen;\n\n\tif (len == 0 || len & 3)\n\t\treturn -EINVAL;\n\n\tskb = __netdev_alloc_skb(NULL, len, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcb = (struct qrtr_cb *)skb->cb;\n\n\t/* Version field in v1 is little endian, so this works for both cases */\n\tver = *(u8*)data;\n\n\tswitch (ver) {\n\tcase QRTR_PROTO_VER_1:\n\t\tif (len < sizeof(*v1))\n\t\t\tgoto err;\n\t\tv1 = data;\n\t\thdrlen = sizeof(*v1);\n\n\t\tcb->type = le32_to_cpu(v1->type);\n\t\tcb->src_node = le32_to_cpu(v1->src_node_id);\n\t\tcb->src_port = le32_to_cpu(v1->src_port_id);\n\t\tcb->confirm_rx = !!v1->confirm_rx;\n\t\tcb->dst_node = le32_to_cpu(v1->dst_node_id);\n\t\tcb->dst_port = le32_to_cpu(v1->dst_port_id);\n\n\t\tsize = le32_to_cpu(v1->size);\n\t\tbreak;\n\tcase QRTR_PROTO_VER_2:\n\t\tif (len < sizeof(*v2))\n\t\t\tgoto err;\n\t\tv2 = data;\n\t\thdrlen = sizeof(*v2) + v2->optlen;\n\n\t\tcb->type = v2->type;\n\t\tcb->confirm_rx = !!(v2->flags & QRTR_FLAGS_CONFIRM_RX);\n\t\tcb->src_node = le16_to_cpu(v2->src_node_id);\n\t\tcb->src_port = le16_to_cpu(v2->src_port_id);\n\t\tcb->dst_node = le16_to_cpu(v2->dst_node_id);\n\t\tcb->dst_port = le16_to_cpu(v2->dst_port_id);\n\n\t\tif (cb->src_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->src_port = QRTR_PORT_CTRL;\n\t\tif (cb->dst_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->dst_port = QRTR_PORT_CTRL;\n\n\t\tsize = le32_to_cpu(v2->size);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"qrtr: Invalid version %d\\n\", ver);\n\t\tgoto err;\n\t}\n\n\tif (len != ALIGN(size, 4) + hdrlen)\n\t\tgoto err;\n\n\tif (cb->dst_port != QRTR_PORT_CTRL && cb->type != QRTR_TYPE_DATA &&\n\t    cb->type != QRTR_TYPE_RESUME_TX)\n\t\tgoto err;\n\n\tskb_put_data(skb, data + hdrlen, size);\n\n\tqrtr_node_assign(node, cb->src_node);\n\n\tif (cb->type == QRTR_TYPE_NEW_SERVER) {\n\t\t/* Remote node endpoint can bridge other distant nodes */\n\t\tconst struct qrtr_ctrl_pkt *pkt = data + hdrlen;\n\n\t\tqrtr_node_assign(node, le32_to_cpu(pkt->server.node));\n\t}\n\n\tif (cb->type == QRTR_TYPE_RESUME_TX) {\n\t\tqrtr_tx_resume(node, skb);\n\t} else {\n\t\tipc = qrtr_port_lookup(cb->dst_port);\n\t\tif (!ipc)\n\t\t\tgoto err;\n\n\t\tif (sock_queue_rcv_skb(&ipc->sk, skb))\n\t\t\tgoto err;\n\n\t\tqrtr_port_put(ipc);\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint qrtr_endpoint_post(struct qrtr_endpoint *ep, const void *data, size_t len)\n{\n\tstruct qrtr_node *node = ep->node;\n\tconst struct qrtr_hdr_v1 *v1;\n\tconst struct qrtr_hdr_v2 *v2;\n\tstruct qrtr_sock *ipc;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tsize_t size;\n\tunsigned int ver;\n\tsize_t hdrlen;\n\n\tif (len == 0 || len & 3)\n\t\treturn -EINVAL;\n\n\tskb = __netdev_alloc_skb(NULL, len, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcb = (struct qrtr_cb *)skb->cb;\n\n\t/* Version field in v1 is little endian, so this works for both cases */\n\tver = *(u8*)data;\n\n\tswitch (ver) {\n\tcase QRTR_PROTO_VER_1:\n\t\tif (len < sizeof(*v1))\n\t\t\tgoto err;\n\t\tv1 = data;\n\t\thdrlen = sizeof(*v1);\n\n\t\tcb->type = le32_to_cpu(v1->type);\n\t\tcb->src_node = le32_to_cpu(v1->src_node_id);\n\t\tcb->src_port = le32_to_cpu(v1->src_port_id);\n\t\tcb->confirm_rx = !!v1->confirm_rx;\n\t\tcb->dst_node = le32_to_cpu(v1->dst_node_id);\n\t\tcb->dst_port = le32_to_cpu(v1->dst_port_id);\n\n\t\tsize = le32_to_cpu(v1->size);\n\t\tbreak;\n\tcase QRTR_PROTO_VER_2:\n\t\tif (len < sizeof(*v2))\n\t\t\tgoto err;\n\t\tv2 = data;\n\t\thdrlen = sizeof(*v2) + v2->optlen;\n\n\t\tcb->type = v2->type;\n\t\tcb->confirm_rx = !!(v2->flags & QRTR_FLAGS_CONFIRM_RX);\n\t\tcb->src_node = le16_to_cpu(v2->src_node_id);\n\t\tcb->src_port = le16_to_cpu(v2->src_port_id);\n\t\tcb->dst_node = le16_to_cpu(v2->dst_node_id);\n\t\tcb->dst_port = le16_to_cpu(v2->dst_port_id);\n\n\t\tif (cb->src_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->src_port = QRTR_PORT_CTRL;\n\t\tif (cb->dst_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->dst_port = QRTR_PORT_CTRL;\n\n\t\tsize = le32_to_cpu(v2->size);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"qrtr: Invalid version %d\\n\", ver);\n\t\tgoto err;\n\t}\n\n\tif (len != ALIGN(size, 4) + hdrlen)\n\t\tgoto err;\n\n\tif (cb->dst_port != QRTR_PORT_CTRL && cb->type != QRTR_TYPE_DATA &&\n\t    cb->type != QRTR_TYPE_RESUME_TX)\n\t\tgoto err;\n\n\tskb_put_data(skb, data + hdrlen, size);\n\n\tqrtr_node_assign(node, cb->src_node);\n\n\tif (cb->type == QRTR_TYPE_NEW_SERVER) {\n\t\t/* Remote node endpoint can bridge other distant nodes */\n\t\tconst struct qrtr_ctrl_pkt *pkt = data + hdrlen;\n\n\t\tqrtr_node_assign(node, le32_to_cpu(pkt->server.node));\n\t}\n\n\tif (cb->type == QRTR_TYPE_RESUME_TX) {\n\t\tqrtr_tx_resume(node, skb);\n\t} else {\n\t\tipc = qrtr_port_lookup(cb->dst_port);\n\t\tif (!ipc)\n\t\t\tgoto err;\n\n\t\tif (sock_queue_rcv_skb(&ipc->sk, skb))\n\t\t\tgoto err;\n\n\t\tqrtr_port_put(ipc);\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct xfrm_address_filter *filter = NULL;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\n\t\tstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\n\n\t\tfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (filter == NULL) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tfilter->family = xfilter->sadb_x_filter_family;\n\t\tfilter->splen = xfilter->sadb_x_filter_splen;\n\t\tfilter->dplen = xfilter->sadb_x_filter_dplen;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}",
                        "code_after_change": "static int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct xfrm_address_filter *filter = NULL;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\n\t\tstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\n\n\t\tif ((xfilter->sadb_x_filter_splen >=\n\t\t\t(sizeof(xfrm_address_t) << 3)) ||\n\t\t    (xfilter->sadb_x_filter_dplen >=\n\t\t\t(sizeof(xfrm_address_t) << 3))) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (filter == NULL) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tfilter->family = xfilter->sadb_x_filter_family;\n\t\tfilter->splen = xfilter->sadb_x_filter_splen;\n\t\tfilter->dplen = xfilter->sadb_x_filter_dplen;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}",
                        "cve_id": "CVE-2021-0605"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t\t     xfrma_policy, cb->extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct xfrm_address_filter *filter = NULL;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\n\t\tstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\n\n\t\tfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (filter == NULL) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tfilter->family = xfilter->sadb_x_filter_family;\n\t\tfilter->splen = xfilter->sadb_x_filter_splen;\n\t\tfilter->dplen = xfilter->sadb_x_filter_dplen;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct xfrm_address_filter *filter = NULL;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\n\t\tstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\n\n\t\tif ((xfilter->sadb_x_filter_splen >=\n\t\t\t(sizeof(xfrm_address_t) << 3)) ||\n\t\t    (xfilter->sadb_x_filter_dplen >=\n\t\t\t(sizeof(xfrm_address_t) << 3))) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (filter == NULL) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tfilter->family = xfilter->sadb_x_filter_family;\n\t\tfilter->splen = xfilter->sadb_x_filter_splen;\n\t\tfilter->dplen = xfilter->sadb_x_filter_dplen;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3793,
            "cve_id": "CVE-2022-48502",
            "code_snippet": "int indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,\n\t      struct indx_node **node)\n{\n\tint err;\n\tstruct INDEX_BUFFER *ib;\n\tstruct runs_tree *run = &indx->alloc_run;\n\tstruct rw_semaphore *lock = &indx->run_lock;\n\tu64 vbo = (u64)vbn << indx->vbn2vbo_bits;\n\tu32 bytes = 1u << indx->index_bits;\n\tstruct indx_node *in = *node;\n\tconst struct INDEX_NAMES *name;\n\n\tif (!in) {\n\t\tin = kzalloc(sizeof(struct indx_node), GFP_NOFS);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tnb_put(&in->nb);\n\t}\n\n\tib = in->index;\n\tif (!ib) {\n\t\tib = kmalloc(bytes, GFP_NOFS);\n\t\tif (!ib) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (!err)\n\t\tgoto ok;\n\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err != -ENOENT)\n\t\tgoto out;\n\n\tname = &s_index_names[indx->type];\n\tdown_write(lock);\n\terr = attr_load_runs_range(ni, ATTR_ALLOC, name->name, name->name_len,\n\t\t\t\t   run, vbo, vbo + bytes);\n\tup_write(lock);\n\tif (err)\n\t\tgoto out;\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err)\n\t\tgoto out;\n\nok:\n\tif (err == -E_NTFS_FIXUP) {\n\t\tntfs_write_bh(ni->mi.sbi, &ib->rhdr, &in->nb, 0);\n\t\terr = 0;\n\t}\n\n\t/* check for index header length */\n\tif (offsetof(struct INDEX_BUFFER, ihdr) + ib->ihdr.used > bytes) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tin->index = ib;\n\t*node = in;\n\nout:\n\tif (ib != in->index)\n\t\tkfree(ib);\n\n\tif (*node != in) {\n\t\tnb_put(&in->nb);\n\t\tkfree(in);\n\t}\n\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root))\n\t\t\tmemcpy(attr, a_root, asize);\n\t\telse {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}",
                        "code_after_change": "static int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root)) {\n\t\t\tmemcpy(attr, a_root, asize);\n\t\t} else {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,\n\t      struct indx_node **node)\n{\n\tint err;\n\tstruct INDEX_BUFFER *ib;\n\tstruct runs_tree *run = &indx->alloc_run;\n\tstruct rw_semaphore *lock = &indx->run_lock;\n\tu64 vbo = (u64)vbn << indx->vbn2vbo_bits;\n\tu32 bytes = 1u << indx->index_bits;\n\tstruct indx_node *in = *node;\n\tconst struct INDEX_NAMES *name;\n\n\tif (!in) {\n\t\tin = kzalloc(sizeof(struct indx_node), GFP_NOFS);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tnb_put(&in->nb);\n\t}\n\n\tib = in->index;\n\tif (!ib) {\n\t\tib = kmalloc(bytes, GFP_NOFS);\n\t\tif (!ib) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (!err)\n\t\tgoto ok;\n\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err != -ENOENT)\n\t\tgoto out;\n\n\tname = &s_index_names[indx->type];\n\tdown_write(lock);\n\terr = attr_load_runs_range(ni, ATTR_ALLOC, name->name, name->name_len,\n\t\t\t\t   run, vbo, vbo + bytes);\n\tup_write(lock);\n\tif (err)\n\t\tgoto out;\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err)\n\t\tgoto out;\n\nok:\n\tif (err == -E_NTFS_FIXUP) {\n\t\tntfs_write_bh(ni->mi.sbi, &ib->rhdr, &in->nb, 0);\n\t\terr = 0;\n\t}\n\n\t/* check for index header length */\n\tif (offsetof(struct INDEX_BUFFER, ihdr) + ib->ihdr.used > bytes) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tin->index = ib;\n\t*node = in;\n\nout:\n\tif (ib != in->index)\n\t\tkfree(ib);\n\n\tif (*node != in) {\n\t\tnb_put(&in->nb);\n\t\tkfree(in);\n\t}\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root))\n\t\t\tmemcpy(attr, a_root, asize);\n\t\telse {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root)) {\n\t\t\tmemcpy(attr, a_root, asize);\n\t\t} else {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,\n\t      struct indx_node **node)\n{\n\tint err;\n\tstruct INDEX_BUFFER *ib;\n\tstruct runs_tree *run = &indx->alloc_run;\n\tstruct rw_semaphore *lock = &indx->run_lock;\n\tu64 vbo = (u64)vbn << indx->vbn2vbo_bits;\n\tu32 bytes = 1u << indx->index_bits;\n\tstruct indx_node *in = *node;\n\tconst struct INDEX_NAMES *name;\n\n\tif (!in) {\n\t\tin = kzalloc(sizeof(struct indx_node), GFP_NOFS);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tnb_put(&in->nb);\n\t}\n\n\tib = in->index;\n\tif (!ib) {\n\t\tib = kmalloc(bytes, GFP_NOFS);\n\t\tif (!ib) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (!err)\n\t\tgoto ok;\n\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err != -ENOENT)\n\t\tgoto out;\n\n\tname = &s_index_names[indx->type];\n\tdown_write(lock);\n\terr = attr_load_runs_range(ni, ATTR_ALLOC, name->name, name->name_len,\n\t\t\t\t   run, vbo, vbo + bytes);\n\tup_write(lock);\n\tif (err)\n\t\tgoto out;\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err)\n\t\tgoto out;\n\nok:\n\tif (err == -E_NTFS_FIXUP) {\n\t\tntfs_write_bh(ni->mi.sbi, &ib->rhdr, &in->nb, 0);\n\t\terr = 0;\n\t}\n\n\t/* check for index header length */\n\tif (offsetof(struct INDEX_BUFFER, ihdr) + ib->ihdr.used > bytes) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tin->index = ib;\n\t*node = in;\n\nout:\n\tif (ib != in->index)\n\t\tkfree(ib);\n\n\tif (*node != in) {\n\t\tnb_put(&in->nb);\n\t\tkfree(in);\n\t}\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off)) {\n\t\tstruct EA_FULL *ea;\n\t\tsize_t ea_sz;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tea_sz = unpacked_ea_size(ea);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}",
                        "code_after_change": "static noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,\n\t      struct indx_node **node)\n{\n\tint err;\n\tstruct INDEX_BUFFER *ib;\n\tstruct runs_tree *run = &indx->alloc_run;\n\tstruct rw_semaphore *lock = &indx->run_lock;\n\tu64 vbo = (u64)vbn << indx->vbn2vbo_bits;\n\tu32 bytes = 1u << indx->index_bits;\n\tstruct indx_node *in = *node;\n\tconst struct INDEX_NAMES *name;\n\n\tif (!in) {\n\t\tin = kzalloc(sizeof(struct indx_node), GFP_NOFS);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tnb_put(&in->nb);\n\t}\n\n\tib = in->index;\n\tif (!ib) {\n\t\tib = kmalloc(bytes, GFP_NOFS);\n\t\tif (!ib) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (!err)\n\t\tgoto ok;\n\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err != -ENOENT)\n\t\tgoto out;\n\n\tname = &s_index_names[indx->type];\n\tdown_write(lock);\n\terr = attr_load_runs_range(ni, ATTR_ALLOC, name->name, name->name_len,\n\t\t\t\t   run, vbo, vbo + bytes);\n\tup_write(lock);\n\tif (err)\n\t\tgoto out;\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err)\n\t\tgoto out;\n\nok:\n\tif (err == -E_NTFS_FIXUP) {\n\t\tntfs_write_bh(ni->mi.sbi, &ib->rhdr, &in->nb, 0);\n\t\terr = 0;\n\t}\n\n\t/* check for index header length */\n\tif (offsetof(struct INDEX_BUFFER, ihdr) + ib->ihdr.used > bytes) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tin->index = ib;\n\t*node = in;\n\nout:\n\tif (ib != in->index)\n\t\tkfree(ib);\n\n\tif (*node != in) {\n\t\tnb_put(&in->nb);\n\t\tkfree(in);\n\t}\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off)) {\n\t\tstruct EA_FULL *ea;\n\t\tsize_t ea_sz;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tea_sz = unpacked_ea_size(ea);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1552,
            "cve_id": "CVE-2017-8240",
            "code_snippet": "static void msm_pinctrl_setup_pm_reset(struct msm_pinctrl *pctrl)\n{\n\tint i = 0;\n\tconst struct msm_function *func = pctrl->soc->functions;\n\n\tfor (; i <= pctrl->soc->nfunctions; i++)\n\t\tif (!strcmp(func[i].name, \"ps_hold\")) {\n\t\t\tpctrl->restart_nb.notifier_call = msm_ps_hold_restart;\n\t\t\tpctrl->restart_nb.priority = 128;\n\t\t\tif (register_restart_handler(&pctrl->restart_nb))\n\t\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\t\"failed to setup restart handler.\\n\");\n\t\t\tbreak;\n\t\t}\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2021-3444"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void msm_pinctrl_setup_pm_reset(struct msm_pinctrl *pctrl)\n{\n\tint i = 0;\n\tconst struct msm_function *func = pctrl->soc->functions;\n\n\tfor (; i <= pctrl->soc->nfunctions; i++)\n\t\tif (!strcmp(func[i].name, \"ps_hold\")) {\n\t\t\tpctrl->restart_nb.notifier_call = msm_ps_hold_restart;\n\t\t\tpctrl->restart_nb.priority = 128;\n\t\t\tif (register_restart_handler(&pctrl->restart_nb))\n\t\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\t\"failed to setup restart handler.\\n\");\n\t\t\tbreak;\n\t\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tvoid *control_header;\n\tint i, protocol;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\tcontrol_header = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t NULL, UAC_HEADER);\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tif (!control_header) {\n\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tvoid *control_header;\n\tint i, protocol;\n\tint rest_bytes;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\tcontrol_header = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t NULL, UAC_HEADER);\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tif (!control_header) {\n\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trest_bytes = (void *)(host_iface->extra + host_iface->extralen) -\n\t\tcontrol_header;\n\n\t/* just to be sure -- this shouldn't hit at all */\n\tif (rest_bytes <= 0) {\n\t\tdev_err(&dev->dev, \"invalid control header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n\n\t\tif (rest_bytes < sizeof(*h1)) {\n\t\t\tdev_err(&dev->dev, \"too short v1 buffer descriptor\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < h1->bLength) {\n\t\t\tdev_err(&dev->dev, \"invalid buffer length (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-16529"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void msm_pinctrl_setup_pm_reset(struct msm_pinctrl *pctrl)\n{\n\tint i = 0;\n\tconst struct msm_function *func = pctrl->soc->functions;\n\n\tfor (; i <= pctrl->soc->nfunctions; i++)\n\t\tif (!strcmp(func[i].name, \"ps_hold\")) {\n\t\t\tpctrl->restart_nb.notifier_call = msm_ps_hold_restart;\n\t\t\tpctrl->restart_nb.priority = 128;\n\t\t\tif (register_restart_handler(&pctrl->restart_nb))\n\t\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\t\"failed to setup restart handler.\\n\");\n\t\t\tbreak;\n\t\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tvoid *control_header;\n\tint i, protocol;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\tcontrol_header = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t NULL, UAC_HEADER);\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tif (!control_header) {\n\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tvoid *control_header;\n\tint i, protocol;\n\tint rest_bytes;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\tcontrol_header = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t NULL, UAC_HEADER);\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tif (!control_header) {\n\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trest_bytes = (void *)(host_iface->extra + host_iface->extralen) -\n\t\tcontrol_header;\n\n\t/* just to be sure -- this shouldn't hit at all */\n\tif (rest_bytes <= 0) {\n\t\tdev_err(&dev->dev, \"invalid control header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n\n\t\tif (rest_bytes < sizeof(*h1)) {\n\t\t\tdev_err(&dev->dev, \"too short v1 buffer descriptor\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < h1->bLength) {\n\t\t\tdev_err(&dev->dev, \"invalid buffer length (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2307,
            "cve_id": "CVE-2019-3459",
            "code_snippet": "static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *endptr = data + data_size;\n\tvoid *req = chan->conf_req;\n\tint len = chan->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\tu8 remote_efs = 0;\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\tset_bit(CONF_RECV_NO_FCS, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tremote_efs = 1;\n\t\t\tmemcpy(&efs, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\t\tset_bit(CONF_EWS_RECV, &chan->conf_state);\n\t\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t\t\tchan->remote_tx_win = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->num_conf_rsp || chan->num_conf_req > 1)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {\n\t\t\tchan->mode = l2cap_select_mode(rfc.mode,\n\t\t\t\t\t\t       chan->conn->feat_mask);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (remote_efs) {\n\t\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\t\t\telse\n\t\t\t\treturn -ECONNREFUSED;\n\t\t}\n\n\t\tif (chan->mode != rfc.mode)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = chan->mode;\n\n\t\tif (chan->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tchan->omtu = mtu;\n\t\t\tset_bit(CONF_MTU_DONE, &chan->conf_state);\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);\n\n\t\tif (remote_efs) {\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype) {\n\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\t\tif (chan->num_conf_req >= 1)\n\t\t\t\t\treturn -ECONNREFUSED;\n\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t} else {\n\t\t\t\t/* Send PENDING Conf Rsp */\n\t\t\t\tresult = L2CAP_CONF_PENDING;\n\t\t\t\tset_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\t\t\t}\n\t\t}\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tif (!test_bit(CONF_EWS_RECV, &chan->conf_state))\n\t\t\t\tchan->remote_tx_win = rfc.txwin_size;\n\t\t\telse\n\t\t\t\trfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;\n\n\t\t\tchan->remote_max_tx = rfc.max_transmit;\n\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\t   sizeof(rfc), (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->remote_id = efs.id;\n\t\t\t\tchan->remote_stype = efs.stype;\n\t\t\t\tchan->remote_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->remote_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t\tchan->remote_acc_lat =\n\t\t\t\t\tle32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->remote_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = chan->mode;\n\t\t}\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\t}\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}",
                        "code_after_change": "static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}",
                        "cve_id": "CVE-2019-3459"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *endptr = data + data_size;\n\tvoid *req = chan->conf_req;\n\tint len = chan->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\tu8 remote_efs = 0;\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\tset_bit(CONF_RECV_NO_FCS, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tremote_efs = 1;\n\t\t\tmemcpy(&efs, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\t\tset_bit(CONF_EWS_RECV, &chan->conf_state);\n\t\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t\t\tchan->remote_tx_win = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->num_conf_rsp || chan->num_conf_req > 1)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {\n\t\t\tchan->mode = l2cap_select_mode(rfc.mode,\n\t\t\t\t\t\t       chan->conn->feat_mask);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (remote_efs) {\n\t\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\t\t\telse\n\t\t\t\treturn -ECONNREFUSED;\n\t\t}\n\n\t\tif (chan->mode != rfc.mode)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = chan->mode;\n\n\t\tif (chan->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tchan->omtu = mtu;\n\t\t\tset_bit(CONF_MTU_DONE, &chan->conf_state);\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);\n\n\t\tif (remote_efs) {\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype) {\n\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\t\tif (chan->num_conf_req >= 1)\n\t\t\t\t\treturn -ECONNREFUSED;\n\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t} else {\n\t\t\t\t/* Send PENDING Conf Rsp */\n\t\t\t\tresult = L2CAP_CONF_PENDING;\n\t\t\t\tset_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\t\t\t}\n\t\t}\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tif (!test_bit(CONF_EWS_RECV, &chan->conf_state))\n\t\t\t\tchan->remote_tx_win = rfc.txwin_size;\n\t\t\telse\n\t\t\t\trfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;\n\n\t\t\tchan->remote_max_tx = rfc.max_transmit;\n\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\t   sizeof(rfc), (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->remote_id = efs.id;\n\t\t\t\tchan->remote_stype = efs.stype;\n\t\t\t\tchan->remote_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->remote_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t\tchan->remote_acc_lat =\n\t\t\t\t\tle32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->remote_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = chan->mode;\n\t\t}\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\t}\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1431,
            "cve_id": "CVE-2017-18344",
            "code_snippet": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * The timespec64 based conversion is suboptimal, but it's not\n\t * worth to implement yet another callback.\n\t */\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
                        "code_after_change": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-18344"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * The timespec64 based conversion is suboptimal, but it's not\n\t * worth to implement yet another callback.\n\t */\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nint common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1368,
            "cve_id": "CVE-2017-17741",
            "code_snippet": "static int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, *(u64 *)val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);\n\treturn X86EMUL_IO_NEEDED;\n}",
                        "code_after_change": "static int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);\n\treturn X86EMUL_IO_NEEDED;\n}",
                        "cve_id": "CVE-2017-17741"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, *(u64 *)val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);\n\treturn X86EMUL_IO_NEEDED;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);\n\treturn X86EMUL_IO_NEEDED;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2655,
            "cve_id": "CVE-2020-28097",
            "code_snippet": "static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tvgacon_scrollback_update(c, t, lines);\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t/* Redrawing not needed */\n}",
                        "code_after_change": "static int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\treturn 0;\t\t/* Redrawing not needed */\n}",
                        "cve_id": "CVE-2020-28097"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tvgacon_scrollback_update(c, t, lines);\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t/* Redrawing not needed */\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\treturn 0;\t\t/* Redrawing not needed */\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1984,
            "cve_id": "CVE-2019-15090",
            "code_snippet": "void\nqedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), nfunc, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void\nqedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}",
                        "code_after_change": "void\nqedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}",
                        "cve_id": "CVE-2019-15090"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid\nqedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), nfunc, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}\n'''\nRelated vulnerability code snippet:\n'''\nvoid\nqedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nvoid\nqedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2290,
            "cve_id": "CVE-2019-2101",
            "code_snippet": "static int uvc_parse_standard_control(struct uvc_device *dev,\n\tconst unsigned char *buffer, int buflen)\n{\n\tstruct usb_device *udev = dev->udev;\n\tstruct uvc_entity *unit, *term;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *alts = dev->intf->cur_altsetting;\n\tunsigned int i, n, p, len;\n\tu16 type;\n\n\tswitch (buffer[2]) {\n\tcase UVC_VC_HEADER:\n\t\tn = buflen >= 12 ? buffer[11] : 0;\n\n\t\tif (buflen < 12 + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d HEADER error\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev->uvc_version = get_unaligned_le16(&buffer[3]);\n\t\tdev->clock_frequency = get_unaligned_le32(&buffer[7]);\n\n\t\t/* Parse all USB Video Streaming interfaces. */\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tintf = usb_ifnum_to_if(udev, buffer[12+i]);\n\t\t\tif (intf == NULL) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d \"\n\t\t\t\t\t\"interface %d doesn't exists\\n\",\n\t\t\t\t\tudev->devnum, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuvc_parse_streaming(dev, intf);\n\t\t}\n\t\tbreak;\n\n\tcase UVC_VC_INPUT_TERMINAL:\n\t\tif (buflen < 8) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Make sure the terminal type MSB is not null, otherwise it\n\t\t * could be confused with a unit.\n\t\t */\n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0xff00) == 0) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL %d has invalid \"\n\t\t\t\t\"type 0x%04x, skipping\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber,\n\t\t\t\tbuffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tn = 0;\n\t\tp = 0;\n\t\tlen = 8;\n\n\t\tif (type == UVC_ITT_CAMERA) {\n\t\t\tn = buflen >= 15 ? buffer[14] : 0;\n\t\t\tlen = 15;\n\n\t\t} else if (type == UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tn = buflen >= 9 ? buffer[8] : 0;\n\t\t\tp = buflen >= 10 + n ? buffer[9+n] : 0;\n\t\t\tlen = 10;\n\t\t}\n\n\t\tif (buflen < len + n + p) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_INPUT, buffer[3],\n\t\t\t\t\t1, n + p);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA) {\n\t\t\tterm->camera.bControlSize = n;\n\t\t\tterm->camera.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->camera.wObjectiveFocalLengthMin =\n\t\t\t\tget_unaligned_le16(&buffer[8]);\n\t\t\tterm->camera.wObjectiveFocalLengthMax =\n\t\t\t\tget_unaligned_le16(&buffer[10]);\n\t\t\tterm->camera.wOcularFocalLength =\n\t\t\t\tget_unaligned_le16(&buffer[12]);\n\t\t\tmemcpy(term->camera.bmControls, &buffer[15], n);\n\t\t} else if (UVC_ENTITY_TYPE(term) ==\n\t\t\t   UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tterm->media.bControlSize = n;\n\t\t\tterm->media.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->media.bTransportModeSize = p;\n\t\t\tterm->media.bmTransportModes = (u8 *)term\n\t\t\t\t\t\t     + sizeof(*term) + n;\n\t\t\tmemcpy(term->media.bmControls, &buffer[9], n);\n\t\t\tmemcpy(term->media.bmTransportModes, &buffer[10+n], p);\n\t\t}\n\n\t\tif (buffer[7] != 0)\n\t\t\tusb_string(udev, buffer[7], term->name,\n\t\t\t\t   sizeof(term->name));\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA)\n\t\t\tsprintf(term->name, \"Camera %u\", buffer[3]);\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_MEDIA_TRANSPORT_INPUT)\n\t\t\tsprintf(term->name, \"Media %u\", buffer[3]);\n\t\telse\n\t\t\tsprintf(term->name, \"Input %u\", buffer[3]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_OUTPUT_TERMINAL:\n\t\tif (buflen < 9) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d OUTPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Make sure the terminal type MSB is not null, otherwise it\n\t\t * could be confused with a unit.\n\t\t */\n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0xff00) == 0) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d OUTPUT_TERMINAL %d has invalid \"\n\t\t\t\t\"type 0x%04x, skipping\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber, buffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_OUTPUT, buffer[3],\n\t\t\t\t\t1, 0);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(term->baSourceID, &buffer[7], 1);\n\n\t\tif (buffer[8] != 0)\n\t\t\tusb_string(udev, buffer[8], term->name,\n\t\t\t\t   sizeof(term->name));\n\t\telse\n\t\t\tsprintf(term->name, \"Output %u\", buffer[3]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_SELECTOR_UNIT:\n\t\tp = buflen >= 5 ? buffer[4] : 0;\n\n\t\tif (buflen < 5 || buflen < 6 + p) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d SELECTOR_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, 0);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[5], p);\n\n\t\tif (buffer[5+p] != 0)\n\t\t\tusb_string(udev, buffer[5+p], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Selector %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_PROCESSING_UNIT:\n\t\tn = buflen >= 8 ? buffer[7] : 0;\n\t\tp = dev->uvc_version >= 0x0110 ? 10 : 9;\n\n\t\tif (buflen < p + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d PROCESSING_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], 2, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[4], 1);\n\t\tunit->processing.wMaxMultiplier =\n\t\t\tget_unaligned_le16(&buffer[5]);\n\t\tunit->processing.bControlSize = buffer[7];\n\t\tunit->processing.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->processing.bmControls, &buffer[8], n);\n\t\tif (dev->uvc_version >= 0x0110)\n\t\t\tunit->processing.bmVideoStandards = buffer[9+n];\n\n\t\tif (buffer[8+n] != 0)\n\t\t\tusb_string(udev, buffer[8+n], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Processing %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_EXTENSION_UNIT:\n\t\tp = buflen >= 22 ? buffer[21] : 0;\n\t\tn = buflen >= 24 + p ? buffer[22+p] : 0;\n\n\t\tif (buflen < 24 + p + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d EXTENSION_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->extension.guidExtensionCode, &buffer[4], 16);\n\t\tunit->extension.bNumControls = buffer[20];\n\t\tmemcpy(unit->baSourceID, &buffer[22], p);\n\t\tunit->extension.bControlSize = buffer[22+p];\n\t\tunit->extension.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->extension.bmControls, &buffer[23+p], n);\n\n\t\tif (buffer[23+p+n] != 0)\n\t\t\tusb_string(udev, buffer[23+p+n], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Extension %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tdefault:\n\t\tuvc_trace(UVC_TRACE_DESCR, \"Found an unknown CS_INTERFACE \"\n\t\t\t\"descriptor (%u)\\n\", buffer[2]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\t\tlength = cap->bLength;\n\n\t\tif (total_len < length)\n\t\t\tbreak;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}",
                        "code_after_change": "int uclogic_params_init(struct uclogic_params *params,\n\t\t\tstruct hid_device *hdev)\n{\n\tint rc;\n\tstruct usb_device *udev = hid_to_usb_dev(hdev);\n\t__u8  bNumInterfaces = udev->config->desc.bNumInterfaces;\n\tstruct usb_interface *iface = to_usb_interface(hdev->dev.parent);\n\t__u8 bInterfaceNumber = iface->cur_altsetting->desc.bInterfaceNumber;\n\tbool found;\n\t/* The resulting parameters (noop) */\n\tstruct uclogic_params p = {0, };\n\n\t/* Check arguments */\n\tif (params == NULL || hdev == NULL || !hid_is_usb(hdev)) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Set replacement report descriptor if the original matches the\n\t * specified size. Otherwise keep interface unchanged.\n\t */\n#define WITH_OPT_DESC(_orig_desc_token, _new_desc_token) \\\n\tuclogic_params_init_with_opt_desc(                  \\\n\t\t&p, hdev,                                   \\\n\t\tUCLOGIC_RDESC_##_orig_desc_token##_SIZE,    \\\n\t\tuclogic_rdesc_##_new_desc_token##_arr,      \\\n\t\tuclogic_rdesc_##_new_desc_token##_size)\n\n#define VID_PID(_vid, _pid) \\\n\t(((__u32)(_vid) << 16) | ((__u32)(_pid) & U16_MAX))\n\n\t/*\n\t * Handle specific interfaces for specific tablets.\n\t *\n\t * Observe the following logic:\n\t *\n\t * If the interface is recognized as producing certain useful input:\n\t *\tMark interface as valid.\n\t *\tOutput interface parameters.\n\t * Else, if the interface is recognized as *not* producing any useful\n\t * input:\n\t *\tMark interface as invalid.\n\t * Else:\n\t *\tMark interface as valid.\n\t *\tOutput noop parameters.\n\t *\n\t * Rule of thumb: it is better to disable a broken interface than let\n\t *\t\t  it spew garbage input.\n\t */\n\n\tswitch (VID_PID(hdev->vendor, hdev->product)) {\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_PF1209):\n\t\trc = WITH_OPT_DESC(PF1209_ORIG, pf1209_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp4030u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U):\n\t\tif (hdev->dev_rsize == UCLOGIC_RDESC_WP5540U_V2_ORIG_SIZE) {\n\t\t\tif (bInterfaceNumber == 0) {\n\t\t\t\t/* Try to probe v1 pen parameters */\n\t\t\t\trc = uclogic_params_pen_init_v1(&p.pen,\n\t\t\t\t\t\t\t\t&found, hdev);\n\t\t\t\tif (rc != 0) {\n\t\t\t\t\thid_err(hdev,\n\t\t\t\t\t\t\"pen probing failed: %d\\n\",\n\t\t\t\t\t\trc);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\thid_warn(hdev,\n\t\t\t\t\t\t \"pen parameters not found\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp5540u_fixed);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp8060u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP1062):\n\t\trc = WITH_OPT_DESC(WP1062_ORIG, wp1062_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850):\n\t\tswitch (bInterfaceNumber) {\n\t\tcase 0:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG0, twhl850_fixed0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG1, twhl850_fixed1);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG2, twhl850_fixed2);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60):\n\t\t/*\n\t\t * If it is not a three-interface version, which is known to\n\t\t * respond to initialization.\n\t\t */\n\t\tif (bNumInterfaces != 3) {\n\t\t\tswitch (bInterfaceNumber) {\n\t\t\tcase 0:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG0,\n\t\t\t\t\t\t\ttwha60_fixed0);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG1,\n\t\t\t\t\t\t\ttwha60_fixed1);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_HS64):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_YIYNOVA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_81):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_DRAWIMAGE_G3):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_45):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_47):\n\t\trc = uclogic_params_huion_init(&p, hdev);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GP0610):\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GT5040):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G540):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G640):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_RAINBOW_CV720):\n\t\t/* If this is the pen interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01):\n\t\t/* If this is the pen and frame interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* Initialize frame parameters */\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_arr,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_TRUST,\n\t\t     USB_DEVICE_ID_TRUST_PANORA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_G5):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_arr,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_size,\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_ID);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tp.frame.re_lsb =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_RE_LSB;\n\t\t\tp.frame.dev_id_byte =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_DEV_ID_BYTE;\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_EX07S):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_arr,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\t}\n\n#undef VID_PID\n#undef WITH_OPT_DESC\n\n\t/* Output parameters */\n\tmemcpy(params, &p, sizeof(*params));\n\tmemset(&p, 0, sizeof(p));\n\trc = 0;\ncleanup:\n\tuclogic_params_cleanup(&p);\n\treturn rc;\n}",
                        "cve_id": "CVE-2017-16535"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int uvc_parse_standard_control(struct uvc_device *dev,\n\tconst unsigned char *buffer, int buflen)\n{\n\tstruct usb_device *udev = dev->udev;\n\tstruct uvc_entity *unit, *term;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *alts = dev->intf->cur_altsetting;\n\tunsigned int i, n, p, len;\n\tu16 type;\n\n\tswitch (buffer[2]) {\n\tcase UVC_VC_HEADER:\n\t\tn = buflen >= 12 ? buffer[11] : 0;\n\n\t\tif (buflen < 12 + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d HEADER error\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev->uvc_version = get_unaligned_le16(&buffer[3]);\n\t\tdev->clock_frequency = get_unaligned_le32(&buffer[7]);\n\n\t\t/* Parse all USB Video Streaming interfaces. */\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tintf = usb_ifnum_to_if(udev, buffer[12+i]);\n\t\t\tif (intf == NULL) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d \"\n\t\t\t\t\t\"interface %d doesn't exists\\n\",\n\t\t\t\t\tudev->devnum, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuvc_parse_streaming(dev, intf);\n\t\t}\n\t\tbreak;\n\n\tcase UVC_VC_INPUT_TERMINAL:\n\t\tif (buflen < 8) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Make sure the terminal type MSB is not null, otherwise it\n\t\t * could be confused with a unit.\n\t\t */\n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0xff00) == 0) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL %d has invalid \"\n\t\t\t\t\"type 0x%04x, skipping\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber,\n\t\t\t\tbuffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tn = 0;\n\t\tp = 0;\n\t\tlen = 8;\n\n\t\tif (type == UVC_ITT_CAMERA) {\n\t\t\tn = buflen >= 15 ? buffer[14] : 0;\n\t\t\tlen = 15;\n\n\t\t} else if (type == UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tn = buflen >= 9 ? buffer[8] : 0;\n\t\t\tp = buflen >= 10 + n ? buffer[9+n] : 0;\n\t\t\tlen = 10;\n\t\t}\n\n\t\tif (buflen < len + n + p) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_INPUT, buffer[3],\n\t\t\t\t\t1, n + p);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA) {\n\t\t\tterm->camera.bControlSize = n;\n\t\t\tterm->camera.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->camera.wObjectiveFocalLengthMin =\n\t\t\t\tget_unaligned_le16(&buffer[8]);\n\t\t\tterm->camera.wObjectiveFocalLengthMax =\n\t\t\t\tget_unaligned_le16(&buffer[10]);\n\t\t\tterm->camera.wOcularFocalLength =\n\t\t\t\tget_unaligned_le16(&buffer[12]);\n\t\t\tmemcpy(term->camera.bmControls, &buffer[15], n);\n\t\t} else if (UVC_ENTITY_TYPE(term) ==\n\t\t\t   UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tterm->media.bControlSize = n;\n\t\t\tterm->media.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->media.bTransportModeSize = p;\n\t\t\tterm->media.bmTransportModes = (u8 *)term\n\t\t\t\t\t\t     + sizeof(*term) + n;\n\t\t\tmemcpy(term->media.bmControls, &buffer[9], n);\n\t\t\tmemcpy(term->media.bmTransportModes, &buffer[10+n], p);\n\t\t}\n\n\t\tif (buffer[7] != 0)\n\t\t\tusb_string(udev, buffer[7], term->name,\n\t\t\t\t   sizeof(term->name));\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA)\n\t\t\tsprintf(term->name, \"Camera %u\", buffer[3]);\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_MEDIA_TRANSPORT_INPUT)\n\t\t\tsprintf(term->name, \"Media %u\", buffer[3]);\n\t\telse\n\t\t\tsprintf(term->name, \"Input %u\", buffer[3]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_OUTPUT_TERMINAL:\n\t\tif (buflen < 9) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d OUTPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Make sure the terminal type MSB is not null, otherwise it\n\t\t * could be confused with a unit.\n\t\t */\n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0xff00) == 0) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d OUTPUT_TERMINAL %d has invalid \"\n\t\t\t\t\"type 0x%04x, skipping\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber, buffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_OUTPUT, buffer[3],\n\t\t\t\t\t1, 0);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(term->baSourceID, &buffer[7], 1);\n\n\t\tif (buffer[8] != 0)\n\t\t\tusb_string(udev, buffer[8], term->name,\n\t\t\t\t   sizeof(term->name));\n\t\telse\n\t\t\tsprintf(term->name, \"Output %u\", buffer[3]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_SELECTOR_UNIT:\n\t\tp = buflen >= 5 ? buffer[4] : 0;\n\n\t\tif (buflen < 5 || buflen < 6 + p) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d SELECTOR_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, 0);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[5], p);\n\n\t\tif (buffer[5+p] != 0)\n\t\t\tusb_string(udev, buffer[5+p], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Selector %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_PROCESSING_UNIT:\n\t\tn = buflen >= 8 ? buffer[7] : 0;\n\t\tp = dev->uvc_version >= 0x0110 ? 10 : 9;\n\n\t\tif (buflen < p + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d PROCESSING_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], 2, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[4], 1);\n\t\tunit->processing.wMaxMultiplier =\n\t\t\tget_unaligned_le16(&buffer[5]);\n\t\tunit->processing.bControlSize = buffer[7];\n\t\tunit->processing.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->processing.bmControls, &buffer[8], n);\n\t\tif (dev->uvc_version >= 0x0110)\n\t\t\tunit->processing.bmVideoStandards = buffer[9+n];\n\n\t\tif (buffer[8+n] != 0)\n\t\t\tusb_string(udev, buffer[8+n], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Processing %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_EXTENSION_UNIT:\n\t\tp = buflen >= 22 ? buffer[21] : 0;\n\t\tn = buflen >= 24 + p ? buffer[22+p] : 0;\n\n\t\tif (buflen < 24 + p + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d EXTENSION_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->extension.guidExtensionCode, &buffer[4], 16);\n\t\tunit->extension.bNumControls = buffer[20];\n\t\tmemcpy(unit->baSourceID, &buffer[22], p);\n\t\tunit->extension.bControlSize = buffer[22+p];\n\t\tunit->extension.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->extension.bmControls, &buffer[23+p], n);\n\n\t\tif (buffer[23+p+n] != 0)\n\t\t\tusb_string(udev, buffer[23+p+n], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Extension %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tdefault:\n\t\tuvc_trace(UVC_TRACE_DESCR, \"Found an unknown CS_INTERFACE \"\n\t\t\t\"descriptor (%u)\\n\", buffer[2]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nint usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\t\tlength = cap->bLength;\n\n\t\tif (total_len < length)\n\t\t\tbreak;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint uclogic_params_init(struct uclogic_params *params,\n\t\t\tstruct hid_device *hdev)\n{\n\tint rc;\n\tstruct usb_device *udev = hid_to_usb_dev(hdev);\n\t__u8  bNumInterfaces = udev->config->desc.bNumInterfaces;\n\tstruct usb_interface *iface = to_usb_interface(hdev->dev.parent);\n\t__u8 bInterfaceNumber = iface->cur_altsetting->desc.bInterfaceNumber;\n\tbool found;\n\t/* The resulting parameters (noop) */\n\tstruct uclogic_params p = {0, };\n\n\t/* Check arguments */\n\tif (params == NULL || hdev == NULL || !hid_is_usb(hdev)) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Set replacement report descriptor if the original matches the\n\t * specified size. Otherwise keep interface unchanged.\n\t */\n#define WITH_OPT_DESC(_orig_desc_token, _new_desc_token) \\\n\tuclogic_params_init_with_opt_desc(                  \\\n\t\t&p, hdev,                                   \\\n\t\tUCLOGIC_RDESC_##_orig_desc_token##_SIZE,    \\\n\t\tuclogic_rdesc_##_new_desc_token##_arr,      \\\n\t\tuclogic_rdesc_##_new_desc_token##_size)\n\n#define VID_PID(_vid, _pid) \\\n\t(((__u32)(_vid) << 16) | ((__u32)(_pid) & U16_MAX))\n\n\t/*\n\t * Handle specific interfaces for specific tablets.\n\t *\n\t * Observe the following logic:\n\t *\n\t * If the interface is recognized as producing certain useful input:\n\t *\tMark interface as valid.\n\t *\tOutput interface parameters.\n\t * Else, if the interface is recognized as *not* producing any useful\n\t * input:\n\t *\tMark interface as invalid.\n\t * Else:\n\t *\tMark interface as valid.\n\t *\tOutput noop parameters.\n\t *\n\t * Rule of thumb: it is better to disable a broken interface than let\n\t *\t\t  it spew garbage input.\n\t */\n\n\tswitch (VID_PID(hdev->vendor, hdev->product)) {\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_PF1209):\n\t\trc = WITH_OPT_DESC(PF1209_ORIG, pf1209_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp4030u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U):\n\t\tif (hdev->dev_rsize == UCLOGIC_RDESC_WP5540U_V2_ORIG_SIZE) {\n\t\t\tif (bInterfaceNumber == 0) {\n\t\t\t\t/* Try to probe v1 pen parameters */\n\t\t\t\trc = uclogic_params_pen_init_v1(&p.pen,\n\t\t\t\t\t\t\t\t&found, hdev);\n\t\t\t\tif (rc != 0) {\n\t\t\t\t\thid_err(hdev,\n\t\t\t\t\t\t\"pen probing failed: %d\\n\",\n\t\t\t\t\t\trc);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\thid_warn(hdev,\n\t\t\t\t\t\t \"pen parameters not found\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp5540u_fixed);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp8060u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP1062):\n\t\trc = WITH_OPT_DESC(WP1062_ORIG, wp1062_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850):\n\t\tswitch (bInterfaceNumber) {\n\t\tcase 0:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG0, twhl850_fixed0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG1, twhl850_fixed1);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG2, twhl850_fixed2);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60):\n\t\t/*\n\t\t * If it is not a three-interface version, which is known to\n\t\t * respond to initialization.\n\t\t */\n\t\tif (bNumInterfaces != 3) {\n\t\t\tswitch (bInterfaceNumber) {\n\t\t\tcase 0:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG0,\n\t\t\t\t\t\t\ttwha60_fixed0);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG1,\n\t\t\t\t\t\t\ttwha60_fixed1);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_HS64):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_YIYNOVA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_81):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_DRAWIMAGE_G3):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_45):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_47):\n\t\trc = uclogic_params_huion_init(&p, hdev);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GP0610):\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GT5040):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G540):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G640):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_RAINBOW_CV720):\n\t\t/* If this is the pen interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01):\n\t\t/* If this is the pen and frame interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* Initialize frame parameters */\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_arr,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_TRUST,\n\t\t     USB_DEVICE_ID_TRUST_PANORA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_G5):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_arr,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_size,\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_ID);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tp.frame.re_lsb =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_RE_LSB;\n\t\t\tp.frame.dev_id_byte =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_DEV_ID_BYTE;\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_EX07S):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_arr,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\t}\n\n#undef VID_PID\n#undef WITH_OPT_DESC\n\n\t/* Output parameters */\n\tmemcpy(params, &p, sizeof(*params));\n\tmemset(&p, 0, sizeof(p));\n\trc = 0;\ncleanup:\n\tuclogic_params_cleanup(&p);\n\treturn rc;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3765,
            "cve_id": "CVE-2022-47520",
            "code_snippet": "void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\t\t\t\tstruct cfg80211_crypto_settings *crypto)\n{\n\tstruct wilc_join_bss_param *param;\n\tstruct ieee80211_p2p_noa_attr noa_attr;\n\tu8 rates_len = 0;\n\tconst u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;\n\tconst u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;\n\tint ret;\n\tconst struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn NULL;\n\n\tparam->beacon_period = cpu_to_le16(bss->beacon_interval);\n\tparam->cap_info = cpu_to_le16(bss->capability);\n\tparam->bss_type = WILC_FW_BSS_TYPE_INFRA;\n\tparam->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tether_addr_copy(param->bssid, bss->bssid);\n\n\tssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (ssid_elm) {\n\t\tif (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)\n\t\t\tmemcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);\n\t}\n\n\ttim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tif (tim_elm && tim_elm[1] >= 2)\n\t\tparam->dtim_period = tim_elm[3];\n\n\tmemset(param->p_suites, 0xFF, 3);\n\tmemset(param->akm_suites, 0xFF, 3);\n\n\trates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);\n\tif (rates_ie) {\n\t\trates_len = rates_ie[1];\n\t\tif (rates_len > WILC_MAX_RATES_SUPPORTED)\n\t\t\trates_len = WILC_MAX_RATES_SUPPORTED;\n\t\tparam->supp_rates[0] = rates_len;\n\t\tmemcpy(&param->supp_rates[1], rates_ie + 2, rates_len);\n\t}\n\n\tif (rates_len < WILC_MAX_RATES_SUPPORTED) {\n\t\tsupp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t\t ies->data, ies->len);\n\t\tif (supp_rates_ie) {\n\t\t\tu8 ext_rates = supp_rates_ie[1];\n\n\t\t\tif (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))\n\t\t\t\tparam->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;\n\t\t\telse\n\t\t\t\tparam->supp_rates[0] += ext_rates;\n\n\t\t\tmemcpy(&param->supp_rates[rates_len + 1],\n\t\t\t       supp_rates_ie + 2,\n\t\t\t       (param->supp_rates[0] - rates_len));\n\t\t}\n\t}\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);\n\tif (ht_ie)\n\t\tparam->ht_capable = true;\n\n\tret = cfg80211_get_p2p_attr(ies->data, ies->len,\n\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t    (u8 *)&noa_attr, sizeof(noa_attr));\n\tif (ret > 0) {\n\t\tparam->tsf_lo = cpu_to_le32(ies->tsf);\n\t\tparam->noa_enabled = 1;\n\t\tparam->idx = noa_attr.index;\n\t\tif (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {\n\t\t\tparam->opp_enabled = 1;\n\t\t\tparam->opp_en.ct_window = noa_attr.oppps_ctwindow;\n\t\t\tparam->opp_en.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_en.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_en.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_en.start_time = noa_attr.desc[0].start_time;\n\t\t} else {\n\t\t\tparam->opp_enabled = 0;\n\t\t\tparam->opp_dis.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_dis.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_dis.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_dis.start_time = noa_attr.desc[0].start_time;\n\t\t}\n\t}\n\twmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wmm_ie) {\n\t\tstruct ieee80211_wmm_param_ie *ie;\n\n\t\tie = (struct ieee80211_wmm_param_ie *)wmm_ie;\n\t\tif ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&\n\t\t    ie->version == 1) {\n\t\t\tparam->wmm_cap = true;\n\t\t\tif (ie->qos_info & BIT(7))\n\t\t\t\tparam->uapsd_cap = true;\n\t\t}\n\t}\n\n\twpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wpa_ie) {\n\t\tparam->mode_802_11i = 1;\n\t\tparam->rsn_found = true;\n\t}\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n\tif (rsn_ie) {\n\t\tint offset = 8;\n\n\t\tparam->mode_802_11i = 2;\n\t\tparam->rsn_found = true;\n\t\t/* extract RSN capabilities */\n\t\toffset += (rsn_ie[offset] * 4) + 2;\n\t\toffset += (rsn_ie[offset] * 4) + 2;\n\t\tmemcpy(param->rsn_cap, &rsn_ie[offset], 2);\n\t}\n\n\tif (param->rsn_found) {\n\t\tint i;\n\n\t\tparam->rsn_grp_policy = crypto->cipher_group & 0xFF;\n\t\tfor (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)\n\t\t\tparam->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;\n\n\t\tfor (i = 0; i < crypto->n_akm_suites && i < 3; i++)\n\t\t\tparam->akm_suites[i] = crypto->akm_suites[i] & 0xFF;\n\t}\n\n\treturn (void *)param;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* Validate length */\n\tif (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))\n\t\treturn -EINVAL;\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}",
                        "code_after_change": "static int technisat_usb2_get_ir(struct dvb_usb_device *d)\n{\n\tstruct technisat_usb2_state *state = d->priv;\n\tstruct ir_raw_event ev;\n\tu8 *buf = state->buf;\n\tint i, ret;\n\n\tbuf[0] = GET_IR_DATA_VENDOR_REQUEST;\n\tbuf[1] = 0x08;\n\tbuf[2] = 0x8f;\n\tbuf[3] = MINIMUM_IR_BIT_TRANSITION_TICK_COUNT;\n\tbuf[4] = MAXIMUM_IR_BIT_TIME_TICK_COUNT;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t0, 0,\n\t\t\tbuf, 5, 500);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t0x8080, 0,\n\t\t\tbuf, 62, 500);\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 1)\n\t\treturn 0; /* no key pressed */\n\n\t/* decoding */\n\n#if 0\n\tdeb_rc(\"RC: %d \", ret);\n\tdebug_dump(buf + 1, ret, deb_rc);\n#endif\n\n\tev.pulse = 0;\n\tfor (i = 1; i < ARRAY_SIZE(state->buf); i++) {\n\t\tif (buf[i] == 0xff) {\n\t\t\tev.pulse = 0;\n\t\t\tev.duration = 888888*2;\n\t\t\tir_raw_event_store(d->rc_dev, &ev);\n\t\t\tbreak;\n\t\t}\n\n\t\tev.pulse = !ev.pulse;\n\t\tev.duration = (buf[i] * FIRMWARE_CLOCK_DIVISOR *\n\t\t\t       FIRMWARE_CLOCK_TICK) / 1000;\n\t\tir_raw_event_store(d->rc_dev, &ev);\n\t}\n\n\tir_raw_event_handle(d->rc_dev);\n\n\treturn 1;\n}",
                        "cve_id": "CVE-2015-9289"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\t\t\t\tstruct cfg80211_crypto_settings *crypto)\n{\n\tstruct wilc_join_bss_param *param;\n\tstruct ieee80211_p2p_noa_attr noa_attr;\n\tu8 rates_len = 0;\n\tconst u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;\n\tconst u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;\n\tint ret;\n\tconst struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn NULL;\n\n\tparam->beacon_period = cpu_to_le16(bss->beacon_interval);\n\tparam->cap_info = cpu_to_le16(bss->capability);\n\tparam->bss_type = WILC_FW_BSS_TYPE_INFRA;\n\tparam->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tether_addr_copy(param->bssid, bss->bssid);\n\n\tssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (ssid_elm) {\n\t\tif (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)\n\t\t\tmemcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);\n\t}\n\n\ttim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tif (tim_elm && tim_elm[1] >= 2)\n\t\tparam->dtim_period = tim_elm[3];\n\n\tmemset(param->p_suites, 0xFF, 3);\n\tmemset(param->akm_suites, 0xFF, 3);\n\n\trates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);\n\tif (rates_ie) {\n\t\trates_len = rates_ie[1];\n\t\tif (rates_len > WILC_MAX_RATES_SUPPORTED)\n\t\t\trates_len = WILC_MAX_RATES_SUPPORTED;\n\t\tparam->supp_rates[0] = rates_len;\n\t\tmemcpy(&param->supp_rates[1], rates_ie + 2, rates_len);\n\t}\n\n\tif (rates_len < WILC_MAX_RATES_SUPPORTED) {\n\t\tsupp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t\t ies->data, ies->len);\n\t\tif (supp_rates_ie) {\n\t\t\tu8 ext_rates = supp_rates_ie[1];\n\n\t\t\tif (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))\n\t\t\t\tparam->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;\n\t\t\telse\n\t\t\t\tparam->supp_rates[0] += ext_rates;\n\n\t\t\tmemcpy(&param->supp_rates[rates_len + 1],\n\t\t\t       supp_rates_ie + 2,\n\t\t\t       (param->supp_rates[0] - rates_len));\n\t\t}\n\t}\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);\n\tif (ht_ie)\n\t\tparam->ht_capable = true;\n\n\tret = cfg80211_get_p2p_attr(ies->data, ies->len,\n\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t    (u8 *)&noa_attr, sizeof(noa_attr));\n\tif (ret > 0) {\n\t\tparam->tsf_lo = cpu_to_le32(ies->tsf);\n\t\tparam->noa_enabled = 1;\n\t\tparam->idx = noa_attr.index;\n\t\tif (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {\n\t\t\tparam->opp_enabled = 1;\n\t\t\tparam->opp_en.ct_window = noa_attr.oppps_ctwindow;\n\t\t\tparam->opp_en.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_en.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_en.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_en.start_time = noa_attr.desc[0].start_time;\n\t\t} else {\n\t\t\tparam->opp_enabled = 0;\n\t\t\tparam->opp_dis.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_dis.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_dis.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_dis.start_time = noa_attr.desc[0].start_time;\n\t\t}\n\t}\n\twmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wmm_ie) {\n\t\tstruct ieee80211_wmm_param_ie *ie;\n\n\t\tie = (struct ieee80211_wmm_param_ie *)wmm_ie;\n\t\tif ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&\n\t\t    ie->version == 1) {\n\t\t\tparam->wmm_cap = true;\n\t\t\tif (ie->qos_info & BIT(7))\n\t\t\t\tparam->uapsd_cap = true;\n\t\t}\n\t}\n\n\twpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wpa_ie) {\n\t\tparam->mode_802_11i = 1;\n\t\tparam->rsn_found = true;\n\t}\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n\tif (rsn_ie) {\n\t\tint offset = 8;\n\n\t\tparam->mode_802_11i = 2;\n\t\tparam->rsn_found = true;\n\t\t/* extract RSN capabilities */\n\t\toffset += (rsn_ie[offset] * 4) + 2;\n\t\toffset += (rsn_ie[offset] * 4) + 2;\n\t\tmemcpy(param->rsn_cap, &rsn_ie[offset], 2);\n\t}\n\n\tif (param->rsn_found) {\n\t\tint i;\n\n\t\tparam->rsn_grp_policy = crypto->cipher_group & 0xFF;\n\t\tfor (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)\n\t\t\tparam->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;\n\n\t\tfor (i = 0; i < crypto->n_akm_suites && i < 3; i++)\n\t\t\tparam->akm_suites[i] = crypto->akm_suites[i] & 0xFF;\n\t}\n\n\treturn (void *)param;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* Validate length */\n\tif (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))\n\t\treturn -EINVAL;\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int technisat_usb2_get_ir(struct dvb_usb_device *d)\n{\n\tstruct technisat_usb2_state *state = d->priv;\n\tstruct ir_raw_event ev;\n\tu8 *buf = state->buf;\n\tint i, ret;\n\n\tbuf[0] = GET_IR_DATA_VENDOR_REQUEST;\n\tbuf[1] = 0x08;\n\tbuf[2] = 0x8f;\n\tbuf[3] = MINIMUM_IR_BIT_TRANSITION_TICK_COUNT;\n\tbuf[4] = MAXIMUM_IR_BIT_TIME_TICK_COUNT;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t0, 0,\n\t\t\tbuf, 5, 500);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t0x8080, 0,\n\t\t\tbuf, 62, 500);\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 1)\n\t\treturn 0; /* no key pressed */\n\n\t/* decoding */\n\n#if 0\n\tdeb_rc(\"RC: %d \", ret);\n\tdebug_dump(buf + 1, ret, deb_rc);\n#endif\n\n\tev.pulse = 0;\n\tfor (i = 1; i < ARRAY_SIZE(state->buf); i++) {\n\t\tif (buf[i] == 0xff) {\n\t\t\tev.pulse = 0;\n\t\t\tev.duration = 888888*2;\n\t\t\tir_raw_event_store(d->rc_dev, &ev);\n\t\t\tbreak;\n\t\t}\n\n\t\tev.pulse = !ev.pulse;\n\t\tev.duration = (buf[i] * FIRMWARE_CLOCK_DIVISOR *\n\t\t\t       FIRMWARE_CLOCK_TICK) / 1000;\n\t\tir_raw_event_store(d->rc_dev, &ev);\n\t}\n\n\tir_raw_event_handle(d->rc_dev);\n\n\treturn 1;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "code_after_change": "static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Validate length */\n\tif (d->msg_len > sizeof(d->msg))\n                return -EINVAL;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2019-15927"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\t\t\t\tstruct cfg80211_crypto_settings *crypto)\n{\n\tstruct wilc_join_bss_param *param;\n\tstruct ieee80211_p2p_noa_attr noa_attr;\n\tu8 rates_len = 0;\n\tconst u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;\n\tconst u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;\n\tint ret;\n\tconst struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn NULL;\n\n\tparam->beacon_period = cpu_to_le16(bss->beacon_interval);\n\tparam->cap_info = cpu_to_le16(bss->capability);\n\tparam->bss_type = WILC_FW_BSS_TYPE_INFRA;\n\tparam->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tether_addr_copy(param->bssid, bss->bssid);\n\n\tssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (ssid_elm) {\n\t\tif (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)\n\t\t\tmemcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);\n\t}\n\n\ttim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tif (tim_elm && tim_elm[1] >= 2)\n\t\tparam->dtim_period = tim_elm[3];\n\n\tmemset(param->p_suites, 0xFF, 3);\n\tmemset(param->akm_suites, 0xFF, 3);\n\n\trates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);\n\tif (rates_ie) {\n\t\trates_len = rates_ie[1];\n\t\tif (rates_len > WILC_MAX_RATES_SUPPORTED)\n\t\t\trates_len = WILC_MAX_RATES_SUPPORTED;\n\t\tparam->supp_rates[0] = rates_len;\n\t\tmemcpy(&param->supp_rates[1], rates_ie + 2, rates_len);\n\t}\n\n\tif (rates_len < WILC_MAX_RATES_SUPPORTED) {\n\t\tsupp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t\t ies->data, ies->len);\n\t\tif (supp_rates_ie) {\n\t\t\tu8 ext_rates = supp_rates_ie[1];\n\n\t\t\tif (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))\n\t\t\t\tparam->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;\n\t\t\telse\n\t\t\t\tparam->supp_rates[0] += ext_rates;\n\n\t\t\tmemcpy(&param->supp_rates[rates_len + 1],\n\t\t\t       supp_rates_ie + 2,\n\t\t\t       (param->supp_rates[0] - rates_len));\n\t\t}\n\t}\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);\n\tif (ht_ie)\n\t\tparam->ht_capable = true;\n\n\tret = cfg80211_get_p2p_attr(ies->data, ies->len,\n\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t    (u8 *)&noa_attr, sizeof(noa_attr));\n\tif (ret > 0) {\n\t\tparam->tsf_lo = cpu_to_le32(ies->tsf);\n\t\tparam->noa_enabled = 1;\n\t\tparam->idx = noa_attr.index;\n\t\tif (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {\n\t\t\tparam->opp_enabled = 1;\n\t\t\tparam->opp_en.ct_window = noa_attr.oppps_ctwindow;\n\t\t\tparam->opp_en.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_en.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_en.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_en.start_time = noa_attr.desc[0].start_time;\n\t\t} else {\n\t\t\tparam->opp_enabled = 0;\n\t\t\tparam->opp_dis.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_dis.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_dis.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_dis.start_time = noa_attr.desc[0].start_time;\n\t\t}\n\t}\n\twmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wmm_ie) {\n\t\tstruct ieee80211_wmm_param_ie *ie;\n\n\t\tie = (struct ieee80211_wmm_param_ie *)wmm_ie;\n\t\tif ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&\n\t\t    ie->version == 1) {\n\t\t\tparam->wmm_cap = true;\n\t\t\tif (ie->qos_info & BIT(7))\n\t\t\t\tparam->uapsd_cap = true;\n\t\t}\n\t}\n\n\twpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wpa_ie) {\n\t\tparam->mode_802_11i = 1;\n\t\tparam->rsn_found = true;\n\t}\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n\tif (rsn_ie) {\n\t\tint offset = 8;\n\n\t\tparam->mode_802_11i = 2;\n\t\tparam->rsn_found = true;\n\t\t/* extract RSN capabilities */\n\t\toffset += (rsn_ie[offset] * 4) + 2;\n\t\toffset += (rsn_ie[offset] * 4) + 2;\n\t\tmemcpy(param->rsn_cap, &rsn_ie[offset], 2);\n\t}\n\n\tif (param->rsn_found) {\n\t\tint i;\n\n\t\tparam->rsn_grp_policy = crypto->cipher_group & 0xFF;\n\t\tfor (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)\n\t\t\tparam->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;\n\n\t\tfor (i = 0; i < crypto->n_akm_suites && i < 3; i++)\n\t\t\tparam->akm_suites[i] = crypto->akm_suites[i] & 0xFF;\n\t}\n\n\treturn (void *)param;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Validate length */\n\tif (d->msg_len > sizeof(d->msg))\n                return -EINVAL;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2021-3444"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\t\t\t\tstruct cfg80211_crypto_settings *crypto)\n{\n\tstruct wilc_join_bss_param *param;\n\tstruct ieee80211_p2p_noa_attr noa_attr;\n\tu8 rates_len = 0;\n\tconst u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;\n\tconst u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;\n\tint ret;\n\tconst struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn NULL;\n\n\tparam->beacon_period = cpu_to_le16(bss->beacon_interval);\n\tparam->cap_info = cpu_to_le16(bss->capability);\n\tparam->bss_type = WILC_FW_BSS_TYPE_INFRA;\n\tparam->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tether_addr_copy(param->bssid, bss->bssid);\n\n\tssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (ssid_elm) {\n\t\tif (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)\n\t\t\tmemcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);\n\t}\n\n\ttim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tif (tim_elm && tim_elm[1] >= 2)\n\t\tparam->dtim_period = tim_elm[3];\n\n\tmemset(param->p_suites, 0xFF, 3);\n\tmemset(param->akm_suites, 0xFF, 3);\n\n\trates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);\n\tif (rates_ie) {\n\t\trates_len = rates_ie[1];\n\t\tif (rates_len > WILC_MAX_RATES_SUPPORTED)\n\t\t\trates_len = WILC_MAX_RATES_SUPPORTED;\n\t\tparam->supp_rates[0] = rates_len;\n\t\tmemcpy(&param->supp_rates[1], rates_ie + 2, rates_len);\n\t}\n\n\tif (rates_len < WILC_MAX_RATES_SUPPORTED) {\n\t\tsupp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t\t ies->data, ies->len);\n\t\tif (supp_rates_ie) {\n\t\t\tu8 ext_rates = supp_rates_ie[1];\n\n\t\t\tif (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))\n\t\t\t\tparam->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;\n\t\t\telse\n\t\t\t\tparam->supp_rates[0] += ext_rates;\n\n\t\t\tmemcpy(&param->supp_rates[rates_len + 1],\n\t\t\t       supp_rates_ie + 2,\n\t\t\t       (param->supp_rates[0] - rates_len));\n\t\t}\n\t}\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);\n\tif (ht_ie)\n\t\tparam->ht_capable = true;\n\n\tret = cfg80211_get_p2p_attr(ies->data, ies->len,\n\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t    (u8 *)&noa_attr, sizeof(noa_attr));\n\tif (ret > 0) {\n\t\tparam->tsf_lo = cpu_to_le32(ies->tsf);\n\t\tparam->noa_enabled = 1;\n\t\tparam->idx = noa_attr.index;\n\t\tif (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {\n\t\t\tparam->opp_enabled = 1;\n\t\t\tparam->opp_en.ct_window = noa_attr.oppps_ctwindow;\n\t\t\tparam->opp_en.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_en.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_en.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_en.start_time = noa_attr.desc[0].start_time;\n\t\t} else {\n\t\t\tparam->opp_enabled = 0;\n\t\t\tparam->opp_dis.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_dis.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_dis.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_dis.start_time = noa_attr.desc[0].start_time;\n\t\t}\n\t}\n\twmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wmm_ie) {\n\t\tstruct ieee80211_wmm_param_ie *ie;\n\n\t\tie = (struct ieee80211_wmm_param_ie *)wmm_ie;\n\t\tif ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&\n\t\t    ie->version == 1) {\n\t\t\tparam->wmm_cap = true;\n\t\t\tif (ie->qos_info & BIT(7))\n\t\t\t\tparam->uapsd_cap = true;\n\t\t}\n\t}\n\n\twpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wpa_ie) {\n\t\tparam->mode_802_11i = 1;\n\t\tparam->rsn_found = true;\n\t}\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n\tif (rsn_ie) {\n\t\tint offset = 8;\n\n\t\tparam->mode_802_11i = 2;\n\t\tparam->rsn_found = true;\n\t\t/* extract RSN capabilities */\n\t\toffset += (rsn_ie[offset] * 4) + 2;\n\t\toffset += (rsn_ie[offset] * 4) + 2;\n\t\tmemcpy(param->rsn_cap, &rsn_ie[offset], 2);\n\t}\n\n\tif (param->rsn_found) {\n\t\tint i;\n\n\t\tparam->rsn_grp_policy = crypto->cipher_group & 0xFF;\n\t\tfor (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)\n\t\t\tparam->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;\n\n\t\tfor (i = 0; i < crypto->n_akm_suites && i < 3; i++)\n\t\t\tparam->akm_suites[i] = crypto->akm_suites[i] & 0xFF;\n\t}\n\n\treturn (void *)param;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 1252,
            "cve_id": "CVE-2017-11600",
            "code_snippet": "int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\n\t/* Stage 1 - find policy */\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Stage 2 - find and update state(s) */\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Stage 3 - update policy */\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\n\t/* Stage 4 - delete old state(s) */\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\n\t/* Stage 5 - announce */\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\n\txfrm_pol_put(pol);\n\n\treturn 0;\nout:\n\treturn err;\n\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg) ||\n\t\t    skb->len < nlh->nlmsg_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}",
                        "code_after_change": "static void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t\t    skb->len < nlh->nlmsg_len ||\n\t\t    nlmsg_len(nlh) < sizeof(struct nfgenmsg)) {\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}",
                        "cve_id": "CVE-2016-7917"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\n\t/* Stage 1 - find policy */\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Stage 2 - find and update state(s) */\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Stage 3 - update policy */\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\n\t/* Stage 4 - delete old state(s) */\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\n\t/* Stage 5 - announce */\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\n\txfrm_pol_put(pol);\n\n\treturn 0;\nout:\n\treturn err;\n\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg) ||\n\t\t    skb->len < nlh->nlmsg_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t\t    skb->len < nlh->nlmsg_len ||\n\t\t    nlmsg_len(nlh) < sizeof(struct nfgenmsg)) {\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2020-14314"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\n\t/* Stage 1 - find policy */\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Stage 2 - find and update state(s) */\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Stage 3 - update policy */\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\n\t/* Stage 4 - delete old state(s) */\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\n\t/* Stage 5 - announce */\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\n\txfrm_pol_put(pol);\n\n\treturn 0;\nout:\n\treturn err;\n\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static int f2fs_move_inline_dirents(struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tvoid *inline_dentry)\n{\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr src, dst;\n\tint err;\n\n\tpage = f2fs_grab_cache_page(dir->i_mapping, 0, false);\n\tif (!page) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tif (unlikely(dn.data_blkaddr != NEW_ADDR)) {\n\t\tf2fs_put_dnode(&dn);\n\t\tset_sbi_flag(F2FS_P_SB(page), SBI_NEED_FSCK);\n\t\tf2fs_msg(F2FS_P_SB(page)->sb, KERN_WARNING,\n\t\t\t\"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"\n\t\t\t\"run fsck to fix.\",\n\t\t\t__func__, dir->i_ino, dn.data_blkaddr);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tf2fs_wait_on_page_writeback(page, DATA, true);\n\n\tdentry_blk = page_address(page);\n\n\tmake_dentry_ptr_inline(dir, &src, inline_dentry);\n\tmake_dentry_ptr_block(dir, &dst, dentry_blk);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dst.bitmap, src.bitmap, src.nr_bitmap);\n\tmemset(dst.bitmap + src.nr_bitmap, 0, dst.nr_bitmap - src.nr_bitmap);\n\t/*\n\t * we do not need to zero out remainder part of dentry and filename\n\t * field, since we have used bitmap for marking the usage status of\n\t * them, besides, we can also ignore copying/zeroing reserved space\n\t * of dentry block, because them haven't been used so far.\n\t */\n\tmemcpy(dst.dentry, src.dentry, SIZE_OF_DIR_ENTRY * src.max);\n\tmemcpy(dst.filename, src.filename, src.max * F2FS_SLOT_LEN);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\t/* clear inline dir and flag after data writeback */\n\tf2fs_truncate_inline_inode(dir, ipage, 0);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(dir, FI_INLINE_DENTRY);\n\n\tf2fs_i_depth_write(dir, 1);\n\tif (i_size_read(dir) < PAGE_SIZE)\n\t\tf2fs_i_size_write(dir, PAGE_SIZE);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\n\t/* Stage 1 - find policy */\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Stage 2 - find and update state(s) */\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Stage 3 - update policy */\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\n\t/* Stage 4 - delete old state(s) */\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\n\t/* Stage 5 - announce */\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\n\txfrm_pol_put(pol);\n\n\treturn 0;\nout:\n\treturn err;\n\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int f2fs_move_inline_dirents(struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tvoid *inline_dentry)\n{\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr src, dst;\n\tint err;\n\n\tpage = f2fs_grab_cache_page(dir->i_mapping, 0, false);\n\tif (!page) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tif (unlikely(dn.data_blkaddr != NEW_ADDR)) {\n\t\tf2fs_put_dnode(&dn);\n\t\tset_sbi_flag(F2FS_P_SB(page), SBI_NEED_FSCK);\n\t\tf2fs_msg(F2FS_P_SB(page)->sb, KERN_WARNING,\n\t\t\t\"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"\n\t\t\t\"run fsck to fix.\",\n\t\t\t__func__, dir->i_ino, dn.data_blkaddr);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tf2fs_wait_on_page_writeback(page, DATA, true);\n\n\tdentry_blk = page_address(page);\n\n\tmake_dentry_ptr_inline(dir, &src, inline_dentry);\n\tmake_dentry_ptr_block(dir, &dst, dentry_blk);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dst.bitmap, src.bitmap, src.nr_bitmap);\n\tmemset(dst.bitmap + src.nr_bitmap, 0, dst.nr_bitmap - src.nr_bitmap);\n\t/*\n\t * we do not need to zero out remainder part of dentry and filename\n\t * field, since we have used bitmap for marking the usage status of\n\t * them, besides, we can also ignore copying/zeroing reserved space\n\t * of dentry block, because them haven't been used so far.\n\t */\n\tmemcpy(dst.dentry, src.dentry, SIZE_OF_DIR_ENTRY * src.max);\n\tmemcpy(dst.filename, src.filename, src.max * F2FS_SLOT_LEN);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\t/* clear inline dir and flag after data writeback */\n\tf2fs_truncate_inline_inode(dir, ipage, 0);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(dir, FI_INLINE_DENTRY);\n\n\tf2fs_i_depth_write(dir, 1);\n\tif (i_size_read(dir) < PAGE_SIZE)\n\t\tf2fs_i_size_write(dir, PAGE_SIZE);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2265,
            "cve_id": "CVE-2019-19927",
            "code_snippet": "static void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n\t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t/* Check that we don't go over the pool limit */\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don't go over the pool limit */\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "code_after_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "cve_id": "CVE-2023-37453"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n\t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t/* Check that we don't go over the pool limit */\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don't go over the pool limit */\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tif (!vga_init_done) {\n\t\tvgacon_scrollback_startup();\n\t\tvga_init_done = true;\n\t}\n\n\treturn display_desc;\n}",
                        "code_after_change": "static const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tvga_init_done = true;\n\n\treturn display_desc;\n}",
                        "cve_id": "CVE-2020-28097"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n\t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t/* Check that we don't go over the pool limit */\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don't go over the pool limit */\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tif (!vga_init_done) {\n\t\tvgacon_scrollback_startup();\n\t\tvga_init_done = true;\n\t}\n\n\treturn display_desc;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tvga_init_done = true;\n\n\treturn display_desc;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "code_after_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2016-10208"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n\t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (p++ != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t/* Check that we don't go over the pool limit */\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don't go over the pool limit */\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2379,
            "cve_id": "CVE-2020-0427",
            "code_snippet": "static void dt_free_map(struct pinctrl_dev *pctldev,\n\t\t     struct pinctrl_map *map, unsigned num_maps)\n{\n\tif (pctldev) {\n\t\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\t\tif (ops->dt_free_map)\n\t\t\tops->dt_free_map(pctldev, map, num_maps);\n\t} else {\n\t\t/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */\n\t\tkfree(map);\n\t}\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2021-3444"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void dt_free_map(struct pinctrl_dev *pctldev,\n\t\t     struct pinctrl_map *map, unsigned num_maps)\n{\n\tif (pctldev) {\n\t\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\t\tif (ops->dt_free_map)\n\t\t\tops->dt_free_map(pctldev, map, num_maps);\n\t} else {\n\t\t/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */\n\t\tkfree(map);\n\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "code_after_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "cve_id": "CVE-2019-15927"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void dt_free_map(struct pinctrl_dev *pctldev,\n\t\t     struct pinctrl_map *map, unsigned num_maps)\n{\n\tif (pctldev) {\n\t\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\t\tif (ops->dt_free_map)\n\t\t\tops->dt_free_map(pctldev, map, num_maps);\n\t} else {\n\t\t/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */\n\t\tkfree(map);\n\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,\n\tnetdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct ipv6hdr *ipv6h;\n\tconst struct net_offload *ops;\n\tint proto;\n\tstruct frag_hdr *fptr;\n\tunsigned int unfrag_ip6hlen;\n\tunsigned int payload_len;\n\tu8 *prevhdr;\n\tint offset = 0;\n\tbool encap, udpfrag;\n\tint nhoff;\n\tbool gso_partial;\n\n\tskb_reset_network_header(skb);\n\tnhoff = skb_network_header(skb) - skb_mac_header(skb);\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\n\t\tgoto out;\n\n\tencap = SKB_GSO_CB(skb)->encap_level > 0;\n\tif (encap)\n\t\tfeatures &= skb->dev->hw_enc_features;\n\tSKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);\n\n\tipv6h = ipv6_hdr(skb);\n\t__skb_pull(skb, sizeof(*ipv6h));\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\n\tproto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\n\n\tif (skb->encapsulation &&\n\t    skb_shinfo(skb)->gso_type & (SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6))\n\t\tudpfrag = proto == IPPROTO_UDP && encap;\n\telse\n\t\tudpfrag = proto == IPPROTO_UDP && !skb->encapsulation;\n\n\tops = rcu_dereference(inet6_offloads[proto]);\n\tif (likely(ops && ops->callbacks.gso_segment)) {\n\t\tskb_reset_transport_header(skb);\n\t\tsegs = ops->callbacks.gso_segment(skb, features);\n\t}\n\n\tif (IS_ERR_OR_NULL(segs))\n\t\tgoto out;\n\n\tgso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);\n\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);\n\t\tif (gso_partial)\n\t\t\tpayload_len = skb_shinfo(skb)->gso_size +\n\t\t\t\t      SKB_GSO_CB(skb)->data_offset +\n\t\t\t\t      skb->head - (unsigned char *)(ipv6h + 1);\n\t\telse\n\t\t\tpayload_len = skb->len - nhoff - sizeof(*ipv6h);\n\t\tipv6h->payload_len = htons(payload_len);\n\t\tskb->network_header = (u8 *)ipv6h - skb->head;\n\n\t\tif (udpfrag) {\n\t\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\t\tfptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);\n\t\t\tfptr->frag_off = htons(offset);\n\t\t\tif (skb->next)\n\t\t\t\tfptr->frag_off |= htons(IP6_MF);\n\t\t\toffset += (ntohs(ipv6h->payload_len) -\n\t\t\t\t   sizeof(struct frag_hdr));\n\t\t}\n\t\tif (encap)\n\t\t\tskb_reset_inner_headers(skb);\n\t}\n\nout:\n\treturn segs;\n}",
                        "code_after_change": "static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,\n\tnetdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct ipv6hdr *ipv6h;\n\tconst struct net_offload *ops;\n\tint proto;\n\tstruct frag_hdr *fptr;\n\tunsigned int unfrag_ip6hlen;\n\tunsigned int payload_len;\n\tu8 *prevhdr;\n\tint offset = 0;\n\tbool encap, udpfrag;\n\tint nhoff;\n\tbool gso_partial;\n\n\tskb_reset_network_header(skb);\n\tnhoff = skb_network_header(skb) - skb_mac_header(skb);\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\n\t\tgoto out;\n\n\tencap = SKB_GSO_CB(skb)->encap_level > 0;\n\tif (encap)\n\t\tfeatures &= skb->dev->hw_enc_features;\n\tSKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);\n\n\tipv6h = ipv6_hdr(skb);\n\t__skb_pull(skb, sizeof(*ipv6h));\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\n\tproto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\n\n\tif (skb->encapsulation &&\n\t    skb_shinfo(skb)->gso_type & (SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6))\n\t\tudpfrag = proto == IPPROTO_UDP && encap;\n\telse\n\t\tudpfrag = proto == IPPROTO_UDP && !skb->encapsulation;\n\n\tops = rcu_dereference(inet6_offloads[proto]);\n\tif (likely(ops && ops->callbacks.gso_segment)) {\n\t\tskb_reset_transport_header(skb);\n\t\tsegs = ops->callbacks.gso_segment(skb, features);\n\t}\n\n\tif (IS_ERR_OR_NULL(segs))\n\t\tgoto out;\n\n\tgso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);\n\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);\n\t\tif (gso_partial)\n\t\t\tpayload_len = skb_shinfo(skb)->gso_size +\n\t\t\t\t      SKB_GSO_CB(skb)->data_offset +\n\t\t\t\t      skb->head - (unsigned char *)(ipv6h + 1);\n\t\telse\n\t\t\tpayload_len = skb->len - nhoff - sizeof(*ipv6h);\n\t\tipv6h->payload_len = htons(payload_len);\n\t\tskb->network_header = (u8 *)ipv6h - skb->head;\n\n\t\tif (udpfrag) {\n\t\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\t\tif (unfrag_ip6hlen < 0)\n\t\t\t\treturn ERR_PTR(unfrag_ip6hlen);\n\t\t\tfptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);\n\t\t\tfptr->frag_off = htons(offset);\n\t\t\tif (skb->next)\n\t\t\t\tfptr->frag_off |= htons(IP6_MF);\n\t\t\toffset += (ntohs(ipv6h->payload_len) -\n\t\t\t\t   sizeof(struct frag_hdr));\n\t\t}\n\t\tif (encap)\n\t\t\tskb_reset_inner_headers(skb);\n\t}\n\nout:\n\treturn segs;\n}",
                        "cve_id": "CVE-2017-9074"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void dt_free_map(struct pinctrl_dev *pctldev,\n\t\t     struct pinctrl_map *map, unsigned num_maps)\n{\n\tif (pctldev) {\n\t\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\t\tif (ops->dt_free_map)\n\t\t\tops->dt_free_map(pctldev, map, num_maps);\n\t} else {\n\t\t/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */\n\t\tkfree(map);\n\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,\n\tnetdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct ipv6hdr *ipv6h;\n\tconst struct net_offload *ops;\n\tint proto;\n\tstruct frag_hdr *fptr;\n\tunsigned int unfrag_ip6hlen;\n\tunsigned int payload_len;\n\tu8 *prevhdr;\n\tint offset = 0;\n\tbool encap, udpfrag;\n\tint nhoff;\n\tbool gso_partial;\n\n\tskb_reset_network_header(skb);\n\tnhoff = skb_network_header(skb) - skb_mac_header(skb);\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\n\t\tgoto out;\n\n\tencap = SKB_GSO_CB(skb)->encap_level > 0;\n\tif (encap)\n\t\tfeatures &= skb->dev->hw_enc_features;\n\tSKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);\n\n\tipv6h = ipv6_hdr(skb);\n\t__skb_pull(skb, sizeof(*ipv6h));\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\n\tproto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\n\n\tif (skb->encapsulation &&\n\t    skb_shinfo(skb)->gso_type & (SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6))\n\t\tudpfrag = proto == IPPROTO_UDP && encap;\n\telse\n\t\tudpfrag = proto == IPPROTO_UDP && !skb->encapsulation;\n\n\tops = rcu_dereference(inet6_offloads[proto]);\n\tif (likely(ops && ops->callbacks.gso_segment)) {\n\t\tskb_reset_transport_header(skb);\n\t\tsegs = ops->callbacks.gso_segment(skb, features);\n\t}\n\n\tif (IS_ERR_OR_NULL(segs))\n\t\tgoto out;\n\n\tgso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);\n\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);\n\t\tif (gso_partial)\n\t\t\tpayload_len = skb_shinfo(skb)->gso_size +\n\t\t\t\t      SKB_GSO_CB(skb)->data_offset +\n\t\t\t\t      skb->head - (unsigned char *)(ipv6h + 1);\n\t\telse\n\t\t\tpayload_len = skb->len - nhoff - sizeof(*ipv6h);\n\t\tipv6h->payload_len = htons(payload_len);\n\t\tskb->network_header = (u8 *)ipv6h - skb->head;\n\n\t\tif (udpfrag) {\n\t\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\t\tfptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);\n\t\t\tfptr->frag_off = htons(offset);\n\t\t\tif (skb->next)\n\t\t\t\tfptr->frag_off |= htons(IP6_MF);\n\t\t\toffset += (ntohs(ipv6h->payload_len) -\n\t\t\t\t   sizeof(struct frag_hdr));\n\t\t}\n\t\tif (encap)\n\t\t\tskb_reset_inner_headers(skb);\n\t}\n\nout:\n\treturn segs;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,\n\tnetdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct ipv6hdr *ipv6h;\n\tconst struct net_offload *ops;\n\tint proto;\n\tstruct frag_hdr *fptr;\n\tunsigned int unfrag_ip6hlen;\n\tunsigned int payload_len;\n\tu8 *prevhdr;\n\tint offset = 0;\n\tbool encap, udpfrag;\n\tint nhoff;\n\tbool gso_partial;\n\n\tskb_reset_network_header(skb);\n\tnhoff = skb_network_header(skb) - skb_mac_header(skb);\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\n\t\tgoto out;\n\n\tencap = SKB_GSO_CB(skb)->encap_level > 0;\n\tif (encap)\n\t\tfeatures &= skb->dev->hw_enc_features;\n\tSKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);\n\n\tipv6h = ipv6_hdr(skb);\n\t__skb_pull(skb, sizeof(*ipv6h));\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\n\tproto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\n\n\tif (skb->encapsulation &&\n\t    skb_shinfo(skb)->gso_type & (SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6))\n\t\tudpfrag = proto == IPPROTO_UDP && encap;\n\telse\n\t\tudpfrag = proto == IPPROTO_UDP && !skb->encapsulation;\n\n\tops = rcu_dereference(inet6_offloads[proto]);\n\tif (likely(ops && ops->callbacks.gso_segment)) {\n\t\tskb_reset_transport_header(skb);\n\t\tsegs = ops->callbacks.gso_segment(skb, features);\n\t}\n\n\tif (IS_ERR_OR_NULL(segs))\n\t\tgoto out;\n\n\tgso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);\n\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);\n\t\tif (gso_partial)\n\t\t\tpayload_len = skb_shinfo(skb)->gso_size +\n\t\t\t\t      SKB_GSO_CB(skb)->data_offset +\n\t\t\t\t      skb->head - (unsigned char *)(ipv6h + 1);\n\t\telse\n\t\t\tpayload_len = skb->len - nhoff - sizeof(*ipv6h);\n\t\tipv6h->payload_len = htons(payload_len);\n\t\tskb->network_header = (u8 *)ipv6h - skb->head;\n\n\t\tif (udpfrag) {\n\t\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\t\tif (unfrag_ip6hlen < 0)\n\t\t\t\treturn ERR_PTR(unfrag_ip6hlen);\n\t\t\tfptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);\n\t\t\tfptr->frag_off = htons(offset);\n\t\t\tif (skb->next)\n\t\t\t\tfptr->frag_off |= htons(IP6_MF);\n\t\t\toffset += (ntohs(ipv6h->payload_len) -\n\t\t\t\t   sizeof(struct frag_hdr));\n\t\t}\n\t\tif (encap)\n\t\t\tskb_reset_inner_headers(skb);\n\t}\n\nout:\n\treturn segs;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2380,
            "cve_id": "CVE-2020-0427",
            "code_snippet": "static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t/* Initialize common mapping table entry fields */\n\tfor (i = 0; i < num_maps; i++) {\n\t\tmap[i].dev_name = dev_name(p->dev);\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t/* Remember the converted mapping table entries */\n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map) {\n\t\tdt_free_map(pctldev, map, num_maps);\n\t\treturn -ENOMEM;\n\t}\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_map(map, num_maps, false);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2020-14314"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t/* Initialize common mapping table entry fields */\n\tfor (i = 0; i < num_maps; i++) {\n\t\tmap[i].dev_name = dev_name(p->dev);\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t/* Remember the converted mapping table entries */\n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map) {\n\t\tdt_free_map(pctldev, map, num_maps);\n\t\treturn -ENOMEM;\n\t}\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_map(map, num_maps, false);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "code_after_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "cve_id": "CVE-2019-15927"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t/* Initialize common mapping table entry fields */\n\tfor (i = 0; i < num_maps; i++) {\n\t\tmap[i].dev_name = dev_name(p->dev);\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t/* Remember the converted mapping table entries */\n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map) {\n\t\tdt_free_map(pctldev, map, num_maps);\n\t\treturn -ENOMEM;\n\t}\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_map(map, num_maps, false);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2021-3444"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t/* Initialize common mapping table entry fields */\n\tfor (i = 0; i < num_maps; i++) {\n\t\tmap[i].dev_name = dev_name(p->dev);\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t/* Remember the converted mapping table entries */\n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map) {\n\t\tdt_free_map(pctldev, map, num_maps);\n\t\treturn -ENOMEM;\n\t}\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_map(map, num_maps, false);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 3016,
            "cve_id": "CVE-2021-3506",
            "code_snippet": "static void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(journal, i));\n\n\t\traw_ne = nat_in_journal(journal, i);\n\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = __alloc_nat_entry(nid, true);\n\t\t\t__init_nat_entry(nm_i, ne, &raw_ne, true);\n\t\t}\n\n\t\t/*\n\t\t * if a free nat in journal has not been used after last\n\t\t * checkpoint, we should remove it from available nids,\n\t\t * since later we will add it again.\n\t\t */\n\t\tif (!get_nat_flag(ne, IS_DIRTY) &&\n\t\t\t\tle32_to_cpu(raw_ne.block_addr) == NULL_ADDR) {\n\t\t\tspin_lock(&nm_i->nid_list_lock);\n\t\t\tnm_i->available_nids--;\n\t\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\t}\n\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t}\n\tupdate_nats_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "code_after_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "cve_id": "CVE-2016-10208"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(journal, i));\n\n\t\traw_ne = nat_in_journal(journal, i);\n\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = __alloc_nat_entry(nid, true);\n\t\t\t__init_nat_entry(nm_i, ne, &raw_ne, true);\n\t\t}\n\n\t\t/*\n\t\t * if a free nat in journal has not been used after last\n\t\t * checkpoint, we should remove it from available nids,\n\t\t * since later we will add it again.\n\t\t */\n\t\tif (!get_nat_flag(ne, IS_DIRTY) &&\n\t\t\t\tle32_to_cpu(raw_ne.block_addr) == NULL_ADDR) {\n\t\t\tspin_lock(&nm_i->nid_list_lock);\n\t\t\tnm_i->available_nids--;\n\t\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\t}\n\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t}\n\tupdate_nats_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int sanity_check_raw_super(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tblock_t segment_count, segs_per_sec, secs_per_zone, segment_count_main;\n\tblock_t total_sections, blocks_per_seg;\n\tstruct f2fs_super_block *raw_super = (struct f2fs_super_block *)\n\t\t\t\t\t(bh->b_data + F2FS_SUPER_OFFSET);\n\tunsigned int blocksize;\n\tsize_t crc_offset = 0;\n\t__u32 crc = 0;\n\n\tif (le32_to_cpu(raw_super->magic) != F2FS_SUPER_MAGIC) {\n\t\tf2fs_info(sbi, \"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\t  F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check checksum_offset and crc in superblock */\n\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_SB_CHKSUM)) {\n\t\tcrc_offset = le32_to_cpu(raw_super->checksum_offset);\n\t\tif (crc_offset !=\n\t\t\toffsetof(struct f2fs_super_block, crc)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum offset: %zu\",\n\t\t\t\t  crc_offset);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tcrc = le32_to_cpu(raw_super->crc);\n\t\tif (!f2fs_crc_valid(sbi, crc, raw_super, crc_offset)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum value: %u\", crc);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid page_cache_size (%lu), supports only 4KB\",\n\t\t\t  PAGE_SIZE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_info(sbi, \"Invalid blocksize (%u), supports only 4KB\",\n\t\t\t  blocksize);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check log blocks per segment */\n\tif (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {\n\t\tf2fs_info(sbi, \"Invalid log blocks per segment (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_blocks_per_seg));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectorsize (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tsegment_count = le32_to_cpu(raw_super->segment_count);\n\tsegment_count_main = le32_to_cpu(raw_super->segment_count_main);\n\tsegs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsecs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\ttotal_sections = le32_to_cpu(raw_super->section_count);\n\n\t/* blocks_per_seg should be 512, given the above check */\n\tblocks_per_seg = 1 << le32_to_cpu(raw_super->log_blocks_per_seg);\n\n\tif (segment_count > F2FS_MAX_SEGMENT ||\n\t\t\t\tsegment_count < F2FS_MIN_SEGMENTS) {\n\t\tf2fs_info(sbi, \"Invalid segment count (%u)\", segment_count);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (total_sections > segment_count_main || total_sections < 1 ||\n\t\t\tsegs_per_sec > segment_count || !segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u, %u x %u)\",\n\t\t\t  segment_count, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif ((segment_count / segs_per_sec) < total_sections) {\n\t\tf2fs_info(sbi, \"Small segment_count (%u < %u * %u)\",\n\t\t\t  segment_count, segs_per_sec, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count > (le64_to_cpu(raw_super->block_count) >> 9)) {\n\t\tf2fs_info(sbi, \"Wrong segment_count / block_count (%u > %llu)\",\n\t\t\t  segment_count, le64_to_cpu(raw_super->block_count));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (RDEV(0).path[0]) {\n\t\tblock_t dev_seg_count = le32_to_cpu(RDEV(0).total_segments);\n\t\tint i = 1;\n\n\t\twhile (i < MAX_DEVICES && RDEV(i).path[0]) {\n\t\t\tdev_seg_count += le32_to_cpu(RDEV(i).total_segments);\n\t\t\ti++;\n\t\t}\n\t\tif (segment_count != dev_seg_count) {\n\t\t\tf2fs_info(sbi, \"Segment count (%u) mismatch with total segments from devices (%u)\",\n\t\t\t\t\tsegment_count, dev_seg_count);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else {\n\t\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_BLKZONED) &&\n\t\t\t\t\t!bdev_is_zoned(sbi->sb->s_bdev)) {\n\t\t\tf2fs_info(sbi, \"Zoned block device path is missing\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\tif (secs_per_zone > total_sections || !secs_per_zone) {\n\t\tf2fs_info(sbi, \"Wrong secs_per_zone / total_sections (%u, %u)\",\n\t\t\t  secs_per_zone, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->extension_count) > F2FS_MAX_EXTENSION ||\n\t\t\traw_super->hot_ext_count > F2FS_MAX_EXTENSION ||\n\t\t\t(le32_to_cpu(raw_super->extension_count) +\n\t\t\traw_super->hot_ext_count) > F2FS_MAX_EXTENSION) {\n\t\tf2fs_info(sbi, \"Corrupted extension count (%u + %u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->extension_count),\n\t\t\t  raw_super->hot_ext_count,\n\t\t\t  F2FS_MAX_EXTENSION);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (le32_to_cpu(raw_super->cp_payload) >\n\t\t\t\t(blocks_per_seg - F2FS_CP_PACKS)) {\n\t\tf2fs_info(sbi, \"Insane cp_payload (%u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->cp_payload),\n\t\t\t  blocks_per_seg - F2FS_CP_PACKS);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check reserved ino info */\n\tif (le32_to_cpu(raw_super->node_ino) != 1 ||\n\t\tle32_to_cpu(raw_super->meta_ino) != 2 ||\n\t\tle32_to_cpu(raw_super->root_ino) != 3) {\n\t\tf2fs_info(sbi, \"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",\n\t\t\t  le32_to_cpu(raw_super->node_ino),\n\t\t\t  le32_to_cpu(raw_super->meta_ino),\n\t\t\t  le32_to_cpu(raw_super->root_ino));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check CP/SIT/NAT/SSA/MAIN_AREA area boundary */\n\tif (sanity_check_area_boundary(sbi, bh))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}",
                        "code_after_change": "static int sanity_check_raw_super(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tblock_t segment_count, segs_per_sec, secs_per_zone, segment_count_main;\n\tblock_t total_sections, blocks_per_seg;\n\tstruct f2fs_super_block *raw_super = (struct f2fs_super_block *)\n\t\t\t\t\t(bh->b_data + F2FS_SUPER_OFFSET);\n\tunsigned int blocksize;\n\tsize_t crc_offset = 0;\n\t__u32 crc = 0;\n\n\tif (le32_to_cpu(raw_super->magic) != F2FS_SUPER_MAGIC) {\n\t\tf2fs_info(sbi, \"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\t  F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check checksum_offset and crc in superblock */\n\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_SB_CHKSUM)) {\n\t\tcrc_offset = le32_to_cpu(raw_super->checksum_offset);\n\t\tif (crc_offset !=\n\t\t\toffsetof(struct f2fs_super_block, crc)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum offset: %zu\",\n\t\t\t\t  crc_offset);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tcrc = le32_to_cpu(raw_super->crc);\n\t\tif (!f2fs_crc_valid(sbi, crc, raw_super, crc_offset)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum value: %u\", crc);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid page_cache_size (%lu), supports only 4KB\",\n\t\t\t  PAGE_SIZE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_info(sbi, \"Invalid blocksize (%u), supports only 4KB\",\n\t\t\t  blocksize);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check log blocks per segment */\n\tif (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {\n\t\tf2fs_info(sbi, \"Invalid log blocks per segment (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_blocks_per_seg));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectorsize (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tsegment_count = le32_to_cpu(raw_super->segment_count);\n\tsegment_count_main = le32_to_cpu(raw_super->segment_count_main);\n\tsegs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsecs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\ttotal_sections = le32_to_cpu(raw_super->section_count);\n\n\t/* blocks_per_seg should be 512, given the above check */\n\tblocks_per_seg = 1 << le32_to_cpu(raw_super->log_blocks_per_seg);\n\n\tif (segment_count > F2FS_MAX_SEGMENT ||\n\t\t\t\tsegment_count < F2FS_MIN_SEGMENTS) {\n\t\tf2fs_info(sbi, \"Invalid segment count (%u)\", segment_count);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (total_sections > segment_count_main || total_sections < 1 ||\n\t\t\tsegs_per_sec > segment_count || !segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u, %u x %u)\",\n\t\t\t  segment_count, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count_main != total_sections * segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u != %u * %u)\",\n\t\t\t  segment_count_main, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif ((segment_count / segs_per_sec) < total_sections) {\n\t\tf2fs_info(sbi, \"Small segment_count (%u < %u * %u)\",\n\t\t\t  segment_count, segs_per_sec, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count > (le64_to_cpu(raw_super->block_count) >> 9)) {\n\t\tf2fs_info(sbi, \"Wrong segment_count / block_count (%u > %llu)\",\n\t\t\t  segment_count, le64_to_cpu(raw_super->block_count));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (RDEV(0).path[0]) {\n\t\tblock_t dev_seg_count = le32_to_cpu(RDEV(0).total_segments);\n\t\tint i = 1;\n\n\t\twhile (i < MAX_DEVICES && RDEV(i).path[0]) {\n\t\t\tdev_seg_count += le32_to_cpu(RDEV(i).total_segments);\n\t\t\ti++;\n\t\t}\n\t\tif (segment_count != dev_seg_count) {\n\t\t\tf2fs_info(sbi, \"Segment count (%u) mismatch with total segments from devices (%u)\",\n\t\t\t\t\tsegment_count, dev_seg_count);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else {\n\t\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_BLKZONED) &&\n\t\t\t\t\t!bdev_is_zoned(sbi->sb->s_bdev)) {\n\t\t\tf2fs_info(sbi, \"Zoned block device path is missing\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\tif (secs_per_zone > total_sections || !secs_per_zone) {\n\t\tf2fs_info(sbi, \"Wrong secs_per_zone / total_sections (%u, %u)\",\n\t\t\t  secs_per_zone, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->extension_count) > F2FS_MAX_EXTENSION ||\n\t\t\traw_super->hot_ext_count > F2FS_MAX_EXTENSION ||\n\t\t\t(le32_to_cpu(raw_super->extension_count) +\n\t\t\traw_super->hot_ext_count) > F2FS_MAX_EXTENSION) {\n\t\tf2fs_info(sbi, \"Corrupted extension count (%u + %u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->extension_count),\n\t\t\t  raw_super->hot_ext_count,\n\t\t\t  F2FS_MAX_EXTENSION);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (le32_to_cpu(raw_super->cp_payload) >\n\t\t\t\t(blocks_per_seg - F2FS_CP_PACKS)) {\n\t\tf2fs_info(sbi, \"Insane cp_payload (%u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->cp_payload),\n\t\t\t  blocks_per_seg - F2FS_CP_PACKS);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check reserved ino info */\n\tif (le32_to_cpu(raw_super->node_ino) != 1 ||\n\t\tle32_to_cpu(raw_super->meta_ino) != 2 ||\n\t\tle32_to_cpu(raw_super->root_ino) != 3) {\n\t\tf2fs_info(sbi, \"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",\n\t\t\t  le32_to_cpu(raw_super->node_ino),\n\t\t\t  le32_to_cpu(raw_super->meta_ino),\n\t\t\t  le32_to_cpu(raw_super->root_ino));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check CP/SIT/NAT/SSA/MAIN_AREA area boundary */\n\tif (sanity_check_area_boundary(sbi, bh))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2019-19449"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(journal, i));\n\n\t\traw_ne = nat_in_journal(journal, i);\n\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = __alloc_nat_entry(nid, true);\n\t\t\t__init_nat_entry(nm_i, ne, &raw_ne, true);\n\t\t}\n\n\t\t/*\n\t\t * if a free nat in journal has not been used after last\n\t\t * checkpoint, we should remove it from available nids,\n\t\t * since later we will add it again.\n\t\t */\n\t\tif (!get_nat_flag(ne, IS_DIRTY) &&\n\t\t\t\tle32_to_cpu(raw_ne.block_addr) == NULL_ADDR) {\n\t\t\tspin_lock(&nm_i->nid_list_lock);\n\t\t\tnm_i->available_nids--;\n\t\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\t}\n\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t}\n\tupdate_nats_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int sanity_check_raw_super(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tblock_t segment_count, segs_per_sec, secs_per_zone, segment_count_main;\n\tblock_t total_sections, blocks_per_seg;\n\tstruct f2fs_super_block *raw_super = (struct f2fs_super_block *)\n\t\t\t\t\t(bh->b_data + F2FS_SUPER_OFFSET);\n\tunsigned int blocksize;\n\tsize_t crc_offset = 0;\n\t__u32 crc = 0;\n\n\tif (le32_to_cpu(raw_super->magic) != F2FS_SUPER_MAGIC) {\n\t\tf2fs_info(sbi, \"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\t  F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check checksum_offset and crc in superblock */\n\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_SB_CHKSUM)) {\n\t\tcrc_offset = le32_to_cpu(raw_super->checksum_offset);\n\t\tif (crc_offset !=\n\t\t\toffsetof(struct f2fs_super_block, crc)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum offset: %zu\",\n\t\t\t\t  crc_offset);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tcrc = le32_to_cpu(raw_super->crc);\n\t\tif (!f2fs_crc_valid(sbi, crc, raw_super, crc_offset)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum value: %u\", crc);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid page_cache_size (%lu), supports only 4KB\",\n\t\t\t  PAGE_SIZE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_info(sbi, \"Invalid blocksize (%u), supports only 4KB\",\n\t\t\t  blocksize);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check log blocks per segment */\n\tif (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {\n\t\tf2fs_info(sbi, \"Invalid log blocks per segment (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_blocks_per_seg));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectorsize (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tsegment_count = le32_to_cpu(raw_super->segment_count);\n\tsegment_count_main = le32_to_cpu(raw_super->segment_count_main);\n\tsegs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsecs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\ttotal_sections = le32_to_cpu(raw_super->section_count);\n\n\t/* blocks_per_seg should be 512, given the above check */\n\tblocks_per_seg = 1 << le32_to_cpu(raw_super->log_blocks_per_seg);\n\n\tif (segment_count > F2FS_MAX_SEGMENT ||\n\t\t\t\tsegment_count < F2FS_MIN_SEGMENTS) {\n\t\tf2fs_info(sbi, \"Invalid segment count (%u)\", segment_count);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (total_sections > segment_count_main || total_sections < 1 ||\n\t\t\tsegs_per_sec > segment_count || !segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u, %u x %u)\",\n\t\t\t  segment_count, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif ((segment_count / segs_per_sec) < total_sections) {\n\t\tf2fs_info(sbi, \"Small segment_count (%u < %u * %u)\",\n\t\t\t  segment_count, segs_per_sec, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count > (le64_to_cpu(raw_super->block_count) >> 9)) {\n\t\tf2fs_info(sbi, \"Wrong segment_count / block_count (%u > %llu)\",\n\t\t\t  segment_count, le64_to_cpu(raw_super->block_count));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (RDEV(0).path[0]) {\n\t\tblock_t dev_seg_count = le32_to_cpu(RDEV(0).total_segments);\n\t\tint i = 1;\n\n\t\twhile (i < MAX_DEVICES && RDEV(i).path[0]) {\n\t\t\tdev_seg_count += le32_to_cpu(RDEV(i).total_segments);\n\t\t\ti++;\n\t\t}\n\t\tif (segment_count != dev_seg_count) {\n\t\t\tf2fs_info(sbi, \"Segment count (%u) mismatch with total segments from devices (%u)\",\n\t\t\t\t\tsegment_count, dev_seg_count);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else {\n\t\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_BLKZONED) &&\n\t\t\t\t\t!bdev_is_zoned(sbi->sb->s_bdev)) {\n\t\t\tf2fs_info(sbi, \"Zoned block device path is missing\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\tif (secs_per_zone > total_sections || !secs_per_zone) {\n\t\tf2fs_info(sbi, \"Wrong secs_per_zone / total_sections (%u, %u)\",\n\t\t\t  secs_per_zone, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->extension_count) > F2FS_MAX_EXTENSION ||\n\t\t\traw_super->hot_ext_count > F2FS_MAX_EXTENSION ||\n\t\t\t(le32_to_cpu(raw_super->extension_count) +\n\t\t\traw_super->hot_ext_count) > F2FS_MAX_EXTENSION) {\n\t\tf2fs_info(sbi, \"Corrupted extension count (%u + %u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->extension_count),\n\t\t\t  raw_super->hot_ext_count,\n\t\t\t  F2FS_MAX_EXTENSION);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (le32_to_cpu(raw_super->cp_payload) >\n\t\t\t\t(blocks_per_seg - F2FS_CP_PACKS)) {\n\t\tf2fs_info(sbi, \"Insane cp_payload (%u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->cp_payload),\n\t\t\t  blocks_per_seg - F2FS_CP_PACKS);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check reserved ino info */\n\tif (le32_to_cpu(raw_super->node_ino) != 1 ||\n\t\tle32_to_cpu(raw_super->meta_ino) != 2 ||\n\t\tle32_to_cpu(raw_super->root_ino) != 3) {\n\t\tf2fs_info(sbi, \"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",\n\t\t\t  le32_to_cpu(raw_super->node_ino),\n\t\t\t  le32_to_cpu(raw_super->meta_ino),\n\t\t\t  le32_to_cpu(raw_super->root_ino));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check CP/SIT/NAT/SSA/MAIN_AREA area boundary */\n\tif (sanity_check_area_boundary(sbi, bh))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int sanity_check_raw_super(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tblock_t segment_count, segs_per_sec, secs_per_zone, segment_count_main;\n\tblock_t total_sections, blocks_per_seg;\n\tstruct f2fs_super_block *raw_super = (struct f2fs_super_block *)\n\t\t\t\t\t(bh->b_data + F2FS_SUPER_OFFSET);\n\tunsigned int blocksize;\n\tsize_t crc_offset = 0;\n\t__u32 crc = 0;\n\n\tif (le32_to_cpu(raw_super->magic) != F2FS_SUPER_MAGIC) {\n\t\tf2fs_info(sbi, \"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\t  F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check checksum_offset and crc in superblock */\n\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_SB_CHKSUM)) {\n\t\tcrc_offset = le32_to_cpu(raw_super->checksum_offset);\n\t\tif (crc_offset !=\n\t\t\toffsetof(struct f2fs_super_block, crc)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum offset: %zu\",\n\t\t\t\t  crc_offset);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tcrc = le32_to_cpu(raw_super->crc);\n\t\tif (!f2fs_crc_valid(sbi, crc, raw_super, crc_offset)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum value: %u\", crc);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid page_cache_size (%lu), supports only 4KB\",\n\t\t\t  PAGE_SIZE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_info(sbi, \"Invalid blocksize (%u), supports only 4KB\",\n\t\t\t  blocksize);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check log blocks per segment */\n\tif (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {\n\t\tf2fs_info(sbi, \"Invalid log blocks per segment (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_blocks_per_seg));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectorsize (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tsegment_count = le32_to_cpu(raw_super->segment_count);\n\tsegment_count_main = le32_to_cpu(raw_super->segment_count_main);\n\tsegs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsecs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\ttotal_sections = le32_to_cpu(raw_super->section_count);\n\n\t/* blocks_per_seg should be 512, given the above check */\n\tblocks_per_seg = 1 << le32_to_cpu(raw_super->log_blocks_per_seg);\n\n\tif (segment_count > F2FS_MAX_SEGMENT ||\n\t\t\t\tsegment_count < F2FS_MIN_SEGMENTS) {\n\t\tf2fs_info(sbi, \"Invalid segment count (%u)\", segment_count);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (total_sections > segment_count_main || total_sections < 1 ||\n\t\t\tsegs_per_sec > segment_count || !segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u, %u x %u)\",\n\t\t\t  segment_count, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count_main != total_sections * segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u != %u * %u)\",\n\t\t\t  segment_count_main, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif ((segment_count / segs_per_sec) < total_sections) {\n\t\tf2fs_info(sbi, \"Small segment_count (%u < %u * %u)\",\n\t\t\t  segment_count, segs_per_sec, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count > (le64_to_cpu(raw_super->block_count) >> 9)) {\n\t\tf2fs_info(sbi, \"Wrong segment_count / block_count (%u > %llu)\",\n\t\t\t  segment_count, le64_to_cpu(raw_super->block_count));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (RDEV(0).path[0]) {\n\t\tblock_t dev_seg_count = le32_to_cpu(RDEV(0).total_segments);\n\t\tint i = 1;\n\n\t\twhile (i < MAX_DEVICES && RDEV(i).path[0]) {\n\t\t\tdev_seg_count += le32_to_cpu(RDEV(i).total_segments);\n\t\t\ti++;\n\t\t}\n\t\tif (segment_count != dev_seg_count) {\n\t\t\tf2fs_info(sbi, \"Segment count (%u) mismatch with total segments from devices (%u)\",\n\t\t\t\t\tsegment_count, dev_seg_count);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else {\n\t\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_BLKZONED) &&\n\t\t\t\t\t!bdev_is_zoned(sbi->sb->s_bdev)) {\n\t\t\tf2fs_info(sbi, \"Zoned block device path is missing\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\tif (secs_per_zone > total_sections || !secs_per_zone) {\n\t\tf2fs_info(sbi, \"Wrong secs_per_zone / total_sections (%u, %u)\",\n\t\t\t  secs_per_zone, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->extension_count) > F2FS_MAX_EXTENSION ||\n\t\t\traw_super->hot_ext_count > F2FS_MAX_EXTENSION ||\n\t\t\t(le32_to_cpu(raw_super->extension_count) +\n\t\t\traw_super->hot_ext_count) > F2FS_MAX_EXTENSION) {\n\t\tf2fs_info(sbi, \"Corrupted extension count (%u + %u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->extension_count),\n\t\t\t  raw_super->hot_ext_count,\n\t\t\t  F2FS_MAX_EXTENSION);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (le32_to_cpu(raw_super->cp_payload) >\n\t\t\t\t(blocks_per_seg - F2FS_CP_PACKS)) {\n\t\tf2fs_info(sbi, \"Insane cp_payload (%u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->cp_payload),\n\t\t\t  blocks_per_seg - F2FS_CP_PACKS);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check reserved ino info */\n\tif (le32_to_cpu(raw_super->node_ino) != 1 ||\n\t\tle32_to_cpu(raw_super->meta_ino) != 2 ||\n\t\tle32_to_cpu(raw_super->root_ino) != 3) {\n\t\tf2fs_info(sbi, \"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",\n\t\t\t  le32_to_cpu(raw_super->node_ino),\n\t\t\t  le32_to_cpu(raw_super->meta_ino),\n\t\t\t  le32_to_cpu(raw_super->root_ino));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check CP/SIT/NAT/SSA/MAIN_AREA area boundary */\n\tif (sanity_check_area_boundary(sbi, bh))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}",
                        "code_after_change": "static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i, NULL);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}",
                        "cve_id": "CVE-2023-37453"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(journal, i));\n\n\t\traw_ne = nat_in_journal(journal, i);\n\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = __alloc_nat_entry(nid, true);\n\t\t\t__init_nat_entry(nm_i, ne, &raw_ne, true);\n\t\t}\n\n\t\t/*\n\t\t * if a free nat in journal has not been used after last\n\t\t * checkpoint, we should remove it from available nids,\n\t\t * since later we will add it again.\n\t\t */\n\t\tif (!get_nat_flag(ne, IS_DIRTY) &&\n\t\t\t\tle32_to_cpu(raw_ne.block_addr) == NULL_ADDR) {\n\t\t\tspin_lock(&nm_i->nid_list_lock);\n\t\t\tnm_i->available_nids--;\n\t\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\t}\n\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t}\n\tupdate_nats_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i, NULL);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2422,
            "cve_id": "CVE-2020-10769",
            "code_snippet": "int crypto_authenc_extractkeys(struct crypto_authenc_keys *keys, const u8 *key,\n\t\t\t       unsigned int keylen)\n{\n\tstruct rtattr *rta = (struct rtattr *)key;\n\tstruct crypto_authenc_key_param *param;\n\n\tif (!RTA_OK(rta, keylen))\n\t\treturn -EINVAL;\n\tif (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)\n\t\treturn -EINVAL;\n\tif (RTA_PAYLOAD(rta) < sizeof(*param))\n\t\treturn -EINVAL;\n\n\tparam = RTA_DATA(rta);\n\tkeys->enckeylen = be32_to_cpu(param->enckeylen);\n\n\tkey += RTA_ALIGN(rta->rta_len);\n\tkeylen -= RTA_ALIGN(rta->rta_len);\n\n\tif (keylen < keys->enckeylen)\n\t\treturn -EINVAL;\n\n\tkeys->authkeylen = keylen - keys->enckeylen;\n\tkeys->authkey = key;\n\tkeys->enckey = key + keys->authkeylen;\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int find_first_block_group(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *key)\n{\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tint ret = 0;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.objectid >= key->objectid &&\n\t\t    found_key.type == BTRFS_BLOCK_GROUP_ITEM_KEY) {\n\t\t\tstruct extent_map_tree *em_tree;\n\t\t\tstruct extent_map *em;\n\n\t\t\tem_tree = &root->fs_info->mapping_tree.map_tree;\n\t\t\tread_lock(&em_tree->lock);\n\t\t\tem = lookup_extent_mapping(em_tree, found_key.objectid,\n\t\t\t\t\t\t   found_key.offset);\n\t\t\tread_unlock(&em_tree->lock);\n\t\t\tif (!em) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\"logical %llu len %llu found bg but no related chunk\",\n\t\t\t\t\t  found_key.objectid, found_key.offset);\n\t\t\t\tret = -ENOENT;\n\t\t\t} else {\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tfree_extent_map(em);\n\t\t\tgoto out;\n\t\t}\n\t\tpath->slots[0]++;\n\t}\nout:\n\treturn ret;\n}",
                        "code_after_change": "static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct gre_base_hdr *greh;\n\tconst struct ipv6hdr *ipv6h;\n\tint grehlen = sizeof(*greh);\n\tstruct ip6_tnl *t;\n\tint key_off = 0;\n\t__be16 flags;\n\t__be32 key;\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tflags = greh->flags;\n\tif (flags & (GRE_VERSION | GRE_ROUTING))\n\t\treturn;\n\tif (flags & GRE_CSUM)\n\t\tgrehlen += 4;\n\tif (flags & GRE_KEY) {\n\t\tkey_off = grehlen + offset;\n\t\tgrehlen += 4;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tkey = key_off ? *(__be32 *)(skb->data + key_off) : 0;\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\t key, greh->protocol);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}",
                        "cve_id": "CVE-2018-14610"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint crypto_authenc_extractkeys(struct crypto_authenc_keys *keys, const u8 *key,\n\t\t\t       unsigned int keylen)\n{\n\tstruct rtattr *rta = (struct rtattr *)key;\n\tstruct crypto_authenc_key_param *param;\n\n\tif (!RTA_OK(rta, keylen))\n\t\treturn -EINVAL;\n\tif (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)\n\t\treturn -EINVAL;\n\tif (RTA_PAYLOAD(rta) < sizeof(*param))\n\t\treturn -EINVAL;\n\n\tparam = RTA_DATA(rta);\n\tkeys->enckeylen = be32_to_cpu(param->enckeylen);\n\n\tkey += RTA_ALIGN(rta->rta_len);\n\tkeylen -= RTA_ALIGN(rta->rta_len);\n\n\tif (keylen < keys->enckeylen)\n\t\treturn -EINVAL;\n\n\tkeys->authkeylen = keylen - keys->enckeylen;\n\tkeys->authkey = key;\n\tkeys->enckey = key + keys->authkeylen;\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int find_first_block_group(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *key)\n{\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tint ret = 0;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.objectid >= key->objectid &&\n\t\t    found_key.type == BTRFS_BLOCK_GROUP_ITEM_KEY) {\n\t\t\tstruct extent_map_tree *em_tree;\n\t\t\tstruct extent_map *em;\n\n\t\t\tem_tree = &root->fs_info->mapping_tree.map_tree;\n\t\t\tread_lock(&em_tree->lock);\n\t\t\tem = lookup_extent_mapping(em_tree, found_key.objectid,\n\t\t\t\t\t\t   found_key.offset);\n\t\t\tread_unlock(&em_tree->lock);\n\t\t\tif (!em) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\"logical %llu len %llu found bg but no related chunk\",\n\t\t\t\t\t  found_key.objectid, found_key.offset);\n\t\t\t\tret = -ENOENT;\n\t\t\t} else {\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tfree_extent_map(em);\n\t\t\tgoto out;\n\t\t}\n\t\tpath->slots[0]++;\n\t}\nout:\n\treturn ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct gre_base_hdr *greh;\n\tconst struct ipv6hdr *ipv6h;\n\tint grehlen = sizeof(*greh);\n\tstruct ip6_tnl *t;\n\tint key_off = 0;\n\t__be16 flags;\n\t__be32 key;\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tflags = greh->flags;\n\tif (flags & (GRE_VERSION | GRE_ROUTING))\n\t\treturn;\n\tif (flags & GRE_CSUM)\n\t\tgrehlen += 4;\n\tif (flags & GRE_KEY) {\n\t\tkey_off = grehlen + offset;\n\t\tgrehlen += 4;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tkey = key_off ? *(__be32 *)(skb->data + key_off) : 0;\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\t key, greh->protocol);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2808,
            "cve_id": "CVE-2020-8835",
            "code_snippet": "static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,\n\t\t\t\tstruct bpf_reg_state *false_reg, u64 val,\n\t\t\t\tu8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JGT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JGT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSGT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSGT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JLT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JLT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSLT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSLT ? sval + 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\tif (is_jmp32) {\n\t\t__reg_bound_offset32(false_reg);\n\t\t__reg_bound_offset32(true_reg);\n\t}\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\tif (is_jmp32) {\n\t\t__reg_bound_offset32(false_reg);\n\t\t__reg_bound_offset32(true_reg);\n\t}\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}",
                        "code_after_change": "static void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}",
                        "cve_id": "CVE-2020-8835"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void reg_set_min_max_inv(struct bpf_reg_state *true_reg,\n\t\t\t\tstruct bpf_reg_state *false_reg, u64 val,\n\t\t\t\tu8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JGT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JGT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSGT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSGT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JLT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JLT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSLT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSLT ? sval + 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\tif (is_jmp32) {\n\t\t__reg_bound_offset32(false_reg);\n\t\t__reg_bound_offset32(true_reg);\n\t}\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\tif (is_jmp32) {\n\t\t__reg_bound_offset32(false_reg);\n\t\t__reg_bound_offset32(true_reg);\n\t}\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 589,
            "cve_id": "CVE-2014-7825",
            "code_snippet": "static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\tftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\tirq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
                        "code_after_change": "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
                        "cve_id": "CVE-2014-7825"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\tftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\tirq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2753,
            "cve_id": "CVE-2020-36386",
            "code_snippet": "static void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data;\n\t__be16 *p = (__be16 *)(skb->data + offset);\n\tint grehlen = offset + 4;\n\tstruct ip6_tnl *t;\n\t__be16 flags;\n\n\tflags = p[0];\n\tif (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {\n\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n\t\t\treturn;\n\t\tif (flags&GRE_KEY) {\n\t\t\tgrehlen += 4;\n\t\t\tif (flags&GRE_CSUM)\n\t\t\t\tgrehlen += 4;\n\t\t}\n\t}\n\n\t/* If only 8 bytes returned, keyed message will be dropped here */\n\tif (!pskb_may_pull(skb, grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tp = (__be16 *)(skb->data + offset);\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\tflags & GRE_KEY ?\n\t\t\t\t*(((__be32 *)p) + (grehlen / 4) - 1) : 0,\n\t\t\t\tp[1]);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}",
                        "code_after_change": "static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct gre_base_hdr *greh;\n\tconst struct ipv6hdr *ipv6h;\n\tint grehlen = sizeof(*greh);\n\tstruct ip6_tnl *t;\n\tint key_off = 0;\n\t__be16 flags;\n\t__be32 key;\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tflags = greh->flags;\n\tif (flags & (GRE_VERSION | GRE_ROUTING))\n\t\treturn;\n\tif (flags & GRE_CSUM)\n\t\tgrehlen += 4;\n\tif (flags & GRE_KEY) {\n\t\tkey_off = grehlen + offset;\n\t\tgrehlen += 4;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tkey = key_off ? *(__be32 *)(skb->data + key_off) : 0;\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\t key, greh->protocol);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}",
                        "cve_id": "CVE-2017-5897"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data;\n\t__be16 *p = (__be16 *)(skb->data + offset);\n\tint grehlen = offset + 4;\n\tstruct ip6_tnl *t;\n\t__be16 flags;\n\n\tflags = p[0];\n\tif (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {\n\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n\t\t\treturn;\n\t\tif (flags&GRE_KEY) {\n\t\t\tgrehlen += 4;\n\t\t\tif (flags&GRE_CSUM)\n\t\t\t\tgrehlen += 4;\n\t\t}\n\t}\n\n\t/* If only 8 bytes returned, keyed message will be dropped here */\n\tif (!pskb_may_pull(skb, grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tp = (__be16 *)(skb->data + offset);\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\tflags & GRE_KEY ?\n\t\t\t\t*(((__be32 *)p) + (grehlen / 4) - 1) : 0,\n\t\t\t\tp[1]);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct gre_base_hdr *greh;\n\tconst struct ipv6hdr *ipv6h;\n\tint grehlen = sizeof(*greh);\n\tstruct ip6_tnl *t;\n\tint key_off = 0;\n\t__be16 flags;\n\t__be32 key;\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tflags = greh->flags;\n\tif (flags & (GRE_VERSION | GRE_ROUTING))\n\t\treturn;\n\tif (flags & GRE_CSUM)\n\t\tgrehlen += 4;\n\tif (flags & GRE_KEY) {\n\t\tkey_off = grehlen + offset;\n\t\tgrehlen += 4;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tkey = key_off ? *(__be32 *)(skb->data + key_off) : 0;\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\t key, greh->protocol);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tu32 flags = 0;\n\tint err;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tattr = nla[NFTA_TABLE_NAME];\n\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tif (PTR_ERR(table) != -ENOENT)\n\t\t\treturn PTR_ERR(table);\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updtable(&ctx);\n\t}\n\n\tif (nla[NFTA_TABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\n\t\tif (flags & ~NFT_TABLE_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENOMEM;\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (table == NULL)\n\t\tgoto err_kzalloc;\n\n\ttable->name = nla_strdup(attr, GFP_KERNEL);\n\tif (table->name == NULL)\n\t\tgoto err_strdup;\n\n\tif (nla[NFTA_TABLE_USERDATA]) {\n\t\ttable->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);\n\t\tif (table->udata == NULL)\n\t\t\tgoto err_table_udata;\n\n\t\ttable->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);\n\t}\n\n\terr = rhltable_init(&table->chains_ht, &nft_chain_ht_params);\n\tif (err)\n\t\tgoto err_chain_ht;\n\n\tINIT_LIST_HEAD(&table->chains);\n\tINIT_LIST_HEAD(&table->sets);\n\tINIT_LIST_HEAD(&table->objects);\n\tINIT_LIST_HEAD(&table->flowtables);\n\ttable->family = family;\n\ttable->flags = flags;\n\ttable->handle = ++table_handle;\n\tif (table->flags & NFT_TABLE_F_OWNER)\n\t\ttable->nlpid = NETLINK_CB(skb).portid;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\terr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\tlist_add_tail_rcu(&table->list, &nft_net->tables);\n\treturn 0;\nerr_trans:\n\trhltable_destroy(&table->chains_ht);\nerr_chain_ht:\n\tkfree(table->udata);\nerr_table_udata:\n\tkfree(table->name);\nerr_strdup:\n\tkfree(table);\nerr_kzalloc:\n\treturn err;\n}",
                        "code_after_change": "static int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tu32 flags = 0;\n\tint err;\n\n\tif (!nft_supported_family(family))\n\t\treturn -EOPNOTSUPP;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tattr = nla[NFTA_TABLE_NAME];\n\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tif (PTR_ERR(table) != -ENOENT)\n\t\t\treturn PTR_ERR(table);\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updtable(&ctx);\n\t}\n\n\tif (nla[NFTA_TABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\n\t\tif (flags & ~NFT_TABLE_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENOMEM;\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (table == NULL)\n\t\tgoto err_kzalloc;\n\n\ttable->name = nla_strdup(attr, GFP_KERNEL);\n\tif (table->name == NULL)\n\t\tgoto err_strdup;\n\n\tif (nla[NFTA_TABLE_USERDATA]) {\n\t\ttable->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);\n\t\tif (table->udata == NULL)\n\t\t\tgoto err_table_udata;\n\n\t\ttable->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);\n\t}\n\n\terr = rhltable_init(&table->chains_ht, &nft_chain_ht_params);\n\tif (err)\n\t\tgoto err_chain_ht;\n\n\tINIT_LIST_HEAD(&table->chains);\n\tINIT_LIST_HEAD(&table->sets);\n\tINIT_LIST_HEAD(&table->objects);\n\tINIT_LIST_HEAD(&table->flowtables);\n\ttable->family = family;\n\ttable->flags = flags;\n\ttable->handle = ++table_handle;\n\tif (table->flags & NFT_TABLE_F_OWNER)\n\t\ttable->nlpid = NETLINK_CB(skb).portid;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\terr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\tlist_add_tail_rcu(&table->list, &nft_net->tables);\n\treturn 0;\nerr_trans:\n\trhltable_destroy(&table->chains_ht);\nerr_chain_ht:\n\tkfree(table->udata);\nerr_table_udata:\n\tkfree(table->name);\nerr_strdup:\n\tkfree(table);\nerr_kzalloc:\n\treturn err;\n}",
                        "cve_id": "CVE-2023-6040"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tu32 flags = 0;\n\tint err;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tattr = nla[NFTA_TABLE_NAME];\n\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tif (PTR_ERR(table) != -ENOENT)\n\t\t\treturn PTR_ERR(table);\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updtable(&ctx);\n\t}\n\n\tif (nla[NFTA_TABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\n\t\tif (flags & ~NFT_TABLE_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENOMEM;\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (table == NULL)\n\t\tgoto err_kzalloc;\n\n\ttable->name = nla_strdup(attr, GFP_KERNEL);\n\tif (table->name == NULL)\n\t\tgoto err_strdup;\n\n\tif (nla[NFTA_TABLE_USERDATA]) {\n\t\ttable->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);\n\t\tif (table->udata == NULL)\n\t\t\tgoto err_table_udata;\n\n\t\ttable->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);\n\t}\n\n\terr = rhltable_init(&table->chains_ht, &nft_chain_ht_params);\n\tif (err)\n\t\tgoto err_chain_ht;\n\n\tINIT_LIST_HEAD(&table->chains);\n\tINIT_LIST_HEAD(&table->sets);\n\tINIT_LIST_HEAD(&table->objects);\n\tINIT_LIST_HEAD(&table->flowtables);\n\ttable->family = family;\n\ttable->flags = flags;\n\ttable->handle = ++table_handle;\n\tif (table->flags & NFT_TABLE_F_OWNER)\n\t\ttable->nlpid = NETLINK_CB(skb).portid;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\terr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\tlist_add_tail_rcu(&table->list, &nft_net->tables);\n\treturn 0;\nerr_trans:\n\trhltable_destroy(&table->chains_ht);\nerr_chain_ht:\n\tkfree(table->udata);\nerr_table_udata:\n\tkfree(table->name);\nerr_strdup:\n\tkfree(table);\nerr_kzalloc:\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tu32 flags = 0;\n\tint err;\n\n\tif (!nft_supported_family(family))\n\t\treturn -EOPNOTSUPP;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tattr = nla[NFTA_TABLE_NAME];\n\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tif (PTR_ERR(table) != -ENOENT)\n\t\t\treturn PTR_ERR(table);\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updtable(&ctx);\n\t}\n\n\tif (nla[NFTA_TABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\n\t\tif (flags & ~NFT_TABLE_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENOMEM;\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (table == NULL)\n\t\tgoto err_kzalloc;\n\n\ttable->name = nla_strdup(attr, GFP_KERNEL);\n\tif (table->name == NULL)\n\t\tgoto err_strdup;\n\n\tif (nla[NFTA_TABLE_USERDATA]) {\n\t\ttable->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);\n\t\tif (table->udata == NULL)\n\t\t\tgoto err_table_udata;\n\n\t\ttable->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);\n\t}\n\n\terr = rhltable_init(&table->chains_ht, &nft_chain_ht_params);\n\tif (err)\n\t\tgoto err_chain_ht;\n\n\tINIT_LIST_HEAD(&table->chains);\n\tINIT_LIST_HEAD(&table->sets);\n\tINIT_LIST_HEAD(&table->objects);\n\tINIT_LIST_HEAD(&table->flowtables);\n\ttable->family = family;\n\ttable->flags = flags;\n\ttable->handle = ++table_handle;\n\tif (table->flags & NFT_TABLE_F_OWNER)\n\t\ttable->nlpid = NETLINK_CB(skb).portid;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\terr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\tlist_add_tail_rcu(&table->list, &nft_net->tables);\n\treturn 0;\nerr_trans:\n\trhltable_destroy(&table->chains_ht);\nerr_chain_ht:\n\tkfree(table->udata);\nerr_table_udata:\n\tkfree(table->name);\nerr_strdup:\n\tkfree(table);\nerr_kzalloc:\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "code_after_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "cve_id": "CVE-2019-15927"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 1784,
            "cve_id": "CVE-2018-20854",
            "code_snippet": "static int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}",
                        "code_after_change": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}",
                        "cve_id": "CVE-2018-20854"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3767,
            "cve_id": "CVE-2022-47938",
            "code_snippet": "static int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n\t\t\t\t  struct smb2_hdr *hdr)\n{\n\tint ret = 0;\n\n\t*off = 0;\n\t*len = 0;\n\n\t/* error reqeusts do not have data area */\n\tif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)hdr)->StructureSize) == SMB2_ERROR_STRUCTURE_SIZE2_LE)\n\t\treturn ret;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_TREE_CONNECT:\n\t\t*off = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathOffset);\n\t\t*len = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t{\n\t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength) {\n\t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsLength);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\t\tbreak;\n\t}\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferLength);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);\n\t\tbreak;\n\tcase SMB2_LOCK:\n\t{\n\t\tint lock_count;\n\n\t\t/*\n\t\t * smb2_lock request size is 48 included single\n\t\t * smb2_lock_element structure size.\n\t\t */\n\t\tlock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount) - 1;\n\t\tif (lock_count > 0) {\n\t\t\t*off = __SMB2_HEADER_STRUCTURE_SIZE + 48;\n\t\t\t*len = sizeof(struct smb2_lock_element) * lock_count;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputCount);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\tif (*off > 4096) {\n\t\tksmbd_debug(SMB, \"offset %d too large\\n\", *off);\n\t\tret = -EINVAL;\n\t} else if ((u64)*off + *len > MAX_STREAM_PROT_LEN) {\n\t\tksmbd_debug(SMB, \"Request is larger than maximum stream protocol length(%u): %llu\\n\",\n\t\t\t    MAX_STREAM_PROT_LEN, (u64)*off + *len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root))\n\t\t\tmemcpy(attr, a_root, asize);\n\t\telse {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}",
                        "code_after_change": "static int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root)) {\n\t\t\tmemcpy(attr, a_root, asize);\n\t\t} else {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n\t\t\t\t  struct smb2_hdr *hdr)\n{\n\tint ret = 0;\n\n\t*off = 0;\n\t*len = 0;\n\n\t/* error reqeusts do not have data area */\n\tif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)hdr)->StructureSize) == SMB2_ERROR_STRUCTURE_SIZE2_LE)\n\t\treturn ret;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_TREE_CONNECT:\n\t\t*off = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathOffset);\n\t\t*len = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t{\n\t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength) {\n\t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsLength);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\t\tbreak;\n\t}\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferLength);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);\n\t\tbreak;\n\tcase SMB2_LOCK:\n\t{\n\t\tint lock_count;\n\n\t\t/*\n\t\t * smb2_lock request size is 48 included single\n\t\t * smb2_lock_element structure size.\n\t\t */\n\t\tlock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount) - 1;\n\t\tif (lock_count > 0) {\n\t\t\t*off = __SMB2_HEADER_STRUCTURE_SIZE + 48;\n\t\t\t*len = sizeof(struct smb2_lock_element) * lock_count;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputCount);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\tif (*off > 4096) {\n\t\tksmbd_debug(SMB, \"offset %d too large\\n\", *off);\n\t\tret = -EINVAL;\n\t} else if ((u64)*off + *len > MAX_STREAM_PROT_LEN) {\n\t\tksmbd_debug(SMB, \"Request is larger than maximum stream protocol length(%u): %llu\\n\",\n\t\t\t    MAX_STREAM_PROT_LEN, (u64)*off + *len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root))\n\t\t\tmemcpy(attr, a_root, asize);\n\t\telse {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root)) {\n\t\t\tmemcpy(attr, a_root, asize);\n\t\t} else {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int smb2_write(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req;\n\tstruct smb2_write_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length;\n\tssize_t nbytes;\n\tchar *data_buf;\n\tbool writethrough = false;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe write request\\n\");\n\t\treturn smb2_write_pipe(work);\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1 ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset);\n\n\t\tif (req->Length != 0 || req->DataOffset != 0 ||\n\t\t    ch_offset < offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->WriteChannelInfoOffset,\n\t\t\t\t\t\t   req->WriteChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tksmbd_debug(SMB, \"User does not have write permission\\n\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to write : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\n\tif (length > work->conn->vals->max_write_size) {\n\t\tksmbd_debug(SMB, \"limiting write size to max size(%u)\\n\",\n\t\t\t    work->conn->vals->max_write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\twritethrough = true;\n\n\tif (req->Channel != SMB2_CHANNEL_RDMA_V1 &&\n\t    req->Channel != SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tif (le16_to_cpu(req->DataOffset) ==\n\t\t    offsetof(struct smb2_write_req, Buffer)) {\n\t\t\tdata_buf = (char *)&req->Buffer[0];\n\t\t} else {\n\t\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n\t\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n\t\t\t\t       le16_to_cpu(req->DataOffset),\n\t\t\t\t       get_rfc1002_len(work->request_buf));\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\t\tle16_to_cpu(req->DataOffset));\n\t\t}\n\n\t\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n\t\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\t\twritethrough = true;\n\n\t\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t\t    fp->filp->f_path.dentry, offset, length);\n\t\terr = ksmbd_vfs_write(work, fp, data_buf, length, &offset,\n\t\t\t\t      writethrough, &nbytes);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t/* read data from the client using rdma channel, and\n\t\t * write the data.\n\t\t */\n\t\tnbytes = smb2_write_rdma_channel(work, req, fp, offset,\n\t\t\t\t\t\t le32_to_cpu(req->RemainingBytes),\n\t\t\t\t\t\t writethrough);\n\t\tif (nbytes < 0) {\n\t\t\terr = (int)nbytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (err == -ENOSPC || err == -EFBIG)\n\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\telse if (err == -ENOENT)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (err == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (err == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (err == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}",
                        "code_after_change": "int\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len; /* calculated length */\n\t__u64 mid;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t/* decrypt frame now that it is completely read in */\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t/* For SMB2_IOCTL, OutputOffset and OutputLength are optional, so might\n\t * be 0, and not a real miscalculation */\n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Some windows servers also pad up to 8 bytes when compounding.\n\t\t */\n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t/* Only log a message if len was really miscalculated */\n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
                        "cve_id": "CVE-2022-47940"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n\t\t\t\t  struct smb2_hdr *hdr)\n{\n\tint ret = 0;\n\n\t*off = 0;\n\t*len = 0;\n\n\t/* error reqeusts do not have data area */\n\tif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)hdr)->StructureSize) == SMB2_ERROR_STRUCTURE_SIZE2_LE)\n\t\treturn ret;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_TREE_CONNECT:\n\t\t*off = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathOffset);\n\t\t*len = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t{\n\t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength) {\n\t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsLength);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\t\tbreak;\n\t}\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferLength);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);\n\t\tbreak;\n\tcase SMB2_LOCK:\n\t{\n\t\tint lock_count;\n\n\t\t/*\n\t\t * smb2_lock request size is 48 included single\n\t\t * smb2_lock_element structure size.\n\t\t */\n\t\tlock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount) - 1;\n\t\tif (lock_count > 0) {\n\t\t\t*off = __SMB2_HEADER_STRUCTURE_SIZE + 48;\n\t\t\t*len = sizeof(struct smb2_lock_element) * lock_count;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputCount);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\tif (*off > 4096) {\n\t\tksmbd_debug(SMB, \"offset %d too large\\n\", *off);\n\t\tret = -EINVAL;\n\t} else if ((u64)*off + *len > MAX_STREAM_PROT_LEN) {\n\t\tksmbd_debug(SMB, \"Request is larger than maximum stream protocol length(%u): %llu\\n\",\n\t\t\t    MAX_STREAM_PROT_LEN, (u64)*off + *len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n'''\nRelated vulnerability code snippet:\n'''\nint smb2_write(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req;\n\tstruct smb2_write_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length;\n\tssize_t nbytes;\n\tchar *data_buf;\n\tbool writethrough = false;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe write request\\n\");\n\t\treturn smb2_write_pipe(work);\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1 ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset);\n\n\t\tif (req->Length != 0 || req->DataOffset != 0 ||\n\t\t    ch_offset < offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->WriteChannelInfoOffset,\n\t\t\t\t\t\t   req->WriteChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tksmbd_debug(SMB, \"User does not have write permission\\n\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to write : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\n\tif (length > work->conn->vals->max_write_size) {\n\t\tksmbd_debug(SMB, \"limiting write size to max size(%u)\\n\",\n\t\t\t    work->conn->vals->max_write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\twritethrough = true;\n\n\tif (req->Channel != SMB2_CHANNEL_RDMA_V1 &&\n\t    req->Channel != SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tif (le16_to_cpu(req->DataOffset) ==\n\t\t    offsetof(struct smb2_write_req, Buffer)) {\n\t\t\tdata_buf = (char *)&req->Buffer[0];\n\t\t} else {\n\t\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n\t\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n\t\t\t\t       le16_to_cpu(req->DataOffset),\n\t\t\t\t       get_rfc1002_len(work->request_buf));\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\t\tle16_to_cpu(req->DataOffset));\n\t\t}\n\n\t\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n\t\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\t\twritethrough = true;\n\n\t\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t\t    fp->filp->f_path.dentry, offset, length);\n\t\terr = ksmbd_vfs_write(work, fp, data_buf, length, &offset,\n\t\t\t\t      writethrough, &nbytes);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t/* read data from the client using rdma channel, and\n\t\t * write the data.\n\t\t */\n\t\tnbytes = smb2_write_rdma_channel(work, req, fp, offset,\n\t\t\t\t\t\t le32_to_cpu(req->RemainingBytes),\n\t\t\t\t\t\t writethrough);\n\t\tif (nbytes < 0) {\n\t\t\terr = (int)nbytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (err == -ENOSPC || err == -EFBIG)\n\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\telse if (err == -ENOENT)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (err == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (err == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (err == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len; /* calculated length */\n\t__u64 mid;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t/* decrypt frame now that it is completely read in */\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t/* For SMB2_IOCTL, OutputOffset and OutputLength are optional, so might\n\t * be 0, and not a real miscalculation */\n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Some windows servers also pad up to 8 bytes when compounding.\n\t\t */\n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t/* Only log a message if len was really miscalculated */\n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3510,
            "cve_id": "CVE-2022-2905",
            "code_snippet": "static int\nrecord_func_key(struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta,\n\t\tint func_id, int insn_idx)\n{\n\tstruct bpf_insn_aux_data *aux = &env->insn_aux_data[insn_idx];\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg;\n\tstruct bpf_map *map = meta->map_ptr;\n\tstruct tnum range;\n\tu64 val;\n\tint err;\n\n\tif (func_id != BPF_FUNC_tail_call)\n\t\treturn 0;\n\tif (!map || map->map_type != BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tverbose(env, \"kernel subsystem misconfigured verifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trange = tnum_range(0, map->max_entries - 1);\n\treg = &regs[BPF_REG_3];\n\n\tif (!register_is_const(reg) || !tnum_in(range, reg->var_off)) {\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\t\treturn 0;\n\t}\n\n\terr = mark_chain_precision(env, BPF_REG_3);\n\tif (err)\n\t\treturn err;\n\n\tval = reg->var_off.value;\n\tif (bpf_map_key_unseen(aux))\n\t\tbpf_map_key_store(aux, val);\n\telse if (!bpf_map_key_poisoned(aux) &&\n\t\t  bpf_map_key_immediate(aux) != val)\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2021-3444"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int\nrecord_func_key(struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta,\n\t\tint func_id, int insn_idx)\n{\n\tstruct bpf_insn_aux_data *aux = &env->insn_aux_data[insn_idx];\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg;\n\tstruct bpf_map *map = meta->map_ptr;\n\tstruct tnum range;\n\tu64 val;\n\tint err;\n\n\tif (func_id != BPF_FUNC_tail_call)\n\t\treturn 0;\n\tif (!map || map->map_type != BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tverbose(env, \"kernel subsystem misconfigured verifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trange = tnum_range(0, map->max_entries - 1);\n\treg = &regs[BPF_REG_3];\n\n\tif (!register_is_const(reg) || !tnum_in(range, reg->var_off)) {\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\t\treturn 0;\n\t}\n\n\terr = mark_chain_precision(env, BPF_REG_3);\n\tif (err)\n\t\treturn err;\n\n\tval = reg->var_off.value;\n\tif (bpf_map_key_unseen(aux))\n\t\tbpf_map_key_store(aux, val);\n\telse if (!bpf_map_key_poisoned(aux) &&\n\t\t  bpf_map_key_immediate(aux) != val)\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}",
                        "code_after_change": "static int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}",
                        "cve_id": "CVE-2020-0430"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int\nrecord_func_key(struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta,\n\t\tint func_id, int insn_idx)\n{\n\tstruct bpf_insn_aux_data *aux = &env->insn_aux_data[insn_idx];\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg;\n\tstruct bpf_map *map = meta->map_ptr;\n\tstruct tnum range;\n\tu64 val;\n\tint err;\n\n\tif (func_id != BPF_FUNC_tail_call)\n\t\treturn 0;\n\tif (!map || map->map_type != BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tverbose(env, \"kernel subsystem misconfigured verifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trange = tnum_range(0, map->max_entries - 1);\n\treg = &regs[BPF_REG_3];\n\n\tif (!register_is_const(reg) || !tnum_in(range, reg->var_off)) {\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\t\treturn 0;\n\t}\n\n\terr = mark_chain_precision(env, BPF_REG_3);\n\tif (err)\n\t\treturn err;\n\n\tval = reg->var_off.value;\n\tif (bpf_map_key_unseen(aux))\n\t\tbpf_map_key_store(aux, val);\n\telse if (!bpf_map_key_poisoned(aux) &&\n\t\t  bpf_map_key_immediate(aux) != val)\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1349,
            "cve_id": "CVE-2017-16912",
            "code_snippet": "static int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep) {\n\t\tdev_err(&sdev->udev->dev, \"no such endpoint?, %d\\n\",\n\t\t\tepnum);\n\t\tBUG();\n\t}\n\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\n\t/* NOT REACHED */\n\tdev_err(&sdev->udev->dev, \"get pipe, epnum %d\\n\", epnum);\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "code_after_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "cve_id": "CVE-2023-37453"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep) {\n\t\tdev_err(&sdev->udev->dev, \"no such endpoint?, %d\\n\",\n\t\t\tepnum);\n\t\tBUG();\n\t}\n\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\n\t/* NOT REACHED */\n\tdev_err(&sdev->udev->dev, \"get pipe, epnum %d\\n\", epnum);\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}",
                        "code_after_change": "static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i, NULL);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}",
                        "cve_id": "CVE-2023-37453"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep) {\n\t\tdev_err(&sdev->udev->dev, \"no such endpoint?, %d\\n\",\n\t\t\tepnum);\n\t\tBUG();\n\t}\n\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\n\t/* NOT REACHED */\n\tdev_err(&sdev->udev->dev, \"get pipe, epnum %d\\n\", epnum);\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i, NULL);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tint r, alt;\n\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(&intf->altsetting[alt], eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t/*\n\t * ASMedia has a number of usb3 to sata bridge chips, at the time of\n\t * this writing the following versions exist:\n\t * ASM1051 - no uas support version\n\t * ASM1051 - with broken (*) uas support\n\t * ASM1053 - with working uas support, but problems with large xfers\n\t * ASM1153 - with working uas support\n\t *\n\t * Devices with these chips re-use a number of device-ids over the\n\t * entire line, so the device-id is useless to determine if we're\n\t * dealing with an ASM1051 (which we want to avoid).\n\t *\n\t * The ASM1153 can be identified by config.MaxPower == 0,\n\t * where as the ASM105x models have config.MaxPower == 36.\n\t *\n\t * Differentiating between the ASM1053 and ASM1051 is trickier, when\n\t * connected over USB-3 we can look at the number of streams supported,\n\t * ASM1051 supports 32 streams, where as early ASM1053 versions support\n\t * 16 streams, newer ASM1053-s also support 32 streams, but have a\n\t * different prod-id.\n\t *\n\t * (*) ASM1051 chips do work with UAS with some disks (with the\n\t *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks\n\t */\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t/* ASM1153, do nothing */\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t/* No streams info, assume ASM1051 */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t/* Possibly an ASM1051, disable uas */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t/* ASM1053, these have issues with large transfers */\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}",
                        "code_after_change": "static int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tstruct usb_host_interface *alt;\n\tint r;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (!alt)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(alt, eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t/*\n\t * ASMedia has a number of usb3 to sata bridge chips, at the time of\n\t * this writing the following versions exist:\n\t * ASM1051 - no uas support version\n\t * ASM1051 - with broken (*) uas support\n\t * ASM1053 - with working uas support, but problems with large xfers\n\t * ASM1153 - with working uas support\n\t *\n\t * Devices with these chips re-use a number of device-ids over the\n\t * entire line, so the device-id is useless to determine if we're\n\t * dealing with an ASM1051 (which we want to avoid).\n\t *\n\t * The ASM1153 can be identified by config.MaxPower == 0,\n\t * where as the ASM105x models have config.MaxPower == 36.\n\t *\n\t * Differentiating between the ASM1053 and ASM1051 is trickier, when\n\t * connected over USB-3 we can look at the number of streams supported,\n\t * ASM1051 supports 32 streams, where as early ASM1053 versions support\n\t * 16 streams, newer ASM1053-s also support 32 streams, but have a\n\t * different prod-id.\n\t *\n\t * (*) ASM1051 chips do work with UAS with some disks (with the\n\t *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks\n\t */\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t/* ASM1153, do nothing */\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t/* No streams info, assume ASM1051 */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t/* Possibly an ASM1051, disable uas */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t/* ASM1053, these have issues with large transfers */\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}",
                        "cve_id": "CVE-2017-16530"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep) {\n\t\tdev_err(&sdev->udev->dev, \"no such endpoint?, %d\\n\",\n\t\t\tepnum);\n\t\tBUG();\n\t}\n\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\n\t/* NOT REACHED */\n\tdev_err(&sdev->udev->dev, \"get pipe, epnum %d\\n\", epnum);\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tint r, alt;\n\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(&intf->altsetting[alt], eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t/*\n\t * ASMedia has a number of usb3 to sata bridge chips, at the time of\n\t * this writing the following versions exist:\n\t * ASM1051 - no uas support version\n\t * ASM1051 - with broken (*) uas support\n\t * ASM1053 - with working uas support, but problems with large xfers\n\t * ASM1153 - with working uas support\n\t *\n\t * Devices with these chips re-use a number of device-ids over the\n\t * entire line, so the device-id is useless to determine if we're\n\t * dealing with an ASM1051 (which we want to avoid).\n\t *\n\t * The ASM1153 can be identified by config.MaxPower == 0,\n\t * where as the ASM105x models have config.MaxPower == 36.\n\t *\n\t * Differentiating between the ASM1053 and ASM1051 is trickier, when\n\t * connected over USB-3 we can look at the number of streams supported,\n\t * ASM1051 supports 32 streams, where as early ASM1053 versions support\n\t * 16 streams, newer ASM1053-s also support 32 streams, but have a\n\t * different prod-id.\n\t *\n\t * (*) ASM1051 chips do work with UAS with some disks (with the\n\t *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks\n\t */\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t/* ASM1153, do nothing */\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t/* No streams info, assume ASM1051 */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t/* Possibly an ASM1051, disable uas */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t/* ASM1053, these have issues with large transfers */\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tstruct usb_host_interface *alt;\n\tint r;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (!alt)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(alt, eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t/*\n\t * ASMedia has a number of usb3 to sata bridge chips, at the time of\n\t * this writing the following versions exist:\n\t * ASM1051 - no uas support version\n\t * ASM1051 - with broken (*) uas support\n\t * ASM1053 - with working uas support, but problems with large xfers\n\t * ASM1153 - with working uas support\n\t *\n\t * Devices with these chips re-use a number of device-ids over the\n\t * entire line, so the device-id is useless to determine if we're\n\t * dealing with an ASM1051 (which we want to avoid).\n\t *\n\t * The ASM1153 can be identified by config.MaxPower == 0,\n\t * where as the ASM105x models have config.MaxPower == 36.\n\t *\n\t * Differentiating between the ASM1053 and ASM1051 is trickier, when\n\t * connected over USB-3 we can look at the number of streams supported,\n\t * ASM1051 supports 32 streams, where as early ASM1053 versions support\n\t * 16 streams, newer ASM1053-s also support 32 streams, but have a\n\t * different prod-id.\n\t *\n\t * (*) ASM1051 chips do work with UAS with some disks (with the\n\t *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks\n\t */\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t/* ASM1153, do nothing */\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t/* No streams info, assume ASM1051 */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t/* Possibly an ASM1051, disable uas */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t/* ASM1053, these have issues with large transfers */\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 3334,
            "cve_id": "CVE-2022-20132",
            "code_snippet": "static int u2fzero_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct u2fzero_device *dev;\n\tunsigned int minor;\n\tint ret;\n\n\tif (!hid_is_using_ll_driver(hdev, &usb_hid_driver))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->hw_revision = id->driver_data;\n\n\tdev->buf_out = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_report), GFP_KERNEL);\n\tif (dev->buf_out == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->buf_in = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_msg), GFP_KERNEL);\n\tif (dev->buf_in == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->hdev = hdev;\n\thid_set_drvdata(hdev, dev);\n\tmutex_init(&dev->lock);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tu2fzero_fill_in_urb(dev);\n\n\tdev->present = true;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tret = u2fzero_init_led(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s LED initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\tret = u2fzero_init_hwrng(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s RNG initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct asus_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (drvdata == NULL) {\n\t\thid_err(hdev, \"Can't alloc Asus descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, drvdata);\n\n\tdrvdata->quirks = id->driver_data;\n\n\t/*\n\t * T90CHI's keyboard dock returns same ID values as T100CHI's dock.\n\t * Thus, identify T90CHI dock with product name string.\n\t */\n\tif (strstr(hdev->name, \"T90CHI\")) {\n\t\tdrvdata->quirks &= ~QUIRK_T100CHI;\n\t\tdrvdata->quirks |= QUIRK_T90CHI;\n\t}\n\n\tif (drvdata->quirks & QUIRK_IS_MULTITOUCH)\n\t\tdrvdata->tp = &asus_i2c_tp;\n\n\tif ((drvdata->quirks & QUIRK_T100_KEYBOARD) &&\n\t    hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\t\tif (intf->altsetting->desc.bInterfaceNumber == T100_TPAD_INTF) {\n\t\t\tdrvdata->quirks = QUIRK_SKIP_INPUT_MAPPING;\n\t\t\t/*\n\t\t\t * The T100HA uses the same USB-ids as the T100TAF and\n\t\t\t * the T200TA uses the same USB-ids as the T100TA, while\n\t\t\t * both have different max x/y values as the T100TA[F].\n\t\t\t */\n\t\t\tif (dmi_match(DMI_PRODUCT_NAME, \"T100HAN\"))\n\t\t\t\tdrvdata->tp = &asus_t100ha_tp;\n\t\t\telse if (dmi_match(DMI_PRODUCT_NAME, \"T200TA\"))\n\t\t\t\tdrvdata->tp = &asus_t200ta_tp;\n\t\t\telse\n\t\t\t\tdrvdata->tp = &asus_t100ta_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_T100CHI) {\n\t\t/*\n\t\t * All functionality is on a single HID interface and for\n\t\t * userspace the touchpad must be a separate input_dev.\n\t\t */\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\tdrvdata->tp = &asus_t100chi_tp;\n\t}\n\n\tif ((drvdata->quirks & QUIRK_MEDION_E1239T) &&\n\t    hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tstruct usb_host_interface *alt =\n\t\t\tto_usb_interface(hdev->dev.parent)->altsetting;\n\n\t\tif (alt->desc.bInterfaceNumber == MEDION_E1239T_TPAD_INTF) {\n\t\t\t/* For separate input-devs for tp and tp toggle key */\n\t\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\t\tdrvdata->quirks |= QUIRK_SKIP_INPUT_MAPPING;\n\t\t\tdrvdata->tp = &medion_e1239t_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_NO_INIT_REPORTS)\n\t\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\tdrvdata->hdev = hdev;\n\n\tif (drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) {\n\t\tret = asus_battery_probe(hdev);\n\t\tif (ret) {\n\t\t\thid_err(hdev,\n\t\t\t    \"Asus hid battery_probe failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hid parse failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hw start failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!drvdata->input) {\n\t\thid_err(hdev, \"Asus input not registered\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tif (drvdata->tp) {\n\t\tdrvdata->input->name = \"Asus TouchPad\";\n\t} else {\n\t\tdrvdata->input->name = \"Asus Keyboard\";\n\t}\n\n\tif (drvdata->tp) {\n\t\tret = asus_start_multitouch(hdev);\n\t\tif (ret)\n\t\t\tgoto err_stop_hw;\n\t}\n\n\treturn 0;\nerr_stop_hw:\n\thid_hw_stop(hdev);\n\treturn ret;\n}",
                        "code_after_change": "static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct asus_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (drvdata == NULL) {\n\t\thid_err(hdev, \"Can't alloc Asus descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, drvdata);\n\n\tdrvdata->quirks = id->driver_data;\n\n\t/*\n\t * T90CHI's keyboard dock returns same ID values as T100CHI's dock.\n\t * Thus, identify T90CHI dock with product name string.\n\t */\n\tif (strstr(hdev->name, \"T90CHI\")) {\n\t\tdrvdata->quirks &= ~QUIRK_T100CHI;\n\t\tdrvdata->quirks |= QUIRK_T90CHI;\n\t}\n\n\tif (drvdata->quirks & QUIRK_IS_MULTITOUCH)\n\t\tdrvdata->tp = &asus_i2c_tp;\n\n\tif ((drvdata->quirks & QUIRK_T100_KEYBOARD) && hid_is_usb(hdev)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\t\tif (intf->altsetting->desc.bInterfaceNumber == T100_TPAD_INTF) {\n\t\t\tdrvdata->quirks = QUIRK_SKIP_INPUT_MAPPING;\n\t\t\t/*\n\t\t\t * The T100HA uses the same USB-ids as the T100TAF and\n\t\t\t * the T200TA uses the same USB-ids as the T100TA, while\n\t\t\t * both have different max x/y values as the T100TA[F].\n\t\t\t */\n\t\t\tif (dmi_match(DMI_PRODUCT_NAME, \"T100HAN\"))\n\t\t\t\tdrvdata->tp = &asus_t100ha_tp;\n\t\t\telse if (dmi_match(DMI_PRODUCT_NAME, \"T200TA\"))\n\t\t\t\tdrvdata->tp = &asus_t200ta_tp;\n\t\t\telse\n\t\t\t\tdrvdata->tp = &asus_t100ta_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_T100CHI) {\n\t\t/*\n\t\t * All functionality is on a single HID interface and for\n\t\t * userspace the touchpad must be a separate input_dev.\n\t\t */\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\tdrvdata->tp = &asus_t100chi_tp;\n\t}\n\n\tif ((drvdata->quirks & QUIRK_MEDION_E1239T) && hid_is_usb(hdev)) {\n\t\tstruct usb_host_interface *alt =\n\t\t\tto_usb_interface(hdev->dev.parent)->altsetting;\n\n\t\tif (alt->desc.bInterfaceNumber == MEDION_E1239T_TPAD_INTF) {\n\t\t\t/* For separate input-devs for tp and tp toggle key */\n\t\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\t\tdrvdata->quirks |= QUIRK_SKIP_INPUT_MAPPING;\n\t\t\tdrvdata->tp = &medion_e1239t_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_NO_INIT_REPORTS)\n\t\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\tdrvdata->hdev = hdev;\n\n\tif (drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) {\n\t\tret = asus_battery_probe(hdev);\n\t\tif (ret) {\n\t\t\thid_err(hdev,\n\t\t\t    \"Asus hid battery_probe failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hid parse failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hw start failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!drvdata->input) {\n\t\thid_err(hdev, \"Asus input not registered\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tif (drvdata->tp) {\n\t\tdrvdata->input->name = \"Asus TouchPad\";\n\t} else {\n\t\tdrvdata->input->name = \"Asus Keyboard\";\n\t}\n\n\tif (drvdata->tp) {\n\t\tret = asus_start_multitouch(hdev);\n\t\tif (ret)\n\t\t\tgoto err_stop_hw;\n\t}\n\n\treturn 0;\nerr_stop_hw:\n\thid_hw_stop(hdev);\n\treturn ret;\n}",
                        "cve_id": "CVE-2022-20132"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int u2fzero_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct u2fzero_device *dev;\n\tunsigned int minor;\n\tint ret;\n\n\tif (!hid_is_using_ll_driver(hdev, &usb_hid_driver))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->hw_revision = id->driver_data;\n\n\tdev->buf_out = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_report), GFP_KERNEL);\n\tif (dev->buf_out == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->buf_in = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_msg), GFP_KERNEL);\n\tif (dev->buf_in == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->hdev = hdev;\n\thid_set_drvdata(hdev, dev);\n\tmutex_init(&dev->lock);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tu2fzero_fill_in_urb(dev);\n\n\tdev->present = true;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tret = u2fzero_init_led(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s LED initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\tret = u2fzero_init_hwrng(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s RNG initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct asus_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (drvdata == NULL) {\n\t\thid_err(hdev, \"Can't alloc Asus descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, drvdata);\n\n\tdrvdata->quirks = id->driver_data;\n\n\t/*\n\t * T90CHI's keyboard dock returns same ID values as T100CHI's dock.\n\t * Thus, identify T90CHI dock with product name string.\n\t */\n\tif (strstr(hdev->name, \"T90CHI\")) {\n\t\tdrvdata->quirks &= ~QUIRK_T100CHI;\n\t\tdrvdata->quirks |= QUIRK_T90CHI;\n\t}\n\n\tif (drvdata->quirks & QUIRK_IS_MULTITOUCH)\n\t\tdrvdata->tp = &asus_i2c_tp;\n\n\tif ((drvdata->quirks & QUIRK_T100_KEYBOARD) &&\n\t    hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\t\tif (intf->altsetting->desc.bInterfaceNumber == T100_TPAD_INTF) {\n\t\t\tdrvdata->quirks = QUIRK_SKIP_INPUT_MAPPING;\n\t\t\t/*\n\t\t\t * The T100HA uses the same USB-ids as the T100TAF and\n\t\t\t * the T200TA uses the same USB-ids as the T100TA, while\n\t\t\t * both have different max x/y values as the T100TA[F].\n\t\t\t */\n\t\t\tif (dmi_match(DMI_PRODUCT_NAME, \"T100HAN\"))\n\t\t\t\tdrvdata->tp = &asus_t100ha_tp;\n\t\t\telse if (dmi_match(DMI_PRODUCT_NAME, \"T200TA\"))\n\t\t\t\tdrvdata->tp = &asus_t200ta_tp;\n\t\t\telse\n\t\t\t\tdrvdata->tp = &asus_t100ta_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_T100CHI) {\n\t\t/*\n\t\t * All functionality is on a single HID interface and for\n\t\t * userspace the touchpad must be a separate input_dev.\n\t\t */\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\tdrvdata->tp = &asus_t100chi_tp;\n\t}\n\n\tif ((drvdata->quirks & QUIRK_MEDION_E1239T) &&\n\t    hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tstruct usb_host_interface *alt =\n\t\t\tto_usb_interface(hdev->dev.parent)->altsetting;\n\n\t\tif (alt->desc.bInterfaceNumber == MEDION_E1239T_TPAD_INTF) {\n\t\t\t/* For separate input-devs for tp and tp toggle key */\n\t\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\t\tdrvdata->quirks |= QUIRK_SKIP_INPUT_MAPPING;\n\t\t\tdrvdata->tp = &medion_e1239t_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_NO_INIT_REPORTS)\n\t\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\tdrvdata->hdev = hdev;\n\n\tif (drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) {\n\t\tret = asus_battery_probe(hdev);\n\t\tif (ret) {\n\t\t\thid_err(hdev,\n\t\t\t    \"Asus hid battery_probe failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hid parse failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hw start failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!drvdata->input) {\n\t\thid_err(hdev, \"Asus input not registered\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tif (drvdata->tp) {\n\t\tdrvdata->input->name = \"Asus TouchPad\";\n\t} else {\n\t\tdrvdata->input->name = \"Asus Keyboard\";\n\t}\n\n\tif (drvdata->tp) {\n\t\tret = asus_start_multitouch(hdev);\n\t\tif (ret)\n\t\t\tgoto err_stop_hw;\n\t}\n\n\treturn 0;\nerr_stop_hw:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct asus_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (drvdata == NULL) {\n\t\thid_err(hdev, \"Can't alloc Asus descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, drvdata);\n\n\tdrvdata->quirks = id->driver_data;\n\n\t/*\n\t * T90CHI's keyboard dock returns same ID values as T100CHI's dock.\n\t * Thus, identify T90CHI dock with product name string.\n\t */\n\tif (strstr(hdev->name, \"T90CHI\")) {\n\t\tdrvdata->quirks &= ~QUIRK_T100CHI;\n\t\tdrvdata->quirks |= QUIRK_T90CHI;\n\t}\n\n\tif (drvdata->quirks & QUIRK_IS_MULTITOUCH)\n\t\tdrvdata->tp = &asus_i2c_tp;\n\n\tif ((drvdata->quirks & QUIRK_T100_KEYBOARD) && hid_is_usb(hdev)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\t\tif (intf->altsetting->desc.bInterfaceNumber == T100_TPAD_INTF) {\n\t\t\tdrvdata->quirks = QUIRK_SKIP_INPUT_MAPPING;\n\t\t\t/*\n\t\t\t * The T100HA uses the same USB-ids as the T100TAF and\n\t\t\t * the T200TA uses the same USB-ids as the T100TA, while\n\t\t\t * both have different max x/y values as the T100TA[F].\n\t\t\t */\n\t\t\tif (dmi_match(DMI_PRODUCT_NAME, \"T100HAN\"))\n\t\t\t\tdrvdata->tp = &asus_t100ha_tp;\n\t\t\telse if (dmi_match(DMI_PRODUCT_NAME, \"T200TA\"))\n\t\t\t\tdrvdata->tp = &asus_t200ta_tp;\n\t\t\telse\n\t\t\t\tdrvdata->tp = &asus_t100ta_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_T100CHI) {\n\t\t/*\n\t\t * All functionality is on a single HID interface and for\n\t\t * userspace the touchpad must be a separate input_dev.\n\t\t */\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\tdrvdata->tp = &asus_t100chi_tp;\n\t}\n\n\tif ((drvdata->quirks & QUIRK_MEDION_E1239T) && hid_is_usb(hdev)) {\n\t\tstruct usb_host_interface *alt =\n\t\t\tto_usb_interface(hdev->dev.parent)->altsetting;\n\n\t\tif (alt->desc.bInterfaceNumber == MEDION_E1239T_TPAD_INTF) {\n\t\t\t/* For separate input-devs for tp and tp toggle key */\n\t\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\t\tdrvdata->quirks |= QUIRK_SKIP_INPUT_MAPPING;\n\t\t\tdrvdata->tp = &medion_e1239t_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_NO_INIT_REPORTS)\n\t\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\tdrvdata->hdev = hdev;\n\n\tif (drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) {\n\t\tret = asus_battery_probe(hdev);\n\t\tif (ret) {\n\t\t\thid_err(hdev,\n\t\t\t    \"Asus hid battery_probe failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hid parse failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hw start failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!drvdata->input) {\n\t\thid_err(hdev, \"Asus input not registered\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tif (drvdata->tp) {\n\t\tdrvdata->input->name = \"Asus TouchPad\";\n\t} else {\n\t\tdrvdata->input->name = \"Asus Keyboard\";\n\t}\n\n\tif (drvdata->tp) {\n\t\tret = asus_start_multitouch(hdev);\n\t\tif (ret)\n\t\t\tgoto err_stop_hw;\n\t}\n\n\treturn 0;\nerr_stop_hw:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static void wacom_update_name(struct wacom *wacom, const char *suffix)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tchar name[WACOM_NAME_MAX - 20]; /* Leave some room for suffixes */\n\n\t/* Generic devices name unspecified */\n\tif ((features->type == HID_GENERIC) && !strcmp(\"Wacom HID\", features->name)) {\n\t\tchar *product_name = wacom->hdev->name;\n\n\t\tif (hid_is_using_ll_driver(wacom->hdev, &usb_hid_driver)) {\n\t\t\tstruct usb_interface *intf = to_usb_interface(wacom->hdev->dev.parent);\n\t\t\tstruct usb_device *dev = interface_to_usbdev(intf);\n\t\t\tproduct_name = dev->product;\n\t\t}\n\n\t\tif (wacom->hdev->bus == BUS_I2C) {\n\t\t\tsnprintf(name, sizeof(name), \"%s %X\",\n\t\t\t\t features->name, wacom->hdev->product);\n\t\t} else if (strstr(product_name, \"Wacom\") ||\n\t\t\t   strstr(product_name, \"wacom\") ||\n\t\t\t   strstr(product_name, \"WACOM\")) {\n\t\t\tstrlcpy(name, product_name, sizeof(name));\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"Wacom %s\", product_name);\n\t\t}\n\n\t\t/* strip out excess whitespaces */\n\t\twhile (1) {\n\t\t\tchar *gap = strstr(name, \"  \");\n\t\t\tif (gap == NULL)\n\t\t\t\tbreak;\n\t\t\t/* shift everything including the terminator */\n\t\t\tmemmove(gap, gap+1, strlen(gap));\n\t\t}\n\n\t\t/* get rid of trailing whitespace */\n\t\tif (name[strlen(name)-1] == ' ')\n\t\t\tname[strlen(name)-1] = '\\0';\n\t} else {\n\t\tstrlcpy(name, features->name, sizeof(name));\n\t}\n\n\tsnprintf(wacom_wac->name, sizeof(wacom_wac->name), \"%s%s\",\n\t\t name, suffix);\n\n\t/* Append the device type to the name */\n\tsnprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),\n\t\t\"%s%s Pen\", name, suffix);\n\tsnprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),\n\t\t\"%s%s Finger\", name, suffix);\n\tsnprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),\n\t\t\"%s%s Pad\", name, suffix);\n}",
                        "code_after_change": "static void wacom_update_name(struct wacom *wacom, const char *suffix)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tchar name[WACOM_NAME_MAX - 20]; /* Leave some room for suffixes */\n\n\t/* Generic devices name unspecified */\n\tif ((features->type == HID_GENERIC) && !strcmp(\"Wacom HID\", features->name)) {\n\t\tchar *product_name = wacom->hdev->name;\n\n\t\tif (hid_is_usb(wacom->hdev)) {\n\t\t\tstruct usb_interface *intf = to_usb_interface(wacom->hdev->dev.parent);\n\t\t\tstruct usb_device *dev = interface_to_usbdev(intf);\n\t\t\tproduct_name = dev->product;\n\t\t}\n\n\t\tif (wacom->hdev->bus == BUS_I2C) {\n\t\t\tsnprintf(name, sizeof(name), \"%s %X\",\n\t\t\t\t features->name, wacom->hdev->product);\n\t\t} else if (strstr(product_name, \"Wacom\") ||\n\t\t\t   strstr(product_name, \"wacom\") ||\n\t\t\t   strstr(product_name, \"WACOM\")) {\n\t\t\tstrlcpy(name, product_name, sizeof(name));\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"Wacom %s\", product_name);\n\t\t}\n\n\t\t/* strip out excess whitespaces */\n\t\twhile (1) {\n\t\t\tchar *gap = strstr(name, \"  \");\n\t\t\tif (gap == NULL)\n\t\t\t\tbreak;\n\t\t\t/* shift everything including the terminator */\n\t\t\tmemmove(gap, gap+1, strlen(gap));\n\t\t}\n\n\t\t/* get rid of trailing whitespace */\n\t\tif (name[strlen(name)-1] == ' ')\n\t\t\tname[strlen(name)-1] = '\\0';\n\t} else {\n\t\tstrlcpy(name, features->name, sizeof(name));\n\t}\n\n\tsnprintf(wacom_wac->name, sizeof(wacom_wac->name), \"%s%s\",\n\t\t name, suffix);\n\n\t/* Append the device type to the name */\n\tsnprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),\n\t\t\"%s%s Pen\", name, suffix);\n\tsnprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),\n\t\t\"%s%s Finger\", name, suffix);\n\tsnprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),\n\t\t\"%s%s Pad\", name, suffix);\n}",
                        "cve_id": "CVE-2022-20132"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int u2fzero_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct u2fzero_device *dev;\n\tunsigned int minor;\n\tint ret;\n\n\tif (!hid_is_using_ll_driver(hdev, &usb_hid_driver))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->hw_revision = id->driver_data;\n\n\tdev->buf_out = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_report), GFP_KERNEL);\n\tif (dev->buf_out == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->buf_in = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_msg), GFP_KERNEL);\n\tif (dev->buf_in == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->hdev = hdev;\n\thid_set_drvdata(hdev, dev);\n\tmutex_init(&dev->lock);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tu2fzero_fill_in_urb(dev);\n\n\tdev->present = true;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tret = u2fzero_init_led(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s LED initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\tret = u2fzero_init_hwrng(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s RNG initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void wacom_update_name(struct wacom *wacom, const char *suffix)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tchar name[WACOM_NAME_MAX - 20]; /* Leave some room for suffixes */\n\n\t/* Generic devices name unspecified */\n\tif ((features->type == HID_GENERIC) && !strcmp(\"Wacom HID\", features->name)) {\n\t\tchar *product_name = wacom->hdev->name;\n\n\t\tif (hid_is_using_ll_driver(wacom->hdev, &usb_hid_driver)) {\n\t\t\tstruct usb_interface *intf = to_usb_interface(wacom->hdev->dev.parent);\n\t\t\tstruct usb_device *dev = interface_to_usbdev(intf);\n\t\t\tproduct_name = dev->product;\n\t\t}\n\n\t\tif (wacom->hdev->bus == BUS_I2C) {\n\t\t\tsnprintf(name, sizeof(name), \"%s %X\",\n\t\t\t\t features->name, wacom->hdev->product);\n\t\t} else if (strstr(product_name, \"Wacom\") ||\n\t\t\t   strstr(product_name, \"wacom\") ||\n\t\t\t   strstr(product_name, \"WACOM\")) {\n\t\t\tstrlcpy(name, product_name, sizeof(name));\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"Wacom %s\", product_name);\n\t\t}\n\n\t\t/* strip out excess whitespaces */\n\t\twhile (1) {\n\t\t\tchar *gap = strstr(name, \"  \");\n\t\t\tif (gap == NULL)\n\t\t\t\tbreak;\n\t\t\t/* shift everything including the terminator */\n\t\t\tmemmove(gap, gap+1, strlen(gap));\n\t\t}\n\n\t\t/* get rid of trailing whitespace */\n\t\tif (name[strlen(name)-1] == ' ')\n\t\t\tname[strlen(name)-1] = '\\0';\n\t} else {\n\t\tstrlcpy(name, features->name, sizeof(name));\n\t}\n\n\tsnprintf(wacom_wac->name, sizeof(wacom_wac->name), \"%s%s\",\n\t\t name, suffix);\n\n\t/* Append the device type to the name */\n\tsnprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),\n\t\t\"%s%s Pen\", name, suffix);\n\tsnprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),\n\t\t\"%s%s Finger\", name, suffix);\n\tsnprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),\n\t\t\"%s%s Pad\", name, suffix);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void wacom_update_name(struct wacom *wacom, const char *suffix)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tchar name[WACOM_NAME_MAX - 20]; /* Leave some room for suffixes */\n\n\t/* Generic devices name unspecified */\n\tif ((features->type == HID_GENERIC) && !strcmp(\"Wacom HID\", features->name)) {\n\t\tchar *product_name = wacom->hdev->name;\n\n\t\tif (hid_is_usb(wacom->hdev)) {\n\t\t\tstruct usb_interface *intf = to_usb_interface(wacom->hdev->dev.parent);\n\t\t\tstruct usb_device *dev = interface_to_usbdev(intf);\n\t\t\tproduct_name = dev->product;\n\t\t}\n\n\t\tif (wacom->hdev->bus == BUS_I2C) {\n\t\t\tsnprintf(name, sizeof(name), \"%s %X\",\n\t\t\t\t features->name, wacom->hdev->product);\n\t\t} else if (strstr(product_name, \"Wacom\") ||\n\t\t\t   strstr(product_name, \"wacom\") ||\n\t\t\t   strstr(product_name, \"WACOM\")) {\n\t\t\tstrlcpy(name, product_name, sizeof(name));\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"Wacom %s\", product_name);\n\t\t}\n\n\t\t/* strip out excess whitespaces */\n\t\twhile (1) {\n\t\t\tchar *gap = strstr(name, \"  \");\n\t\t\tif (gap == NULL)\n\t\t\t\tbreak;\n\t\t\t/* shift everything including the terminator */\n\t\t\tmemmove(gap, gap+1, strlen(gap));\n\t\t}\n\n\t\t/* get rid of trailing whitespace */\n\t\tif (name[strlen(name)-1] == ' ')\n\t\t\tname[strlen(name)-1] = '\\0';\n\t} else {\n\t\tstrlcpy(name, features->name, sizeof(name));\n\t}\n\n\tsnprintf(wacom_wac->name, sizeof(wacom_wac->name), \"%s%s\",\n\t\t name, suffix);\n\n\t/* Append the device type to the name */\n\tsnprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),\n\t\t\"%s%s Pen\", name, suffix);\n\tsnprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),\n\t\t\"%s%s Finger\", name, suffix);\n\tsnprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),\n\t\t\"%s%s Pad\", name, suffix);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct dj_receiver_dev *djrcv_dev;\n\tstruct usb_interface *intf;\n\tunsigned int no_dj_interfaces = 0;\n\tbool has_hidpp = false;\n\tunsigned long flags;\n\tint retval;\n\n\t/*\n\t * Call to usbhid to fetch the HID descriptors of the current\n\t * interface subsequently call to the hid/hid-core to parse the\n\t * fetched descriptors.\n\t */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: parse failed\\n\", __func__);\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Some KVMs add an extra interface for e.g. mouse emulation. If we\n\t * treat these as logitech-dj interfaces then this causes input events\n\t * reported through this extra interface to not be reported correctly.\n\t * To avoid this, we treat these as generic-hid devices.\n\t */\n\tswitch (id->driver_data) {\n\tcase recvr_type_dj:\t\tno_dj_interfaces = 3; break;\n\tcase recvr_type_hidpp:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_gaming_hidpp:\tno_dj_interfaces = 3; break;\n\tcase recvr_type_mouse_only:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_27mhz:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_bluetooth:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_dinovo:\t\tno_dj_interfaces = 2; break;\n\t}\n\tif (hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tintf = to_usb_interface(hdev->dev.parent);\n\t\tif (intf && intf->altsetting->desc.bInterfaceNumber >=\n\t\t\t\t\t\t\tno_dj_interfaces) {\n\t\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\t\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t}\n\n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\n\t/* no input reports, bail out */\n\tif (list_empty(&rep_enum->report_list))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check for the HID++ application.\n\t * Note: we should theoretically check for HID++ and DJ\n\t * collections, but this will do.\n\t */\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xff000001)\n\t\t\thas_hidpp = true;\n\t}\n\n\t/*\n\t * Ignore interfaces without DJ/HID++ collection, they will not carry\n\t * any data, dont create any hid_device for them.\n\t */\n\tif (!has_hidpp && id->driver_data == recvr_type_dj)\n\t\treturn -ENODEV;\n\n\t/* get the current application attached to the node */\n\trep = list_first_entry(&rep_enum->report_list, struct hid_report, list);\n\tdjrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,\n\t\t\t\t\trep->application, has_hidpp);\n\tif (!djrcv_dev) {\n\t\thid_err(hdev, \"%s: dj_get_receiver_dev failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!rep_enum->numbered)\n\t\tdjrcv_dev->unnumbered_application = rep->application;\n\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tif (has_hidpp) {\n\t\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto switch_to_dj_mode_fail;\n\t\t}\n\t}\n\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\thid_err(hdev, \"%s: hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\n\tif (has_hidpp) {\n\t\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\t\tdjrcv_dev->ready = true;\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_query_paired_devices error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\t/*\n\t\t\t * This can happen with a KVM, let the probe succeed,\n\t\t\t * logi_dj_recv_queue_unknown_work will retry later.\n\t\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\n\tdj_put_receiver_dev(hdev);\n\treturn retval;\n}",
                        "code_after_change": "static int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct dj_receiver_dev *djrcv_dev;\n\tstruct usb_interface *intf;\n\tunsigned int no_dj_interfaces = 0;\n\tbool has_hidpp = false;\n\tunsigned long flags;\n\tint retval;\n\n\t/*\n\t * Call to usbhid to fetch the HID descriptors of the current\n\t * interface subsequently call to the hid/hid-core to parse the\n\t * fetched descriptors.\n\t */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: parse failed\\n\", __func__);\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Some KVMs add an extra interface for e.g. mouse emulation. If we\n\t * treat these as logitech-dj interfaces then this causes input events\n\t * reported through this extra interface to not be reported correctly.\n\t * To avoid this, we treat these as generic-hid devices.\n\t */\n\tswitch (id->driver_data) {\n\tcase recvr_type_dj:\t\tno_dj_interfaces = 3; break;\n\tcase recvr_type_hidpp:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_gaming_hidpp:\tno_dj_interfaces = 3; break;\n\tcase recvr_type_mouse_only:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_27mhz:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_bluetooth:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_dinovo:\t\tno_dj_interfaces = 2; break;\n\t}\n\tif (hid_is_usb(hdev)) {\n\t\tintf = to_usb_interface(hdev->dev.parent);\n\t\tif (intf && intf->altsetting->desc.bInterfaceNumber >=\n\t\t\t\t\t\t\tno_dj_interfaces) {\n\t\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\t\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t}\n\n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\n\t/* no input reports, bail out */\n\tif (list_empty(&rep_enum->report_list))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check for the HID++ application.\n\t * Note: we should theoretically check for HID++ and DJ\n\t * collections, but this will do.\n\t */\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xff000001)\n\t\t\thas_hidpp = true;\n\t}\n\n\t/*\n\t * Ignore interfaces without DJ/HID++ collection, they will not carry\n\t * any data, dont create any hid_device for them.\n\t */\n\tif (!has_hidpp && id->driver_data == recvr_type_dj)\n\t\treturn -ENODEV;\n\n\t/* get the current application attached to the node */\n\trep = list_first_entry(&rep_enum->report_list, struct hid_report, list);\n\tdjrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,\n\t\t\t\t\trep->application, has_hidpp);\n\tif (!djrcv_dev) {\n\t\thid_err(hdev, \"%s: dj_get_receiver_dev failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!rep_enum->numbered)\n\t\tdjrcv_dev->unnumbered_application = rep->application;\n\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tif (has_hidpp) {\n\t\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto switch_to_dj_mode_fail;\n\t\t}\n\t}\n\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\thid_err(hdev, \"%s: hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\n\tif (has_hidpp) {\n\t\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\t\tdjrcv_dev->ready = true;\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_query_paired_devices error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\t/*\n\t\t\t * This can happen with a KVM, let the probe succeed,\n\t\t\t * logi_dj_recv_queue_unknown_work will retry later.\n\t\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\n\tdj_put_receiver_dev(hdev);\n\treturn retval;\n}",
                        "cve_id": "CVE-2022-20132"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int u2fzero_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct u2fzero_device *dev;\n\tunsigned int minor;\n\tint ret;\n\n\tif (!hid_is_using_ll_driver(hdev, &usb_hid_driver))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->hw_revision = id->driver_data;\n\n\tdev->buf_out = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_report), GFP_KERNEL);\n\tif (dev->buf_out == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->buf_in = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_msg), GFP_KERNEL);\n\tif (dev->buf_in == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->hdev = hdev;\n\thid_set_drvdata(hdev, dev);\n\tmutex_init(&dev->lock);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tu2fzero_fill_in_urb(dev);\n\n\tdev->present = true;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tret = u2fzero_init_led(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s LED initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\tret = u2fzero_init_hwrng(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s RNG initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct dj_receiver_dev *djrcv_dev;\n\tstruct usb_interface *intf;\n\tunsigned int no_dj_interfaces = 0;\n\tbool has_hidpp = false;\n\tunsigned long flags;\n\tint retval;\n\n\t/*\n\t * Call to usbhid to fetch the HID descriptors of the current\n\t * interface subsequently call to the hid/hid-core to parse the\n\t * fetched descriptors.\n\t */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: parse failed\\n\", __func__);\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Some KVMs add an extra interface for e.g. mouse emulation. If we\n\t * treat these as logitech-dj interfaces then this causes input events\n\t * reported through this extra interface to not be reported correctly.\n\t * To avoid this, we treat these as generic-hid devices.\n\t */\n\tswitch (id->driver_data) {\n\tcase recvr_type_dj:\t\tno_dj_interfaces = 3; break;\n\tcase recvr_type_hidpp:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_gaming_hidpp:\tno_dj_interfaces = 3; break;\n\tcase recvr_type_mouse_only:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_27mhz:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_bluetooth:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_dinovo:\t\tno_dj_interfaces = 2; break;\n\t}\n\tif (hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tintf = to_usb_interface(hdev->dev.parent);\n\t\tif (intf && intf->altsetting->desc.bInterfaceNumber >=\n\t\t\t\t\t\t\tno_dj_interfaces) {\n\t\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\t\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t}\n\n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\n\t/* no input reports, bail out */\n\tif (list_empty(&rep_enum->report_list))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check for the HID++ application.\n\t * Note: we should theoretically check for HID++ and DJ\n\t * collections, but this will do.\n\t */\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xff000001)\n\t\t\thas_hidpp = true;\n\t}\n\n\t/*\n\t * Ignore interfaces without DJ/HID++ collection, they will not carry\n\t * any data, dont create any hid_device for them.\n\t */\n\tif (!has_hidpp && id->driver_data == recvr_type_dj)\n\t\treturn -ENODEV;\n\n\t/* get the current application attached to the node */\n\trep = list_first_entry(&rep_enum->report_list, struct hid_report, list);\n\tdjrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,\n\t\t\t\t\trep->application, has_hidpp);\n\tif (!djrcv_dev) {\n\t\thid_err(hdev, \"%s: dj_get_receiver_dev failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!rep_enum->numbered)\n\t\tdjrcv_dev->unnumbered_application = rep->application;\n\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tif (has_hidpp) {\n\t\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto switch_to_dj_mode_fail;\n\t\t}\n\t}\n\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\thid_err(hdev, \"%s: hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\n\tif (has_hidpp) {\n\t\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\t\tdjrcv_dev->ready = true;\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_query_paired_devices error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\t/*\n\t\t\t * This can happen with a KVM, let the probe succeed,\n\t\t\t * logi_dj_recv_queue_unknown_work will retry later.\n\t\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\n\tdj_put_receiver_dev(hdev);\n\treturn retval;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct dj_receiver_dev *djrcv_dev;\n\tstruct usb_interface *intf;\n\tunsigned int no_dj_interfaces = 0;\n\tbool has_hidpp = false;\n\tunsigned long flags;\n\tint retval;\n\n\t/*\n\t * Call to usbhid to fetch the HID descriptors of the current\n\t * interface subsequently call to the hid/hid-core to parse the\n\t * fetched descriptors.\n\t */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: parse failed\\n\", __func__);\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Some KVMs add an extra interface for e.g. mouse emulation. If we\n\t * treat these as logitech-dj interfaces then this causes input events\n\t * reported through this extra interface to not be reported correctly.\n\t * To avoid this, we treat these as generic-hid devices.\n\t */\n\tswitch (id->driver_data) {\n\tcase recvr_type_dj:\t\tno_dj_interfaces = 3; break;\n\tcase recvr_type_hidpp:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_gaming_hidpp:\tno_dj_interfaces = 3; break;\n\tcase recvr_type_mouse_only:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_27mhz:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_bluetooth:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_dinovo:\t\tno_dj_interfaces = 2; break;\n\t}\n\tif (hid_is_usb(hdev)) {\n\t\tintf = to_usb_interface(hdev->dev.parent);\n\t\tif (intf && intf->altsetting->desc.bInterfaceNumber >=\n\t\t\t\t\t\t\tno_dj_interfaces) {\n\t\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\t\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t}\n\n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\n\t/* no input reports, bail out */\n\tif (list_empty(&rep_enum->report_list))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check for the HID++ application.\n\t * Note: we should theoretically check for HID++ and DJ\n\t * collections, but this will do.\n\t */\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xff000001)\n\t\t\thas_hidpp = true;\n\t}\n\n\t/*\n\t * Ignore interfaces without DJ/HID++ collection, they will not carry\n\t * any data, dont create any hid_device for them.\n\t */\n\tif (!has_hidpp && id->driver_data == recvr_type_dj)\n\t\treturn -ENODEV;\n\n\t/* get the current application attached to the node */\n\trep = list_first_entry(&rep_enum->report_list, struct hid_report, list);\n\tdjrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,\n\t\t\t\t\trep->application, has_hidpp);\n\tif (!djrcv_dev) {\n\t\thid_err(hdev, \"%s: dj_get_receiver_dev failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!rep_enum->numbered)\n\t\tdjrcv_dev->unnumbered_application = rep->application;\n\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tif (has_hidpp) {\n\t\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto switch_to_dj_mode_fail;\n\t\t}\n\t}\n\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\thid_err(hdev, \"%s: hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\n\tif (has_hidpp) {\n\t\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\t\tdjrcv_dev->ready = true;\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_query_paired_devices error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\t/*\n\t\t\t * This can happen with a KVM, let the probe succeed,\n\t\t\t * logi_dj_recv_queue_unknown_work will retry later.\n\t\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\n\tdj_put_receiver_dev(hdev);\n\treturn retval;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2660,
            "cve_id": "CVE-2020-28915",
            "code_snippet": "static int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "code_after_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "cve_id": "CVE-2023-37453"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}",
                        "code_after_change": "static ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tif (use_unicode(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}",
                        "cve_id": "CVE-2019-19252"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tif (use_unicode(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "code_after_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "cve_id": "CVE-2016-10208"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 1276,
            "cve_id": "CVE-2017-13305",
            "code_snippet": "static int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tif (!memcmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_TRUSTED_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_TRUSTED_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else if (!memcmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_USER_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_USER_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\treturn 0;\nout:\n\treturn -EINVAL;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tif (!memcmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_TRUSTED_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_TRUSTED_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else if (!memcmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_USER_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_USER_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\treturn 0;\nout:\n\treturn -EINVAL;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off)) {\n\t\tstruct EA_FULL *ea;\n\t\tsize_t ea_sz;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tea_sz = unpacked_ea_size(ea);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}",
                        "code_after_change": "static noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tif (!memcmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_TRUSTED_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_TRUSTED_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else if (!memcmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_USER_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_USER_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\treturn 0;\nout:\n\treturn -EINVAL;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off)) {\n\t\tstruct EA_FULL *ea;\n\t\tsize_t ea_sz;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tea_sz = unpacked_ea_size(ea);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry = NULL;\n\tint error = 0;\n\tunsigned int size, len;\n\tvoid *base_addr = NULL;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = lookup_all_xattrs(inode, ipage, index, len, name,\n\t\t\t\t&entry, &base_addr);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\nout:\n\tkzfree(base_addr);\n\treturn error;\n}",
                        "code_after_change": "int f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry = NULL;\n\tint error = 0;\n\tunsigned int size, len;\n\tvoid *base_addr = NULL;\n\tint base_size;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = lookup_all_xattrs(inode, ipage, index, len, name,\n\t\t\t\t&entry, &base_addr, &base_size);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\n\t\tif (base_size - (pval - (char *)base_addr) < size) {\n\t\t\terror = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\nout:\n\tkzfree(base_addr);\n\treturn error;\n}",
                        "cve_id": "CVE-2019-9245"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tif (!memcmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_TRUSTED_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_TRUSTED_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else if (!memcmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_USER_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_USER_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\treturn 0;\nout:\n\treturn -EINVAL;\n}\n'''\nRelated vulnerability code snippet:\n'''\nint f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry = NULL;\n\tint error = 0;\n\tunsigned int size, len;\n\tvoid *base_addr = NULL;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = lookup_all_xattrs(inode, ipage, index, len, name,\n\t\t\t\t&entry, &base_addr);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\nout:\n\tkzfree(base_addr);\n\treturn error;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry = NULL;\n\tint error = 0;\n\tunsigned int size, len;\n\tvoid *base_addr = NULL;\n\tint base_size;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = lookup_all_xattrs(inode, ipage, index, len, name,\n\t\t\t\t&entry, &base_addr, &base_size);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\n\t\tif (base_size - (pval - (char *)base_addr) < size) {\n\t\t\terror = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\nout:\n\tkzfree(base_addr);\n\treturn error;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        }
    ],
    "non_vul_data": [
        {
            "id": 1626,
            "cve_id": "CVE-2018-1093",
            "code_snippet": "static struct buffer_head *\next4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tbitmap_blk = ext4_inode_bitmap(sb, desc);\n\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n\t\text4_error(sb, \"Invalid inode bitmap blk %llu in \"\n\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t    block_group, bitmap_blk);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\tmemset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\ttrace_ext4_load_inode_bitmap(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\tput_bh(bh);\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t   \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\nverify:\n\terr = ext4_validate_inode_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}",
                        "code_after_change": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group) >= sb->s_blocksize)\n\t\treturn blk;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}",
                        "cve_id": "CVE-2018-1093"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic struct buffer_head *\next4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tbitmap_blk = ext4_inode_bitmap(sb, desc);\n\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n\t\text4_error(sb, \"Invalid inode bitmap blk %llu in \"\n\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t    block_group, bitmap_blk);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\tmemset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\ttrace_ext4_load_inode_bitmap(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\tput_bh(bh);\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t   \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\nverify:\n\terr = ext4_validate_inode_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group) >= sb->s_blocksize)\n\t\treturn blk;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1625,
            "cve_id": "CVE-2018-1093",
            "code_snippet": "struct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n\t\text4_error(sb, \"Invalid block bitmap block %llu in \"\n\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Failed to init block bitmap for group \"\n\t\t\t\t   \"%u: %d\", block_group, err);\n\t\t\tgoto out;\n\t\t}\n\t\tgoto verify;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\terr = ext4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}",
                        "code_after_change": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group) >= sb->s_blocksize)\n\t\treturn blk;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}",
                        "cve_id": "CVE-2018-1093"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstruct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n\t\text4_error(sb, \"Invalid block bitmap block %llu in \"\n\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Failed to init block bitmap for group \"\n\t\t\t\t   \"%u: %d\", block_group, err);\n\t\t\tgoto out;\n\t\t}\n\t\tgoto verify;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\terr = ext4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group) >= sb->s_blocksize)\n\t\treturn blk;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 4306,
            "cve_id": "CVE-2023-6610",
            "code_snippet": "static void\nsmb2_dump_detail(void *buf, struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\n\tcifs_server_dbg(VFS, \"Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\\n\",\n\t\t shdr->Command, shdr->Status, shdr->Flags, shdr->MessageId,\n\t\t shdr->Id.SyncId.ProcessId);\n\tif (!server->ops->check_message(buf, server->total_read, server)) {\n\t\tcifs_server_dbg(VFS, \"smb buf %p len %u\\n\", buf,\n\t\t\t\tserver->ops->calc_smb_size(buf));\n\t}\n#endif\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len; /* calculated length */\n\t__u64 mid;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t/* decrypt frame now that it is completely read in */\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t/* For SMB2_IOCTL, OutputOffset and OutputLength are optional, so might\n\t * be 0, and not a real miscalculation */\n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Some windows servers also pad up to 8 bytes when compounding.\n\t\t */\n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t/* Only log a message if len was really miscalculated */\n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
                        "code_after_change": "int\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len; /* calculated length */\n\t__u64 mid;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t/* decrypt frame now that it is completely read in */\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t/* For SMB2_IOCTL, OutputOffset and OutputLength are optional, so might\n\t * be 0, and not a real miscalculation */\n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Some windows servers also pad up to 8 bytes when compounding.\n\t\t */\n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t/* Only log a message if len was really miscalculated */\n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
                        "cve_id": "CVE-2023-6610"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void\nsmb2_dump_detail(void *buf, struct TCP_Server_Info *server)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\n\tcifs_server_dbg(VFS, \"Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\\n\",\n\t\t shdr->Command, shdr->Status, shdr->Flags, shdr->MessageId,\n\t\t shdr->Id.SyncId.ProcessId);\n\tif (!server->ops->check_message(buf, server->total_read, server)) {\n\t\tcifs_server_dbg(VFS, \"smb buf %p len %u\\n\", buf,\n\t\t\t\tserver->ops->calc_smb_size(buf));\n\t}\n#endif\n}\n'''\nRelated vulnerability code snippet:\n'''\nint\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len; /* calculated length */\n\t__u64 mid;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t/* decrypt frame now that it is completely read in */\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t/* For SMB2_IOCTL, OutputOffset and OutputLength are optional, so might\n\t * be 0, and not a real miscalculation */\n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Some windows servers also pad up to 8 bytes when compounding.\n\t\t */\n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t/* Only log a message if len was really miscalculated */\n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint\nsmb2_check_message(char *buf, unsigned int len, struct TCP_Server_Info *server)\n{\n\tstruct TCP_Server_Info *pserver;\n\tstruct smb2_hdr *shdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)shdr;\n\tint hdr_size = sizeof(struct smb2_hdr);\n\tint pdu_size = sizeof(struct smb2_pdu);\n\tint command;\n\t__u32 calc_len; /* calculated length */\n\t__u64 mid;\n\n\t/* If server is a channel, select the primary channel */\n\tpserver = SERVER_IS_CHAN(server) ? server->primary_server : server;\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\tif (shdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\n\t\tstruct smb2_transform_hdr *thdr =\n\t\t\t(struct smb2_transform_hdr *)buf;\n\t\tstruct cifs_ses *ses = NULL;\n\t\tstruct cifs_ses *iter;\n\n\t\t/* decrypt frame now that it is completely read in */\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tlist_for_each_entry(iter, &pserver->smb_ses_list, smb_ses_list) {\n\t\t\tif (iter->Suid == le64_to_cpu(thdr->SessionId)) {\n\t\t\t\tses = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tif (!ses) {\n\t\t\tcifs_dbg(VFS, \"no decryption - session id not found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tmid = le64_to_cpu(shdr->MessageId);\n\tif (check_smb2_hdr(shdr, mid))\n\t\treturn 1;\n\n\tif (shdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Invalid structure size %u\\n\",\n\t\t\t le16_to_cpu(shdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(shdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Invalid SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (len < pdu_size) {\n\t\tif ((len >= hdr_size)\n\t\t    && (shdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (shdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE\n\t\t\t   && (shdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Invalid response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcalc_len = smb2_calc_size(buf);\n\n\t/* For SMB2_IOCTL, OutputOffset and OutputLength are optional, so might\n\t * be 0, and not a real miscalculation */\n\tif (command == SMB2_IOCTL_HE && calc_len == 0)\n\t\treturn 0;\n\n\tif (command == SMB2_NEGOTIATE_HE)\n\t\tcalc_len += get_neg_ctxt_len(shdr, len, calc_len);\n\n\tif (len != calc_len) {\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    shdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (calc_len + 24 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (calc_len == len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(calc_len, 8) == len)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Some windows servers also pad up to 8 bytes when compounding.\n\t\t */\n\t\tif (calc_len < len)\n\t\t\treturn 0;\n\n\t\t/* Only log a message if len was really miscalculated */\n\t\tif (unlikely(cifsFYI))\n\t\t\tcifs_dbg(FYI, \"Server response too short: calculated \"\n\t\t\t\t \"length %u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\t calc_len, len, command, mid);\n\t\telse\n\t\t\tpr_warn(\"Server response too short: calculated length \"\n\t\t\t\t\"%u doesn't match read length %u (cmd=%d, mid=%llu)\\n\",\n\t\t\t\tcalc_len, len, command, mid);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 776,
            "cve_id": "CVE-2015-5327",
            "code_snippet": "int x509_decode_time(time64_t *_t,  size_t hdrlen,\n\t\t     unsigned char tag,\n\t\t     const unsigned char *value, size_t vlen)\n{\n\tstatic const unsigned char month_lengths[] = { 31, 29, 31, 30, 31, 30,\n\t\t\t\t\t\t       31, 31, 30, 31, 30, 31 };\n\tconst unsigned char *p = value;\n\tunsigned year, mon, day, hour, min, sec, mon_len;\n\n#define dec2bin(X) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })\n#define DD2bin(P) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })\n\n\tif (tag == ASN1_UNITIM) {\n\t\t/* UTCTime: YYMMDDHHMMSSZ */\n\t\tif (vlen != 13)\n\t\t\tgoto unsupported_time;\n\t\tyear = DD2bin(p);\n\t\tif (year >= 50)\n\t\t\tyear += 1900;\n\t\telse\n\t\t\tyear += 2000;\n\t} else if (tag == ASN1_GENTIM) {\n\t\t/* GenTime: YYYYMMDDHHMMSSZ */\n\t\tif (vlen != 15)\n\t\t\tgoto unsupported_time;\n\t\tyear = DD2bin(p) * 100 + DD2bin(p);\n\t\tif (year >= 1950 && year <= 2049)\n\t\t\tgoto invalid_time;\n\t} else {\n\t\tgoto unsupported_time;\n\t}\n\n\tmon  = DD2bin(p);\n\tday = DD2bin(p);\n\thour = DD2bin(p);\n\tmin  = DD2bin(p);\n\tsec  = DD2bin(p);\n\n\tif (*p != 'Z')\n\t\tgoto unsupported_time;\n\n\tif (year < 1970 ||\n\t    mon < 1 || mon > 12)\n\t\tgoto invalid_time;\n\n\tmon_len = month_lengths[mon - 1];\n\tif (mon == 2) {\n\t\tif (year % 4 == 0) {\n\t\t\tmon_len = 29;\n\t\t\tif (year % 100 == 0) {\n\t\t\t\tyear /= 100;\n\t\t\t\tif (year % 4 != 0)\n\t\t\t\t\tmon_len = 28;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (day < 1 || day > mon_len ||\n\t    hour > 23 ||\n\t    min > 59 ||\n\t    sec > 59)\n\t\tgoto invalid_time;\n\n\t*_t = mktime64(year, mon, day, hour, min, sec);\n\treturn 0;\n\nunsupported_time:\n\tpr_debug(\"Got unsupported time [tag %02x]: '%*phN'\\n\",\n\t\t tag, (int)vlen, value);\n\treturn -EBADMSG;\ninvalid_time:\n\tpr_debug(\"Got invalid time [tag %02x]: '%*phN'\\n\",\n\t\t tag, (int)vlen, value);\n\treturn -EBADMSG;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}",
                        "code_after_change": "static ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tif (use_unicode(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}",
                        "cve_id": "CVE-2019-19252"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint x509_decode_time(time64_t *_t,  size_t hdrlen,\n\t\t     unsigned char tag,\n\t\t     const unsigned char *value, size_t vlen)\n{\n\tstatic const unsigned char month_lengths[] = { 31, 29, 31, 30, 31, 30,\n\t\t\t\t\t\t       31, 31, 30, 31, 30, 31 };\n\tconst unsigned char *p = value;\n\tunsigned year, mon, day, hour, min, sec, mon_len;\n\n#define dec2bin(X) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })\n#define DD2bin(P) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })\n\n\tif (tag == ASN1_UNITIM) {\n\t\t/* UTCTime: YYMMDDHHMMSSZ */\n\t\tif (vlen != 13)\n\t\t\tgoto unsupported_time;\n\t\tyear = DD2bin(p);\n\t\tif (year >= 50)\n\t\t\tyear += 1900;\n\t\telse\n\t\t\tyear += 2000;\n\t} else if (tag == ASN1_GENTIM) {\n\t\t/* GenTime: YYYYMMDDHHMMSSZ */\n\t\tif (vlen != 15)\n\t\t\tgoto unsupported_time;\n\t\tyear = DD2bin(p) * 100 + DD2bin(p);\n\t\tif (year >= 1950 && year <= 2049)\n\t\t\tgoto invalid_time;\n\t} else {\n\t\tgoto unsupported_time;\n\t}\n\n\tmon  = DD2bin(p);\n\tday = DD2bin(p);\n\thour = DD2bin(p);\n\tmin  = DD2bin(p);\n\tsec  = DD2bin(p);\n\n\tif (*p != 'Z')\n\t\tgoto unsupported_time;\n\n\tif (year < 1970 ||\n\t    mon < 1 || mon > 12)\n\t\tgoto invalid_time;\n\n\tmon_len = month_lengths[mon - 1];\n\tif (mon == 2) {\n\t\tif (year % 4 == 0) {\n\t\t\tmon_len = 29;\n\t\t\tif (year % 100 == 0) {\n\t\t\t\tyear /= 100;\n\t\t\t\tif (year % 4 != 0)\n\t\t\t\t\tmon_len = 28;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (day < 1 || day > mon_len ||\n\t    hour > 23 ||\n\t    min > 59 ||\n\t    sec > 59)\n\t\tgoto invalid_time;\n\n\t*_t = mktime64(year, mon, day, hour, min, sec);\n\treturn 0;\n\nunsupported_time:\n\tpr_debug(\"Got unsupported time [tag %02x]: '%*phN'\\n\",\n\t\t tag, (int)vlen, value);\n\treturn -EBADMSG;\ninvalid_time:\n\tpr_debug(\"Got invalid time [tag %02x]: '%*phN'\\n\",\n\t\t tag, (int)vlen, value);\n\treturn -EBADMSG;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tif (use_unicode(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3799,
            "cve_id": "CVE-2022-48502",
            "code_snippet": "static int ntfs_read_ea(struct ntfs_inode *ni, struct EA_FULL **ea,\n\t\t\tsize_t add_bytes, const struct EA_INFO **info)\n{\n\tint err = -EINVAL;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct ATTRIB *attr_info, *attr_ea;\n\tvoid *ea_p;\n\tu32 size, off, ea_size;\n\n\tstatic_assert(le32_to_cpu(ATTR_EA_INFO) < le32_to_cpu(ATTR_EA));\n\n\t*ea = NULL;\n\t*info = NULL;\n\n\tattr_info =\n\t\tni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, NULL);\n\tattr_ea =\n\t\tni_find_attr(ni, attr_info, &le, ATTR_EA, NULL, 0, NULL, NULL);\n\n\tif (!attr_ea || !attr_info)\n\t\treturn 0;\n\n\t*info = resident_data_ex(attr_info, sizeof(struct EA_INFO));\n\tif (!*info)\n\t\tgoto out;\n\n\t/* Check Ea limit. */\n\tsize = le32_to_cpu((*info)->size);\n\tif (size > sbi->ea_max_size) {\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tif (attr_size(attr_ea) > sbi->ea_max_size) {\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* EA info persists, but xattr is empty. Looks like EA problem. */\n\t\tgoto out;\n\t}\n\n\t/* Allocate memory for packed Ea. */\n\tea_p = kmalloc(size_add(size, add_bytes), GFP_NOFS);\n\tif (!ea_p)\n\t\treturn -ENOMEM;\n\n\tif (attr_ea->non_res) {\n\t\tstruct runs_tree run;\n\n\t\trun_init(&run);\n\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &run, 0, size);\n\t\tif (!err)\n\t\t\terr = ntfs_read_run_nb(sbi, &run, 0, ea_p, size, NULL);\n\t\trun_close(&run);\n\n\t\tif (err)\n\t\t\tgoto out1;\n\t} else {\n\t\tvoid *p = resident_data_ex(attr_ea, size);\n\n\t\tif (!p)\n\t\t\tgoto out1;\n\t\tmemcpy(ea_p, p, size);\n\t}\n\n\tmemset(Add2Ptr(ea_p, size), 0, add_bytes);\n\n\t/* Check all attributes for consistency. */\n\tfor (off = 0; off < size; off += ea_size) {\n\t\tconst struct EA_FULL *ef = Add2Ptr(ea_p, off);\n\t\tu32 bytes = size - off;\n\n\t\t/* Check if we can use field ea->size. */\n\t\tif (bytes < sizeof(ef->size))\n\t\t\tgoto out1;\n\n\t\tif (ef->size) {\n\t\t\tea_size = le32_to_cpu(ef->size);\n\t\t\tif (ea_size > bytes)\n\t\t\t\tgoto out1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check if we can use fields ef->name_len and ef->elength. */\n\t\tif (bytes < offsetof(struct EA_FULL, name))\n\t\t\tgoto out1;\n\n\t\tea_size = ALIGN(struct_size(ef, name,\n\t\t\t\t\t    1 + ef->name_len +\n\t\t\t\t\t\t    le16_to_cpu(ef->elength)),\n\t\t\t\t4);\n\t\tif (ea_size > bytes)\n\t\t\tgoto out1;\n\t}\n\n\t*ea = ea_p;\n\treturn 0;\n\nout1:\n\tkfree(ea_p);\nout:\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off)) {\n\t\tstruct EA_FULL *ea;\n\t\tsize_t ea_sz;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tea_sz = unpacked_ea_size(ea);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}",
                        "code_after_change": "static noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int ntfs_read_ea(struct ntfs_inode *ni, struct EA_FULL **ea,\n\t\t\tsize_t add_bytes, const struct EA_INFO **info)\n{\n\tint err = -EINVAL;\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tstruct ATTR_LIST_ENTRY *le = NULL;\n\tstruct ATTRIB *attr_info, *attr_ea;\n\tvoid *ea_p;\n\tu32 size, off, ea_size;\n\n\tstatic_assert(le32_to_cpu(ATTR_EA_INFO) < le32_to_cpu(ATTR_EA));\n\n\t*ea = NULL;\n\t*info = NULL;\n\n\tattr_info =\n\t\tni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, NULL);\n\tattr_ea =\n\t\tni_find_attr(ni, attr_info, &le, ATTR_EA, NULL, 0, NULL, NULL);\n\n\tif (!attr_ea || !attr_info)\n\t\treturn 0;\n\n\t*info = resident_data_ex(attr_info, sizeof(struct EA_INFO));\n\tif (!*info)\n\t\tgoto out;\n\n\t/* Check Ea limit. */\n\tsize = le32_to_cpu((*info)->size);\n\tif (size > sbi->ea_max_size) {\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tif (attr_size(attr_ea) > sbi->ea_max_size) {\n\t\terr = -EFBIG;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* EA info persists, but xattr is empty. Looks like EA problem. */\n\t\tgoto out;\n\t}\n\n\t/* Allocate memory for packed Ea. */\n\tea_p = kmalloc(size_add(size, add_bytes), GFP_NOFS);\n\tif (!ea_p)\n\t\treturn -ENOMEM;\n\n\tif (attr_ea->non_res) {\n\t\tstruct runs_tree run;\n\n\t\trun_init(&run);\n\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &run, 0, size);\n\t\tif (!err)\n\t\t\terr = ntfs_read_run_nb(sbi, &run, 0, ea_p, size, NULL);\n\t\trun_close(&run);\n\n\t\tif (err)\n\t\t\tgoto out1;\n\t} else {\n\t\tvoid *p = resident_data_ex(attr_ea, size);\n\n\t\tif (!p)\n\t\t\tgoto out1;\n\t\tmemcpy(ea_p, p, size);\n\t}\n\n\tmemset(Add2Ptr(ea_p, size), 0, add_bytes);\n\n\t/* Check all attributes for consistency. */\n\tfor (off = 0; off < size; off += ea_size) {\n\t\tconst struct EA_FULL *ef = Add2Ptr(ea_p, off);\n\t\tu32 bytes = size - off;\n\n\t\t/* Check if we can use field ea->size. */\n\t\tif (bytes < sizeof(ef->size))\n\t\t\tgoto out1;\n\n\t\tif (ef->size) {\n\t\t\tea_size = le32_to_cpu(ef->size);\n\t\t\tif (ea_size > bytes)\n\t\t\t\tgoto out1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check if we can use fields ef->name_len and ef->elength. */\n\t\tif (bytes < offsetof(struct EA_FULL, name))\n\t\t\tgoto out1;\n\n\t\tea_size = ALIGN(struct_size(ef, name,\n\t\t\t\t\t    1 + ef->name_len +\n\t\t\t\t\t\t    le16_to_cpu(ef->elength)),\n\t\t\t\t4);\n\t\tif (ea_size > bytes)\n\t\t\tgoto out1;\n\t}\n\n\t*ea = ea_p;\n\treturn 0;\n\nout1:\n\tkfree(ea_p);\nout:\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off)) {\n\t\tstruct EA_FULL *ea;\n\t\tsize_t ea_sz;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tea_sz = unpacked_ea_size(ea);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3801,
            "cve_id": "CVE-2022-48502",
            "code_snippet": "static ssize_t ntfs_list_ea(struct ntfs_inode *ni, char *buffer,\n\t\t\t    size_t bytes_per_buffer)\n{\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, size;\n\tint err;\n\tint ea_size;\n\tsize_t ret;\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\treturn err;\n\n\tif (!info || !ea_all)\n\t\treturn 0;\n\n\tsize = le32_to_cpu(info->size);\n\n\t/* Enumerate all xattrs. */\n\tfor (ret = 0, off = 0; off < size; off += ea_size) {\n\t\tea = Add2Ptr(ea_all, off);\n\t\tea_size = unpacked_ea_size(ea);\n\n\t\tif (buffer) {\n\t\t\tif (ret + ea->name_len + 1 > bytes_per_buffer) {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(buffer + ret, ea->name, ea->name_len);\n\t\t\tbuffer[ret + ea->name_len] = 0;\n\t\t}\n\n\t\tret += ea->name_len + 1;\n\t}\n\nout:\n\tkfree(ea_all);\n\treturn err ? err : ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ntfs_get_ea(struct inode *inode, const char *name, size_t name_len,\n\t\t       void *buffer, size_t size, size_t *required)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, len;\n\tint err;\n\n\tif (!(ni->ni_flags & NI_FLAG_EA))\n\t\treturn -ENODATA;\n\n\tif (!required)\n\t\tni_lock(ni);\n\n\tlen = 0;\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info)\n\t\tgoto out;\n\n\t/* Enumerate all xattrs. */\n\tif (!find_ea(ea_all, le32_to_cpu(info->size), name, name_len, &off)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\tea = Add2Ptr(ea_all, off);\n\n\tlen = le16_to_cpu(ea->elength);\n\tif (!buffer) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (len > size) {\n\t\terr = -ERANGE;\n\t\tif (required)\n\t\t\t*required = len;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buffer, ea->name + ea->name_len + 1, len);\n\terr = 0;\n\nout:\n\tkfree(ea_all);\n\tif (!required)\n\t\tni_unlock(ni);\n\n\treturn err ? err : len;\n}",
                        "code_after_change": "static int ntfs_get_ea(struct inode *inode, const char *name, size_t name_len,\n\t\t       void *buffer, size_t size, size_t *required)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, len;\n\tint err;\n\n\tif (!(ni->ni_flags & NI_FLAG_EA))\n\t\treturn -ENODATA;\n\n\tif (!required)\n\t\tni_lock(ni);\n\n\tlen = 0;\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info)\n\t\tgoto out;\n\n\t/* Enumerate all xattrs. */\n\tif (!find_ea(ea_all, le32_to_cpu(info->size), name, name_len, &off,\n\t\t     NULL)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\tea = Add2Ptr(ea_all, off);\n\n\tlen = le16_to_cpu(ea->elength);\n\tif (!buffer) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (len > size) {\n\t\terr = -ERANGE;\n\t\tif (required)\n\t\t\t*required = len;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buffer, ea->name + ea->name_len + 1, len);\n\terr = 0;\n\nout:\n\tkfree(ea_all);\n\tif (!required)\n\t\tni_unlock(ni);\n\n\treturn err ? err : len;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic ssize_t ntfs_list_ea(struct ntfs_inode *ni, char *buffer,\n\t\t\t    size_t bytes_per_buffer)\n{\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, size;\n\tint err;\n\tint ea_size;\n\tsize_t ret;\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\treturn err;\n\n\tif (!info || !ea_all)\n\t\treturn 0;\n\n\tsize = le32_to_cpu(info->size);\n\n\t/* Enumerate all xattrs. */\n\tfor (ret = 0, off = 0; off < size; off += ea_size) {\n\t\tea = Add2Ptr(ea_all, off);\n\t\tea_size = unpacked_ea_size(ea);\n\n\t\tif (buffer) {\n\t\t\tif (ret + ea->name_len + 1 > bytes_per_buffer) {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(buffer + ret, ea->name, ea->name_len);\n\t\t\tbuffer[ret + ea->name_len] = 0;\n\t\t}\n\n\t\tret += ea->name_len + 1;\n\t}\n\nout:\n\tkfree(ea_all);\n\treturn err ? err : ret;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int ntfs_get_ea(struct inode *inode, const char *name, size_t name_len,\n\t\t       void *buffer, size_t size, size_t *required)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, len;\n\tint err;\n\n\tif (!(ni->ni_flags & NI_FLAG_EA))\n\t\treturn -ENODATA;\n\n\tif (!required)\n\t\tni_lock(ni);\n\n\tlen = 0;\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info)\n\t\tgoto out;\n\n\t/* Enumerate all xattrs. */\n\tif (!find_ea(ea_all, le32_to_cpu(info->size), name, name_len, &off)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\tea = Add2Ptr(ea_all, off);\n\n\tlen = le16_to_cpu(ea->elength);\n\tif (!buffer) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (len > size) {\n\t\terr = -ERANGE;\n\t\tif (required)\n\t\t\t*required = len;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buffer, ea->name + ea->name_len + 1, len);\n\terr = 0;\n\nout:\n\tkfree(ea_all);\n\tif (!required)\n\t\tni_unlock(ni);\n\n\treturn err ? err : len;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int ntfs_get_ea(struct inode *inode, const char *name, size_t name_len,\n\t\t       void *buffer, size_t size, size_t *required)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *ea_all = NULL;\n\tconst struct EA_FULL *ea;\n\tu32 off, len;\n\tint err;\n\n\tif (!(ni->ni_flags & NI_FLAG_EA))\n\t\treturn -ENODATA;\n\n\tif (!required)\n\t\tni_lock(ni);\n\n\tlen = 0;\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\terr = ntfs_read_ea(ni, &ea_all, 0, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info)\n\t\tgoto out;\n\n\t/* Enumerate all xattrs. */\n\tif (!find_ea(ea_all, le32_to_cpu(info->size), name, name_len, &off,\n\t\t     NULL)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\tea = Add2Ptr(ea_all, off);\n\n\tlen = le16_to_cpu(ea->elength);\n\tif (!buffer) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (len > size) {\n\t\terr = -ERANGE;\n\t\tif (required)\n\t\t\t*required = len;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buffer, ea->name + ea->name_len + 1, len);\n\terr = 0;\n\nout:\n\tkfree(ea_all);\n\tif (!required)\n\t\tni_unlock(ni);\n\n\treturn err ? err : len;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2711,
            "cve_id": "CVE-2020-35519",
            "code_snippet": "static int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check for the null_x25_address */\n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int x25_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tstruct x25_route *rt;\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out; /* Connect completed during a ERESTARTSYS event */\n\t}\n\n\trc = -ECONNREFUSED;\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\t}\n\n\trc = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tgoto out;\n\n\trc = -EALREADY;\t/* Do nothing if call is already in progress */\n\tif (sk->sk_state == TCP_SYN_SENT)\n\t\tgoto out;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trc = -EINVAL;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25)\n\t\tgoto out;\n\n\trc = -ENETUNREACH;\n\trt = x25_get_route(&addr->sx25_addr);\n\tif (!rt)\n\t\tgoto out;\n\n\tx25->neighbour = x25_get_neigh(rt->dev);\n\tif (!x25->neighbour)\n\t\tgoto out_put_route;\n\n\tx25_limit_facilities(&x25->facilities, x25->neighbour);\n\n\tx25->lci = x25_new_lci(x25->neighbour);\n\tif (!x25->lci)\n\t\tgoto out_put_neigh;\n\n\trc = -EINVAL;\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\tgoto out_put_neigh;\n\n\tif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\n\t\tmemset(&x25->source_addr, '\\0', X25_ADDR_LEN);\n\n\tx25->dest_addr = addr->sx25_addr;\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state  = TCP_SYN_SENT;\n\n\tx25->state = X25_STATE_1;\n\n\tx25_write_internal(sk, X25_CALL_REQUEST);\n\n\tx25_start_heartbeat(sk);\n\tx25_start_t21timer(sk);\n\n\t/* Now the loop */\n\trc = -EINPROGRESS;\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\n\t\tgoto out;\n\n\trc = x25_wait_for_connection_establishment(sk);\n\tif (rc)\n\t\tgoto out_put_neigh;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout_put_neigh:\n\tif (rc && x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t\tx25->state = X25_STATE_0;\n\t}\nout_put_route:\n\tx25_route_put(rt);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}",
                        "code_after_change": "static int x25_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tstruct x25_route *rt;\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out; /* Connect completed during a ERESTARTSYS event */\n\t}\n\n\trc = -ECONNREFUSED;\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\t}\n\n\trc = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tgoto out;\n\n\trc = -EALREADY;\t/* Do nothing if call is already in progress */\n\tif (sk->sk_state == TCP_SYN_SENT)\n\t\tgoto out;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trc = -EINVAL;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN)\n\t\tgoto out;\n\n\trc = -ENETUNREACH;\n\trt = x25_get_route(&addr->sx25_addr);\n\tif (!rt)\n\t\tgoto out;\n\n\tx25->neighbour = x25_get_neigh(rt->dev);\n\tif (!x25->neighbour)\n\t\tgoto out_put_route;\n\n\tx25_limit_facilities(&x25->facilities, x25->neighbour);\n\n\tx25->lci = x25_new_lci(x25->neighbour);\n\tif (!x25->lci)\n\t\tgoto out_put_neigh;\n\n\trc = -EINVAL;\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\tgoto out_put_neigh;\n\n\tif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\n\t\tmemset(&x25->source_addr, '\\0', X25_ADDR_LEN);\n\n\tx25->dest_addr = addr->sx25_addr;\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state  = TCP_SYN_SENT;\n\n\tx25->state = X25_STATE_1;\n\n\tx25_write_internal(sk, X25_CALL_REQUEST);\n\n\tx25_start_heartbeat(sk);\n\tx25_start_t21timer(sk);\n\n\t/* Now the loop */\n\trc = -EINPROGRESS;\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\n\t\tgoto out;\n\n\trc = x25_wait_for_connection_establishment(sk);\n\tif (rc)\n\t\tgoto out_put_neigh;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout_put_neigh:\n\tif (rc && x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t\tx25->state = X25_STATE_0;\n\t}\nout_put_route:\n\tx25_route_put(rt);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}",
                        "cve_id": "CVE-2020-35519"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check for the null_x25_address */\n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int x25_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tstruct x25_route *rt;\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out; /* Connect completed during a ERESTARTSYS event */\n\t}\n\n\trc = -ECONNREFUSED;\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\t}\n\n\trc = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tgoto out;\n\n\trc = -EALREADY;\t/* Do nothing if call is already in progress */\n\tif (sk->sk_state == TCP_SYN_SENT)\n\t\tgoto out;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trc = -EINVAL;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25)\n\t\tgoto out;\n\n\trc = -ENETUNREACH;\n\trt = x25_get_route(&addr->sx25_addr);\n\tif (!rt)\n\t\tgoto out;\n\n\tx25->neighbour = x25_get_neigh(rt->dev);\n\tif (!x25->neighbour)\n\t\tgoto out_put_route;\n\n\tx25_limit_facilities(&x25->facilities, x25->neighbour);\n\n\tx25->lci = x25_new_lci(x25->neighbour);\n\tif (!x25->lci)\n\t\tgoto out_put_neigh;\n\n\trc = -EINVAL;\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\tgoto out_put_neigh;\n\n\tif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\n\t\tmemset(&x25->source_addr, '\\0', X25_ADDR_LEN);\n\n\tx25->dest_addr = addr->sx25_addr;\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state  = TCP_SYN_SENT;\n\n\tx25->state = X25_STATE_1;\n\n\tx25_write_internal(sk, X25_CALL_REQUEST);\n\n\tx25_start_heartbeat(sk);\n\tx25_start_t21timer(sk);\n\n\t/* Now the loop */\n\trc = -EINPROGRESS;\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\n\t\tgoto out;\n\n\trc = x25_wait_for_connection_establishment(sk);\n\tif (rc)\n\t\tgoto out_put_neigh;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout_put_neigh:\n\tif (rc && x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t\tx25->state = X25_STATE_0;\n\t}\nout_put_route:\n\tx25_route_put(rt);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int x25_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tstruct x25_route *rt;\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out; /* Connect completed during a ERESTARTSYS event */\n\t}\n\n\trc = -ECONNREFUSED;\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\t}\n\n\trc = -EISCONN;\t/* No reconnect on a seqpacket socket */\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tgoto out;\n\n\trc = -EALREADY;\t/* Do nothing if call is already in progress */\n\tif (sk->sk_state == TCP_SYN_SENT)\n\t\tgoto out;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trc = -EINVAL;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN)\n\t\tgoto out;\n\n\trc = -ENETUNREACH;\n\trt = x25_get_route(&addr->sx25_addr);\n\tif (!rt)\n\t\tgoto out;\n\n\tx25->neighbour = x25_get_neigh(rt->dev);\n\tif (!x25->neighbour)\n\t\tgoto out_put_route;\n\n\tx25_limit_facilities(&x25->facilities, x25->neighbour);\n\n\tx25->lci = x25_new_lci(x25->neighbour);\n\tif (!x25->lci)\n\t\tgoto out_put_neigh;\n\n\trc = -EINVAL;\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\tgoto out_put_neigh;\n\n\tif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\n\t\tmemset(&x25->source_addr, '\\0', X25_ADDR_LEN);\n\n\tx25->dest_addr = addr->sx25_addr;\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state  = TCP_SYN_SENT;\n\n\tx25->state = X25_STATE_1;\n\n\tx25_write_internal(sk, X25_CALL_REQUEST);\n\n\tx25_start_heartbeat(sk);\n\tx25_start_t21timer(sk);\n\n\t/* Now the loop */\n\trc = -EINPROGRESS;\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\n\t\tgoto out;\n\n\trc = x25_wait_for_connection_establishment(sk);\n\tif (rc)\n\t\tgoto out_put_neigh;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout_put_neigh:\n\tif (rc && x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t\tx25->state = X25_STATE_0;\n\t}\nout_put_route:\n\tx25_route_put(rt);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3796,
            "cve_id": "CVE-2022-48502",
            "code_snippet": "struct inode *ntfs_iget5(struct super_block *sb, const struct MFT_REF *ref,\n\t\t\t const struct cpu_str *name)\n{\n\tstruct inode *inode;\n\n\tinode = iget5_locked(sb, ino_get(ref), ntfs_test_inode, ntfs_set_inode,\n\t\t\t     (void *)ref);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (inode->i_state & I_NEW)\n\t\tinode = ntfs_read_mft(inode, name, ref);\n\telse if (ref->seq != ntfs_i(inode)->mi.mrec->seq) {\n\t\t/* Inode overlaps? */\n\t\t_ntfs_bad_inode(inode);\n\t}\n\n\tif (IS_ERR(inode) && name)\n\t\tntfs_set_state(sb->s_fs_info, NTFS_DIRTY_ERROR);\n\n\treturn inode;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstruct inode *ntfs_iget5(struct super_block *sb, const struct MFT_REF *ref,\n\t\t\t const struct cpu_str *name)\n{\n\tstruct inode *inode;\n\n\tinode = iget5_locked(sb, ino_get(ref), ntfs_test_inode, ntfs_set_inode,\n\t\t\t     (void *)ref);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (inode->i_state & I_NEW)\n\t\tinode = ntfs_read_mft(inode, name, ref);\n\telse if (ref->seq != ntfs_i(inode)->mi.mrec->seq) {\n\t\t/* Inode overlaps? */\n\t\t_ntfs_bad_inode(inode);\n\t}\n\n\tif (IS_ERR(inode) && name)\n\t\tntfs_set_state(sb->s_fs_info, NTFS_DIRTY_ERROR);\n\n\treturn inode;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,\n\t\t\t\tstruct inode *dir, struct dentry *dentry,\n\t\t\t\tconst struct cpu_str *uni, umode_t mode,\n\t\t\t\tdev_t dev, const char *symname, u32 size,\n\t\t\t\tstruct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tconst struct qstr *name = &dentry->d_name;\n\tCLST ino = 0;\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct ntfs_inode *ni = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_STD_INFO5 *std5;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct MFT_REC *rec;\n\tu32 asize, dsize, sd_size;\n\tenum FILE_ATTRIBUTE fa;\n\t__le32 security_id = SECURITY_ID_INVALID;\n\tCLST vcn;\n\tconst void *sd;\n\tu16 t16, nsize = 0, aid = 0;\n\tstruct INDEX_ROOT *root, *dir_root;\n\tstruct NTFS_DE *e, *new_de = NULL;\n\tstruct REPARSE_DATA_BUFFER *rp = NULL;\n\tbool rp_inserted = false;\n\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\n\tdir_root = indx_get_root(&dir_ni->dir, dir_ni, NULL, NULL);\n\tif (!dir_root) {\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\t/* Use parent's directory attributes. */\n\t\tfa = dir_ni->std_fa | FILE_ATTRIBUTE_DIRECTORY |\n\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t/*\n\t\t * By default child directory inherits parent attributes.\n\t\t * Root directory is hidden + system.\n\t\t * Make an exception for children in root.\n\t\t */\n\t\tif (dir->i_ino == MFT_REC_ROOT)\n\t\t\tfa &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);\n\t} else if (S_ISLNK(mode)) {\n\t\t/* It is good idea that link should be the same type (file/dir) as target */\n\t\tfa = FILE_ATTRIBUTE_REPARSE_POINT;\n\n\t\t/*\n\t\t * Linux: there are dir/file/symlink and so on.\n\t\t * NTFS: symlinks are \"dir + reparse\" or \"file + reparse\"\n\t\t * It is good idea to create:\n\t\t * dir + reparse if 'symname' points to directory\n\t\t * or\n\t\t * file + reparse if 'symname' points to file\n\t\t * Unfortunately kern_path hangs if symname contains 'dir'.\n\t\t */\n\n\t\t/*\n\t\t *\tstruct path path;\n\t\t *\n\t\t *\tif (!kern_path(symname, LOOKUP_FOLLOW, &path)){\n\t\t *\t\tstruct inode *target = d_inode(path.dentry);\n\t\t *\n\t\t *\t\tif (S_ISDIR(target->i_mode))\n\t\t *\t\t\tfa |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t *\t\t// if ( target->i_sb == sb ){\n\t\t *\t\t//\tuse relative path?\n\t\t *\t\t// }\n\t\t *\t\tpath_put(&path);\n\t\t *\t}\n\t\t */\n\t} else if (S_ISREG(mode)) {\n\t\tif (sbi->options->sparse) {\n\t\t\t/* Sparsed regular file, cause option 'sparse'. */\n\t\t\tfa = FILE_ATTRIBUTE_SPARSE_FILE |\n\t\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\t/* Compressed regular file, if parent is compressed. */\n\t\t\tfa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else {\n\t\t\t/* Regular file, default attributes. */\n\t\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t\t}\n\t} else {\n\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t}\n\n\t/* If option \"hide_dot_files\" then set hidden attribute for dot files. */\n\tif (sbi->options->hide_dot_files && name->name[0] == '.')\n\t\tfa |= FILE_ATTRIBUTE_HIDDEN;\n\n\tif (!(mode & 0222))\n\t\tfa |= FILE_ATTRIBUTE_READONLY;\n\n\t/* Allocate PATH_MAX bytes. */\n\tnew_de = __getname();\n\tif (!new_de) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Mark rw ntfs as dirty. it will be cleared at umount. */\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t/* Step 1: allocate and fill new mft record. */\n\terr = ntfs_look_free_mft(sbi, &ino, false, NULL, NULL);\n\tif (err)\n\t\tgoto out2;\n\n\tni = ntfs_new_inode(sbi, ino, fa & FILE_ATTRIBUTE_DIRECTORY);\n\tif (IS_ERR(ni)) {\n\t\terr = PTR_ERR(ni);\n\t\tni = NULL;\n\t\tgoto out3;\n\t}\n\tinode = &ni->vfs_inode;\n\tinode_init_owner(mnt_userns, inode, dir, mode);\n\tmode = inode->i_mode;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = ni->i_crtime =\n\t\tcurrent_time(inode);\n\n\trec = ni->mi.mrec;\n\trec->hard_links = cpu_to_le16(1);\n\tattr = Add2Ptr(rec, le16_to_cpu(rec->attr_off));\n\n\t/* Get default security id. */\n\tsd = s_default_security;\n\tsd_size = sizeof(s_default_security);\n\n\tif (is_ntfs3(sbi)) {\n\t\tsecurity_id = dir_ni->std_security_id;\n\t\tif (le32_to_cpu(security_id) < SECURITY_ID_FIRST) {\n\t\t\tsecurity_id = sbi->security.def_security_id;\n\n\t\t\tif (security_id == SECURITY_ID_INVALID &&\n\t\t\t    !ntfs_insert_security(sbi, sd, sd_size,\n\t\t\t\t\t\t  &security_id, NULL))\n\t\t\t\tsbi->security.def_security_id = security_id;\n\t\t}\n\t}\n\n\t/* Insert standard info. */\n\tstd5 = Add2Ptr(attr, SIZEOF_RESIDENT);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\tdsize = sizeof(struct ATTR_STD_INFO);\n\t} else {\n\t\tdsize = sizeof(struct ATTR_STD_INFO5);\n\t\tstd5->security_id = security_id;\n\t\tni->std_security_id = security_id;\n\t}\n\tasize = SIZEOF_RESIDENT + dsize;\n\n\tattr->type = ATTR_STD;\n\tattr->size = cpu_to_le32(asize);\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.data_size = cpu_to_le32(dsize);\n\n\tstd5->cr_time = std5->m_time = std5->c_time = std5->a_time =\n\t\tkernel2nt(&inode->i_atime);\n\n\tni->std_fa = fa;\n\tstd5->fa = fa;\n\n\tattr = Add2Ptr(attr, asize);\n\n\t/* Insert file name. */\n\terr = fill_name_de(sbi, new_de, name, uni);\n\tif (err)\n\t\tgoto out4;\n\n\tmi_get_ref(&ni->mi, &new_de->ref);\n\n\tfname = (struct ATTR_FILE_NAME *)(new_de + 1);\n\n\tif (sbi->options->windows_names &&\n\t    !valid_windows_name(sbi, (struct le_str *)&fname->name_len)) {\n\t\terr = -EINVAL;\n\t\tgoto out4;\n\t}\n\n\tmi_get_ref(&dir_ni->mi, &fname->home);\n\tfname->dup.cr_time = fname->dup.m_time = fname->dup.c_time =\n\t\tfname->dup.a_time = std5->cr_time;\n\tfname->dup.alloc_size = fname->dup.data_size = 0;\n\tfname->dup.fa = std5->fa;\n\tfname->dup.ea_size = fname->dup.reparse = 0;\n\n\tdsize = le16_to_cpu(new_de->key_size);\n\tasize = ALIGN(SIZEOF_RESIDENT + dsize, 8);\n\n\tattr->type = ATTR_NAME;\n\tattr->size = cpu_to_le32(asize);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.flags = RESIDENT_FLAG_INDEXED;\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_size = cpu_to_le32(dsize);\n\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), fname, dsize);\n\n\tattr = Add2Ptr(attr, asize);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\t/* Insert security attribute. */\n\t\tasize = SIZEOF_RESIDENT + ALIGN(sd_size, 8);\n\n\t\tattr->type = ATTR_SECURE;\n\t\tattr->size = cpu_to_le32(asize);\n\t\tattr->id = cpu_to_le16(aid++);\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_size = cpu_to_le32(sd_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), sd, sd_size);\n\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\tattr->id = cpu_to_le16(aid++);\n\tif (fa & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t/*\n\t\t * Regular directory or symlink to directory.\n\t\t * Create root attribute.\n\t\t */\n\t\tdsize = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE);\n\t\tasize = sizeof(I30_NAME) + SIZEOF_RESIDENT + dsize;\n\n\t\tattr->type = ATTR_ROOT;\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\tattr->name_len = ARRAY_SIZE(I30_NAME);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off =\n\t\t\tcpu_to_le16(sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tattr->res.data_size = cpu_to_le32(dsize);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), I30_NAME,\n\t\t       sizeof(I30_NAME));\n\n\t\troot = Add2Ptr(attr, sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tmemcpy(root, dir_root, offsetof(struct INDEX_ROOT, ihdr));\n\t\troot->ihdr.de_off =\n\t\t\tcpu_to_le32(sizeof(struct INDEX_HDR)); // 0x10\n\t\troot->ihdr.used = cpu_to_le32(sizeof(struct INDEX_HDR) +\n\t\t\t\t\t      sizeof(struct NTFS_DE));\n\t\troot->ihdr.total = root->ihdr.used;\n\n\t\te = Add2Ptr(root, sizeof(struct INDEX_ROOT));\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST;\n\t} else if (S_ISLNK(mode)) {\n\t\t/*\n\t\t * Symlink to file.\n\t\t * Create empty resident data attribute.\n\t\t */\n\t\tasize = SIZEOF_RESIDENT;\n\n\t\t/* Insert empty ATTR_DATA */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t} else if (S_ISREG(mode)) {\n\t\t/*\n\t\t * Regular file. Create empty non resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->non_res = 1;\n\t\tattr->nres.evcn = cpu_to_le64(-1ll);\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tasize = SIZEOF_NONRESIDENT + 8;\n\t\t}\n\t\tattr->nres.run_off = attr->name_off;\n\t} else {\n\t\t/*\n\t\t * Node. Create empty resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\telse if (fa & FILE_ATTRIBUTE_COMPRESSED)\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tasize = SIZEOF_RESIDENT;\n\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out4;\n\t} else if (S_ISLNK(mode)) {\n\t\trp = ntfs_create_reparse_buffer(sbi, symname, size, &nsize);\n\n\t\tif (IS_ERR(rp)) {\n\t\t\terr = PTR_ERR(rp);\n\t\t\trp = NULL;\n\t\t\tgoto out4;\n\t\t}\n\n\t\t/*\n\t\t * Insert ATTR_REPARSE.\n\t\t */\n\t\tattr = Add2Ptr(attr, asize);\n\t\tattr->type = ATTR_REPARSE;\n\t\tattr->id = cpu_to_le16(aid++);\n\n\t\t/* Resident or non resident? */\n\t\tasize = ALIGN(SIZEOF_RESIDENT + nsize, 8);\n\t\tt16 = PtrOffset(rec, attr);\n\n\t\t/*\n\t\t * Below function 'ntfs_save_wsl_perm' requires 0x78 bytes.\n\t\t * It is good idea to keep extened attributes resident.\n\t\t */\n\t\tif (asize + t16 + 0x78 + 8 > sbi->record_size) {\n\t\t\tCLST alen;\n\t\t\tCLST clst = bytes_to_cluster(sbi, nsize);\n\n\t\t\t/* Bytes per runs. */\n\t\t\tt16 = sbi->record_size - t16 - SIZEOF_NONRESIDENT;\n\n\t\t\tattr->non_res = 1;\n\t\t\tattr->nres.evcn = cpu_to_le64(clst - 1);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tattr->nres.run_off = attr->name_off;\n\t\t\tattr->nres.data_size = cpu_to_le64(nsize);\n\t\t\tattr->nres.valid_size = attr->nres.data_size;\n\t\t\tattr->nres.alloc_size =\n\t\t\t\tcpu_to_le64(ntfs_up_cluster(sbi, nsize));\n\n\t\t\terr = attr_allocate_clusters(sbi, &ni->file.run, 0, 0,\n\t\t\t\t\t\t     clst, NULL, ALLOCATE_DEF,\n\t\t\t\t\t\t     &alen, 0, NULL, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out5;\n\n\t\t\terr = run_pack(&ni->file.run, 0, clst,\n\t\t\t\t       Add2Ptr(attr, SIZEOF_NONRESIDENT), t16,\n\t\t\t\t       &vcn);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out5;\n\n\t\t\tif (vcn != clst) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out5;\n\t\t\t}\n\n\t\t\tasize = SIZEOF_NONRESIDENT + ALIGN(err, 8);\n\t\t} else {\n\t\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\t\tattr->res.data_size = cpu_to_le32(nsize);\n\t\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), rp, nsize);\n\t\t\tnsize = 0;\n\t\t}\n\t\t/* Size of symlink equals the length of input string. */\n\t\tinode->i_size = size;\n\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\terr = ntfs_insert_reparse(sbi, IO_REPARSE_TAG_SYMLINK,\n\t\t\t\t\t  &new_de->ref);\n\t\tif (err)\n\t\t\tgoto out5;\n\n\t\trp_inserted = true;\n\t}\n\n\tattr = Add2Ptr(attr, asize);\n\tattr->type = ATTR_END;\n\n\trec->used = cpu_to_le32(PtrOffset(rec, attr) + 8);\n\trec->next_attr_id = cpu_to_le16(aid);\n\n\t/* Step 2: Add new name in index. */\n\terr = indx_insert_entry(&dir_ni->dir, dir_ni, new_de, sbi, fnd, 0);\n\tif (err)\n\t\tgoto out6;\n\n\t/* Unlock parent directory before ntfs_init_acl. */\n\tif (!fnd)\n\t\tni_unlock(dir_ni);\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\tdir->i_mtime = dir->i_ctime = inode->i_atime;\n\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode->i_mapping->a_ops = &ntfs_aops;\n\t\tinode->i_size = size;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tinit_rwsem(&ni->file.run_lock);\n\t} else {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, dev);\n\t}\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\tif (!S_ISLNK(mode) && (sb->s_flags & SB_POSIXACL)) {\n\t\terr = ntfs_init_acl(mnt_userns, inode, dir);\n\t\tif (err)\n\t\t\tgoto out7;\n\t} else\n#endif\n\t{\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\t/* Write non resident data. */\n\tif (nsize) {\n\t\terr = ntfs_sb_write_run(sbi, &ni->file.run, 0, rp, nsize, 0);\n\t\tif (err)\n\t\t\tgoto out7;\n\t}\n\n\t/*\n\t * Call 'd_instantiate' after inode->i_op is set\n\t * but before finish_open.\n\t */\n\td_instantiate(dentry, inode);\n\n\tntfs_save_wsl_perm(inode);\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\t/* Normal exit. */\n\tgoto out2;\n\nout7:\n\n\t/* Undo 'indx_insert_entry'. */\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\tindx_delete_entry(&dir_ni->dir, dir_ni, new_de + 1,\n\t\t\t  le16_to_cpu(new_de->key_size), sbi);\n\t/* ni_unlock(dir_ni); will be called later. */\nout6:\n\tif (rp_inserted)\n\t\tntfs_remove_reparse(sbi, IO_REPARSE_TAG_SYMLINK, &new_de->ref);\n\nout5:\n\tif (S_ISDIR(mode) || run_is_empty(&ni->file.run))\n\t\tgoto out4;\n\n\trun_deallocate(sbi, &ni->file.run, false);\n\nout4:\n\tclear_rec_inuse(rec);\n\tclear_nlink(inode);\n\tni->mi.dirty = false;\n\tdiscard_new_inode(inode);\nout3:\n\tntfs_mark_rec_free(sbi, ino, false);\n\nout2:\n\t__putname(new_de);\n\tkfree(rp);\n\nout1:\n\tif (err) {\n\t\tif (!fnd)\n\t\t\tni_unlock(dir_ni);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
                        "code_after_change": "struct inode *ntfs_create_inode(struct user_namespace *mnt_userns,\n\t\t\t\tstruct inode *dir, struct dentry *dentry,\n\t\t\t\tconst struct cpu_str *uni, umode_t mode,\n\t\t\t\tdev_t dev, const char *symname, u32 size,\n\t\t\t\tstruct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tconst struct qstr *name = &dentry->d_name;\n\tCLST ino = 0;\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct ntfs_inode *ni = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_STD_INFO5 *std5;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct MFT_REC *rec;\n\tu32 asize, dsize, sd_size;\n\tenum FILE_ATTRIBUTE fa;\n\t__le32 security_id = SECURITY_ID_INVALID;\n\tCLST vcn;\n\tconst void *sd;\n\tu16 t16, nsize = 0, aid = 0;\n\tstruct INDEX_ROOT *root, *dir_root;\n\tstruct NTFS_DE *e, *new_de = NULL;\n\tstruct REPARSE_DATA_BUFFER *rp = NULL;\n\tbool rp_inserted = false;\n\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\n\tdir_root = indx_get_root(&dir_ni->dir, dir_ni, NULL, NULL);\n\tif (!dir_root) {\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\t/* Use parent's directory attributes. */\n\t\tfa = dir_ni->std_fa | FILE_ATTRIBUTE_DIRECTORY |\n\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t/*\n\t\t * By default child directory inherits parent attributes.\n\t\t * Root directory is hidden + system.\n\t\t * Make an exception for children in root.\n\t\t */\n\t\tif (dir->i_ino == MFT_REC_ROOT)\n\t\t\tfa &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);\n\t} else if (S_ISLNK(mode)) {\n\t\t/* It is good idea that link should be the same type (file/dir) as target */\n\t\tfa = FILE_ATTRIBUTE_REPARSE_POINT;\n\n\t\t/*\n\t\t * Linux: there are dir/file/symlink and so on.\n\t\t * NTFS: symlinks are \"dir + reparse\" or \"file + reparse\"\n\t\t * It is good idea to create:\n\t\t * dir + reparse if 'symname' points to directory\n\t\t * or\n\t\t * file + reparse if 'symname' points to file\n\t\t * Unfortunately kern_path hangs if symname contains 'dir'.\n\t\t */\n\n\t\t/*\n\t\t *\tstruct path path;\n\t\t *\n\t\t *\tif (!kern_path(symname, LOOKUP_FOLLOW, &path)){\n\t\t *\t\tstruct inode *target = d_inode(path.dentry);\n\t\t *\n\t\t *\t\tif (S_ISDIR(target->i_mode))\n\t\t *\t\t\tfa |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t *\t\t// if ( target->i_sb == sb ){\n\t\t *\t\t//\tuse relative path?\n\t\t *\t\t// }\n\t\t *\t\tpath_put(&path);\n\t\t *\t}\n\t\t */\n\t} else if (S_ISREG(mode)) {\n\t\tif (sbi->options->sparse) {\n\t\t\t/* Sparsed regular file, cause option 'sparse'. */\n\t\t\tfa = FILE_ATTRIBUTE_SPARSE_FILE |\n\t\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\t/* Compressed regular file, if parent is compressed. */\n\t\t\tfa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else {\n\t\t\t/* Regular file, default attributes. */\n\t\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t\t}\n\t} else {\n\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t}\n\n\t/* If option \"hide_dot_files\" then set hidden attribute for dot files. */\n\tif (sbi->options->hide_dot_files && name->name[0] == '.')\n\t\tfa |= FILE_ATTRIBUTE_HIDDEN;\n\n\tif (!(mode & 0222))\n\t\tfa |= FILE_ATTRIBUTE_READONLY;\n\n\t/* Allocate PATH_MAX bytes. */\n\tnew_de = __getname();\n\tif (!new_de) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Mark rw ntfs as dirty. it will be cleared at umount. */\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t/* Step 1: allocate and fill new mft record. */\n\terr = ntfs_look_free_mft(sbi, &ino, false, NULL, NULL);\n\tif (err)\n\t\tgoto out2;\n\n\tni = ntfs_new_inode(sbi, ino, fa & FILE_ATTRIBUTE_DIRECTORY);\n\tif (IS_ERR(ni)) {\n\t\terr = PTR_ERR(ni);\n\t\tni = NULL;\n\t\tgoto out3;\n\t}\n\tinode = &ni->vfs_inode;\n\tinode_init_owner(mnt_userns, inode, dir, mode);\n\tmode = inode->i_mode;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = ni->i_crtime =\n\t\tcurrent_time(inode);\n\n\trec = ni->mi.mrec;\n\trec->hard_links = cpu_to_le16(1);\n\tattr = Add2Ptr(rec, le16_to_cpu(rec->attr_off));\n\n\t/* Get default security id. */\n\tsd = s_default_security;\n\tsd_size = sizeof(s_default_security);\n\n\tif (is_ntfs3(sbi)) {\n\t\tsecurity_id = dir_ni->std_security_id;\n\t\tif (le32_to_cpu(security_id) < SECURITY_ID_FIRST) {\n\t\t\tsecurity_id = sbi->security.def_security_id;\n\n\t\t\tif (security_id == SECURITY_ID_INVALID &&\n\t\t\t    !ntfs_insert_security(sbi, sd, sd_size,\n\t\t\t\t\t\t  &security_id, NULL))\n\t\t\t\tsbi->security.def_security_id = security_id;\n\t\t}\n\t}\n\n\t/* Insert standard info. */\n\tstd5 = Add2Ptr(attr, SIZEOF_RESIDENT);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\tdsize = sizeof(struct ATTR_STD_INFO);\n\t} else {\n\t\tdsize = sizeof(struct ATTR_STD_INFO5);\n\t\tstd5->security_id = security_id;\n\t\tni->std_security_id = security_id;\n\t}\n\tasize = SIZEOF_RESIDENT + dsize;\n\n\tattr->type = ATTR_STD;\n\tattr->size = cpu_to_le32(asize);\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.data_size = cpu_to_le32(dsize);\n\n\tstd5->cr_time = std5->m_time = std5->c_time = std5->a_time =\n\t\tkernel2nt(&inode->i_atime);\n\n\tni->std_fa = fa;\n\tstd5->fa = fa;\n\n\tattr = Add2Ptr(attr, asize);\n\n\t/* Insert file name. */\n\terr = fill_name_de(sbi, new_de, name, uni);\n\tif (err)\n\t\tgoto out4;\n\n\tmi_get_ref(&ni->mi, &new_de->ref);\n\n\tfname = (struct ATTR_FILE_NAME *)(new_de + 1);\n\n\tif (sbi->options->windows_names &&\n\t    !valid_windows_name(sbi, (struct le_str *)&fname->name_len)) {\n\t\terr = -EINVAL;\n\t\tgoto out4;\n\t}\n\n\tmi_get_ref(&dir_ni->mi, &fname->home);\n\tfname->dup.cr_time = fname->dup.m_time = fname->dup.c_time =\n\t\tfname->dup.a_time = std5->cr_time;\n\tfname->dup.alloc_size = fname->dup.data_size = 0;\n\tfname->dup.fa = std5->fa;\n\tfname->dup.ea_size = fname->dup.reparse = 0;\n\n\tdsize = le16_to_cpu(new_de->key_size);\n\tasize = ALIGN(SIZEOF_RESIDENT + dsize, 8);\n\n\tattr->type = ATTR_NAME;\n\tattr->size = cpu_to_le32(asize);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.flags = RESIDENT_FLAG_INDEXED;\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_size = cpu_to_le32(dsize);\n\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), fname, dsize);\n\n\tattr = Add2Ptr(attr, asize);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\t/* Insert security attribute. */\n\t\tasize = SIZEOF_RESIDENT + ALIGN(sd_size, 8);\n\n\t\tattr->type = ATTR_SECURE;\n\t\tattr->size = cpu_to_le32(asize);\n\t\tattr->id = cpu_to_le16(aid++);\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_size = cpu_to_le32(sd_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), sd, sd_size);\n\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\tattr->id = cpu_to_le16(aid++);\n\tif (fa & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t/*\n\t\t * Regular directory or symlink to directory.\n\t\t * Create root attribute.\n\t\t */\n\t\tdsize = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE);\n\t\tasize = sizeof(I30_NAME) + SIZEOF_RESIDENT + dsize;\n\n\t\tattr->type = ATTR_ROOT;\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\tattr->name_len = ARRAY_SIZE(I30_NAME);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off =\n\t\t\tcpu_to_le16(sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tattr->res.data_size = cpu_to_le32(dsize);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), I30_NAME,\n\t\t       sizeof(I30_NAME));\n\n\t\troot = Add2Ptr(attr, sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tmemcpy(root, dir_root, offsetof(struct INDEX_ROOT, ihdr));\n\t\troot->ihdr.de_off =\n\t\t\tcpu_to_le32(sizeof(struct INDEX_HDR)); // 0x10\n\t\troot->ihdr.used = cpu_to_le32(sizeof(struct INDEX_HDR) +\n\t\t\t\t\t      sizeof(struct NTFS_DE));\n\t\troot->ihdr.total = root->ihdr.used;\n\n\t\te = Add2Ptr(root, sizeof(struct INDEX_ROOT));\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST;\n\t} else if (S_ISLNK(mode)) {\n\t\t/*\n\t\t * Symlink to file.\n\t\t * Create empty resident data attribute.\n\t\t */\n\t\tasize = SIZEOF_RESIDENT;\n\n\t\t/* Insert empty ATTR_DATA */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t} else if (S_ISREG(mode)) {\n\t\t/*\n\t\t * Regular file. Create empty non resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->non_res = 1;\n\t\tattr->nres.evcn = cpu_to_le64(-1ll);\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tasize = SIZEOF_NONRESIDENT + 8;\n\t\t}\n\t\tattr->nres.run_off = attr->name_off;\n\t} else {\n\t\t/*\n\t\t * Node. Create empty resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\telse if (fa & FILE_ATTRIBUTE_COMPRESSED)\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tasize = SIZEOF_RESIDENT;\n\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out4;\n\t} else if (S_ISLNK(mode)) {\n\t\trp = ntfs_create_reparse_buffer(sbi, symname, size, &nsize);\n\n\t\tif (IS_ERR(rp)) {\n\t\t\terr = PTR_ERR(rp);\n\t\t\trp = NULL;\n\t\t\tgoto out4;\n\t\t}\n\n\t\t/*\n\t\t * Insert ATTR_REPARSE.\n\t\t */\n\t\tattr = Add2Ptr(attr, asize);\n\t\tattr->type = ATTR_REPARSE;\n\t\tattr->id = cpu_to_le16(aid++);\n\n\t\t/* Resident or non resident? */\n\t\tasize = ALIGN(SIZEOF_RESIDENT + nsize, 8);\n\t\tt16 = PtrOffset(rec, attr);\n\n\t\t/*\n\t\t * Below function 'ntfs_save_wsl_perm' requires 0x78 bytes.\n\t\t * It is good idea to keep extened attributes resident.\n\t\t */\n\t\tif (asize + t16 + 0x78 + 8 > sbi->record_size) {\n\t\t\tCLST alen;\n\t\t\tCLST clst = bytes_to_cluster(sbi, nsize);\n\n\t\t\t/* Bytes per runs. */\n\t\t\tt16 = sbi->record_size - t16 - SIZEOF_NONRESIDENT;\n\n\t\t\tattr->non_res = 1;\n\t\t\tattr->nres.evcn = cpu_to_le64(clst - 1);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tattr->nres.run_off = attr->name_off;\n\t\t\tattr->nres.data_size = cpu_to_le64(nsize);\n\t\t\tattr->nres.valid_size = attr->nres.data_size;\n\t\t\tattr->nres.alloc_size =\n\t\t\t\tcpu_to_le64(ntfs_up_cluster(sbi, nsize));\n\n\t\t\terr = attr_allocate_clusters(sbi, &ni->file.run, 0, 0,\n\t\t\t\t\t\t     clst, NULL, ALLOCATE_DEF,\n\t\t\t\t\t\t     &alen, 0, NULL, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out5;\n\n\t\t\terr = run_pack(&ni->file.run, 0, clst,\n\t\t\t\t       Add2Ptr(attr, SIZEOF_NONRESIDENT), t16,\n\t\t\t\t       &vcn);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out5;\n\n\t\t\tif (vcn != clst) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out5;\n\t\t\t}\n\n\t\t\tasize = SIZEOF_NONRESIDENT + ALIGN(err, 8);\n\t\t} else {\n\t\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\t\tattr->res.data_size = cpu_to_le32(nsize);\n\t\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), rp, nsize);\n\t\t\tnsize = 0;\n\t\t}\n\t\t/* Size of symlink equals the length of input string. */\n\t\tinode->i_size = size;\n\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\terr = ntfs_insert_reparse(sbi, IO_REPARSE_TAG_SYMLINK,\n\t\t\t\t\t  &new_de->ref);\n\t\tif (err)\n\t\t\tgoto out5;\n\n\t\trp_inserted = true;\n\t}\n\n\tattr = Add2Ptr(attr, asize);\n\tattr->type = ATTR_END;\n\n\trec->used = cpu_to_le32(PtrOffset(rec, attr) + 8);\n\trec->next_attr_id = cpu_to_le16(aid);\n\n\t/* Step 2: Add new name in index. */\n\terr = indx_insert_entry(&dir_ni->dir, dir_ni, new_de, sbi, fnd, 0);\n\tif (err)\n\t\tgoto out6;\n\n\t/* Unlock parent directory before ntfs_init_acl. */\n\tif (!fnd)\n\t\tni_unlock(dir_ni);\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\tdir->i_mtime = dir->i_ctime = inode->i_atime;\n\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode->i_mapping->a_ops = &ntfs_aops;\n\t\tinode->i_size = size;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tinit_rwsem(&ni->file.run_lock);\n\t} else {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, dev);\n\t}\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\tif (!S_ISLNK(mode) && (sb->s_flags & SB_POSIXACL)) {\n\t\terr = ntfs_init_acl(mnt_userns, inode, dir);\n\t\tif (err)\n\t\t\tgoto out7;\n\t} else\n#endif\n\t{\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\t/* Write non resident data. */\n\tif (nsize) {\n\t\terr = ntfs_sb_write_run(sbi, &ni->file.run, 0, rp, nsize, 0);\n\t\tif (err)\n\t\t\tgoto out7;\n\t}\n\n\t/*\n\t * Call 'd_instantiate' after inode->i_op is set\n\t * but before finish_open.\n\t */\n\td_instantiate(dentry, inode);\n\n\tntfs_save_wsl_perm(inode);\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\t/* Normal exit. */\n\tgoto out2;\n\nout7:\n\n\t/* Undo 'indx_insert_entry'. */\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\tindx_delete_entry(&dir_ni->dir, dir_ni, new_de + 1,\n\t\t\t  le16_to_cpu(new_de->key_size), sbi);\n\t/* ni_unlock(dir_ni); will be called later. */\nout6:\n\tif (rp_inserted)\n\t\tntfs_remove_reparse(sbi, IO_REPARSE_TAG_SYMLINK, &new_de->ref);\n\nout5:\n\tif (!S_ISDIR(mode))\n\t\trun_deallocate(sbi, &ni->file.run, false);\n\nout4:\n\tclear_rec_inuse(rec);\n\tclear_nlink(inode);\n\tni->mi.dirty = false;\n\tdiscard_new_inode(inode);\nout3:\n\tntfs_mark_rec_free(sbi, ino, false);\n\nout2:\n\t__putname(new_de);\n\tkfree(rp);\n\nout1:\n\tif (err) {\n\t\tif (!fnd)\n\t\t\tni_unlock(dir_ni);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstruct inode *ntfs_iget5(struct super_block *sb, const struct MFT_REF *ref,\n\t\t\t const struct cpu_str *name)\n{\n\tstruct inode *inode;\n\n\tinode = iget5_locked(sb, ino_get(ref), ntfs_test_inode, ntfs_set_inode,\n\t\t\t     (void *)ref);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (inode->i_state & I_NEW)\n\t\tinode = ntfs_read_mft(inode, name, ref);\n\telse if (ref->seq != ntfs_i(inode)->mi.mrec->seq) {\n\t\t/* Inode overlaps? */\n\t\t_ntfs_bad_inode(inode);\n\t}\n\n\tif (IS_ERR(inode) && name)\n\t\tntfs_set_state(sb->s_fs_info, NTFS_DIRTY_ERROR);\n\n\treturn inode;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstruct inode *ntfs_create_inode(struct user_namespace *mnt_userns,\n\t\t\t\tstruct inode *dir, struct dentry *dentry,\n\t\t\t\tconst struct cpu_str *uni, umode_t mode,\n\t\t\t\tdev_t dev, const char *symname, u32 size,\n\t\t\t\tstruct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tconst struct qstr *name = &dentry->d_name;\n\tCLST ino = 0;\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct ntfs_inode *ni = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_STD_INFO5 *std5;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct MFT_REC *rec;\n\tu32 asize, dsize, sd_size;\n\tenum FILE_ATTRIBUTE fa;\n\t__le32 security_id = SECURITY_ID_INVALID;\n\tCLST vcn;\n\tconst void *sd;\n\tu16 t16, nsize = 0, aid = 0;\n\tstruct INDEX_ROOT *root, *dir_root;\n\tstruct NTFS_DE *e, *new_de = NULL;\n\tstruct REPARSE_DATA_BUFFER *rp = NULL;\n\tbool rp_inserted = false;\n\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\n\tdir_root = indx_get_root(&dir_ni->dir, dir_ni, NULL, NULL);\n\tif (!dir_root) {\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\t/* Use parent's directory attributes. */\n\t\tfa = dir_ni->std_fa | FILE_ATTRIBUTE_DIRECTORY |\n\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t/*\n\t\t * By default child directory inherits parent attributes.\n\t\t * Root directory is hidden + system.\n\t\t * Make an exception for children in root.\n\t\t */\n\t\tif (dir->i_ino == MFT_REC_ROOT)\n\t\t\tfa &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);\n\t} else if (S_ISLNK(mode)) {\n\t\t/* It is good idea that link should be the same type (file/dir) as target */\n\t\tfa = FILE_ATTRIBUTE_REPARSE_POINT;\n\n\t\t/*\n\t\t * Linux: there are dir/file/symlink and so on.\n\t\t * NTFS: symlinks are \"dir + reparse\" or \"file + reparse\"\n\t\t * It is good idea to create:\n\t\t * dir + reparse if 'symname' points to directory\n\t\t * or\n\t\t * file + reparse if 'symname' points to file\n\t\t * Unfortunately kern_path hangs if symname contains 'dir'.\n\t\t */\n\n\t\t/*\n\t\t *\tstruct path path;\n\t\t *\n\t\t *\tif (!kern_path(symname, LOOKUP_FOLLOW, &path)){\n\t\t *\t\tstruct inode *target = d_inode(path.dentry);\n\t\t *\n\t\t *\t\tif (S_ISDIR(target->i_mode))\n\t\t *\t\t\tfa |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t *\t\t// if ( target->i_sb == sb ){\n\t\t *\t\t//\tuse relative path?\n\t\t *\t\t// }\n\t\t *\t\tpath_put(&path);\n\t\t *\t}\n\t\t */\n\t} else if (S_ISREG(mode)) {\n\t\tif (sbi->options->sparse) {\n\t\t\t/* Sparsed regular file, cause option 'sparse'. */\n\t\t\tfa = FILE_ATTRIBUTE_SPARSE_FILE |\n\t\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\t/* Compressed regular file, if parent is compressed. */\n\t\t\tfa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else {\n\t\t\t/* Regular file, default attributes. */\n\t\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t\t}\n\t} else {\n\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t}\n\n\t/* If option \"hide_dot_files\" then set hidden attribute for dot files. */\n\tif (sbi->options->hide_dot_files && name->name[0] == '.')\n\t\tfa |= FILE_ATTRIBUTE_HIDDEN;\n\n\tif (!(mode & 0222))\n\t\tfa |= FILE_ATTRIBUTE_READONLY;\n\n\t/* Allocate PATH_MAX bytes. */\n\tnew_de = __getname();\n\tif (!new_de) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Mark rw ntfs as dirty. it will be cleared at umount. */\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t/* Step 1: allocate and fill new mft record. */\n\terr = ntfs_look_free_mft(sbi, &ino, false, NULL, NULL);\n\tif (err)\n\t\tgoto out2;\n\n\tni = ntfs_new_inode(sbi, ino, fa & FILE_ATTRIBUTE_DIRECTORY);\n\tif (IS_ERR(ni)) {\n\t\terr = PTR_ERR(ni);\n\t\tni = NULL;\n\t\tgoto out3;\n\t}\n\tinode = &ni->vfs_inode;\n\tinode_init_owner(mnt_userns, inode, dir, mode);\n\tmode = inode->i_mode;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = ni->i_crtime =\n\t\tcurrent_time(inode);\n\n\trec = ni->mi.mrec;\n\trec->hard_links = cpu_to_le16(1);\n\tattr = Add2Ptr(rec, le16_to_cpu(rec->attr_off));\n\n\t/* Get default security id. */\n\tsd = s_default_security;\n\tsd_size = sizeof(s_default_security);\n\n\tif (is_ntfs3(sbi)) {\n\t\tsecurity_id = dir_ni->std_security_id;\n\t\tif (le32_to_cpu(security_id) < SECURITY_ID_FIRST) {\n\t\t\tsecurity_id = sbi->security.def_security_id;\n\n\t\t\tif (security_id == SECURITY_ID_INVALID &&\n\t\t\t    !ntfs_insert_security(sbi, sd, sd_size,\n\t\t\t\t\t\t  &security_id, NULL))\n\t\t\t\tsbi->security.def_security_id = security_id;\n\t\t}\n\t}\n\n\t/* Insert standard info. */\n\tstd5 = Add2Ptr(attr, SIZEOF_RESIDENT);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\tdsize = sizeof(struct ATTR_STD_INFO);\n\t} else {\n\t\tdsize = sizeof(struct ATTR_STD_INFO5);\n\t\tstd5->security_id = security_id;\n\t\tni->std_security_id = security_id;\n\t}\n\tasize = SIZEOF_RESIDENT + dsize;\n\n\tattr->type = ATTR_STD;\n\tattr->size = cpu_to_le32(asize);\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.data_size = cpu_to_le32(dsize);\n\n\tstd5->cr_time = std5->m_time = std5->c_time = std5->a_time =\n\t\tkernel2nt(&inode->i_atime);\n\n\tni->std_fa = fa;\n\tstd5->fa = fa;\n\n\tattr = Add2Ptr(attr, asize);\n\n\t/* Insert file name. */\n\terr = fill_name_de(sbi, new_de, name, uni);\n\tif (err)\n\t\tgoto out4;\n\n\tmi_get_ref(&ni->mi, &new_de->ref);\n\n\tfname = (struct ATTR_FILE_NAME *)(new_de + 1);\n\n\tif (sbi->options->windows_names &&\n\t    !valid_windows_name(sbi, (struct le_str *)&fname->name_len)) {\n\t\terr = -EINVAL;\n\t\tgoto out4;\n\t}\n\n\tmi_get_ref(&dir_ni->mi, &fname->home);\n\tfname->dup.cr_time = fname->dup.m_time = fname->dup.c_time =\n\t\tfname->dup.a_time = std5->cr_time;\n\tfname->dup.alloc_size = fname->dup.data_size = 0;\n\tfname->dup.fa = std5->fa;\n\tfname->dup.ea_size = fname->dup.reparse = 0;\n\n\tdsize = le16_to_cpu(new_de->key_size);\n\tasize = ALIGN(SIZEOF_RESIDENT + dsize, 8);\n\n\tattr->type = ATTR_NAME;\n\tattr->size = cpu_to_le32(asize);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.flags = RESIDENT_FLAG_INDEXED;\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_size = cpu_to_le32(dsize);\n\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), fname, dsize);\n\n\tattr = Add2Ptr(attr, asize);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\t/* Insert security attribute. */\n\t\tasize = SIZEOF_RESIDENT + ALIGN(sd_size, 8);\n\n\t\tattr->type = ATTR_SECURE;\n\t\tattr->size = cpu_to_le32(asize);\n\t\tattr->id = cpu_to_le16(aid++);\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_size = cpu_to_le32(sd_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), sd, sd_size);\n\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\tattr->id = cpu_to_le16(aid++);\n\tif (fa & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t/*\n\t\t * Regular directory or symlink to directory.\n\t\t * Create root attribute.\n\t\t */\n\t\tdsize = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE);\n\t\tasize = sizeof(I30_NAME) + SIZEOF_RESIDENT + dsize;\n\n\t\tattr->type = ATTR_ROOT;\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\tattr->name_len = ARRAY_SIZE(I30_NAME);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off =\n\t\t\tcpu_to_le16(sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tattr->res.data_size = cpu_to_le32(dsize);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), I30_NAME,\n\t\t       sizeof(I30_NAME));\n\n\t\troot = Add2Ptr(attr, sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tmemcpy(root, dir_root, offsetof(struct INDEX_ROOT, ihdr));\n\t\troot->ihdr.de_off =\n\t\t\tcpu_to_le32(sizeof(struct INDEX_HDR)); // 0x10\n\t\troot->ihdr.used = cpu_to_le32(sizeof(struct INDEX_HDR) +\n\t\t\t\t\t      sizeof(struct NTFS_DE));\n\t\troot->ihdr.total = root->ihdr.used;\n\n\t\te = Add2Ptr(root, sizeof(struct INDEX_ROOT));\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST;\n\t} else if (S_ISLNK(mode)) {\n\t\t/*\n\t\t * Symlink to file.\n\t\t * Create empty resident data attribute.\n\t\t */\n\t\tasize = SIZEOF_RESIDENT;\n\n\t\t/* Insert empty ATTR_DATA */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t} else if (S_ISREG(mode)) {\n\t\t/*\n\t\t * Regular file. Create empty non resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->non_res = 1;\n\t\tattr->nres.evcn = cpu_to_le64(-1ll);\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tasize = SIZEOF_NONRESIDENT + 8;\n\t\t}\n\t\tattr->nres.run_off = attr->name_off;\n\t} else {\n\t\t/*\n\t\t * Node. Create empty resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\telse if (fa & FILE_ATTRIBUTE_COMPRESSED)\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tasize = SIZEOF_RESIDENT;\n\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out4;\n\t} else if (S_ISLNK(mode)) {\n\t\trp = ntfs_create_reparse_buffer(sbi, symname, size, &nsize);\n\n\t\tif (IS_ERR(rp)) {\n\t\t\terr = PTR_ERR(rp);\n\t\t\trp = NULL;\n\t\t\tgoto out4;\n\t\t}\n\n\t\t/*\n\t\t * Insert ATTR_REPARSE.\n\t\t */\n\t\tattr = Add2Ptr(attr, asize);\n\t\tattr->type = ATTR_REPARSE;\n\t\tattr->id = cpu_to_le16(aid++);\n\n\t\t/* Resident or non resident? */\n\t\tasize = ALIGN(SIZEOF_RESIDENT + nsize, 8);\n\t\tt16 = PtrOffset(rec, attr);\n\n\t\t/*\n\t\t * Below function 'ntfs_save_wsl_perm' requires 0x78 bytes.\n\t\t * It is good idea to keep extened attributes resident.\n\t\t */\n\t\tif (asize + t16 + 0x78 + 8 > sbi->record_size) {\n\t\t\tCLST alen;\n\t\t\tCLST clst = bytes_to_cluster(sbi, nsize);\n\n\t\t\t/* Bytes per runs. */\n\t\t\tt16 = sbi->record_size - t16 - SIZEOF_NONRESIDENT;\n\n\t\t\tattr->non_res = 1;\n\t\t\tattr->nres.evcn = cpu_to_le64(clst - 1);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tattr->nres.run_off = attr->name_off;\n\t\t\tattr->nres.data_size = cpu_to_le64(nsize);\n\t\t\tattr->nres.valid_size = attr->nres.data_size;\n\t\t\tattr->nres.alloc_size =\n\t\t\t\tcpu_to_le64(ntfs_up_cluster(sbi, nsize));\n\n\t\t\terr = attr_allocate_clusters(sbi, &ni->file.run, 0, 0,\n\t\t\t\t\t\t     clst, NULL, ALLOCATE_DEF,\n\t\t\t\t\t\t     &alen, 0, NULL, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out5;\n\n\t\t\terr = run_pack(&ni->file.run, 0, clst,\n\t\t\t\t       Add2Ptr(attr, SIZEOF_NONRESIDENT), t16,\n\t\t\t\t       &vcn);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out5;\n\n\t\t\tif (vcn != clst) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out5;\n\t\t\t}\n\n\t\t\tasize = SIZEOF_NONRESIDENT + ALIGN(err, 8);\n\t\t} else {\n\t\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\t\tattr->res.data_size = cpu_to_le32(nsize);\n\t\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), rp, nsize);\n\t\t\tnsize = 0;\n\t\t}\n\t\t/* Size of symlink equals the length of input string. */\n\t\tinode->i_size = size;\n\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\terr = ntfs_insert_reparse(sbi, IO_REPARSE_TAG_SYMLINK,\n\t\t\t\t\t  &new_de->ref);\n\t\tif (err)\n\t\t\tgoto out5;\n\n\t\trp_inserted = true;\n\t}\n\n\tattr = Add2Ptr(attr, asize);\n\tattr->type = ATTR_END;\n\n\trec->used = cpu_to_le32(PtrOffset(rec, attr) + 8);\n\trec->next_attr_id = cpu_to_le16(aid);\n\n\t/* Step 2: Add new name in index. */\n\terr = indx_insert_entry(&dir_ni->dir, dir_ni, new_de, sbi, fnd, 0);\n\tif (err)\n\t\tgoto out6;\n\n\t/* Unlock parent directory before ntfs_init_acl. */\n\tif (!fnd)\n\t\tni_unlock(dir_ni);\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\tdir->i_mtime = dir->i_ctime = inode->i_atime;\n\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode->i_mapping->a_ops = &ntfs_aops;\n\t\tinode->i_size = size;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tinit_rwsem(&ni->file.run_lock);\n\t} else {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, dev);\n\t}\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\tif (!S_ISLNK(mode) && (sb->s_flags & SB_POSIXACL)) {\n\t\terr = ntfs_init_acl(mnt_userns, inode, dir);\n\t\tif (err)\n\t\t\tgoto out7;\n\t} else\n#endif\n\t{\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\t/* Write non resident data. */\n\tif (nsize) {\n\t\terr = ntfs_sb_write_run(sbi, &ni->file.run, 0, rp, nsize, 0);\n\t\tif (err)\n\t\t\tgoto out7;\n\t}\n\n\t/*\n\t * Call 'd_instantiate' after inode->i_op is set\n\t * but before finish_open.\n\t */\n\td_instantiate(dentry, inode);\n\n\tntfs_save_wsl_perm(inode);\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\t/* Normal exit. */\n\tgoto out2;\n\nout7:\n\n\t/* Undo 'indx_insert_entry'. */\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\tindx_delete_entry(&dir_ni->dir, dir_ni, new_de + 1,\n\t\t\t  le16_to_cpu(new_de->key_size), sbi);\n\t/* ni_unlock(dir_ni); will be called later. */\nout6:\n\tif (rp_inserted)\n\t\tntfs_remove_reparse(sbi, IO_REPARSE_TAG_SYMLINK, &new_de->ref);\n\nout5:\n\tif (S_ISDIR(mode) || run_is_empty(&ni->file.run))\n\t\tgoto out4;\n\n\trun_deallocate(sbi, &ni->file.run, false);\n\nout4:\n\tclear_rec_inuse(rec);\n\tclear_nlink(inode);\n\tni->mi.dirty = false;\n\tdiscard_new_inode(inode);\nout3:\n\tntfs_mark_rec_free(sbi, ino, false);\n\nout2:\n\t__putname(new_de);\n\tkfree(rp);\n\nout1:\n\tif (err) {\n\t\tif (!fnd)\n\t\t\tni_unlock(dir_ni);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstruct inode *ntfs_create_inode(struct user_namespace *mnt_userns,\n\t\t\t\tstruct inode *dir, struct dentry *dentry,\n\t\t\t\tconst struct cpu_str *uni, umode_t mode,\n\t\t\t\tdev_t dev, const char *symname, u32 size,\n\t\t\t\tstruct ntfs_fnd *fnd)\n{\n\tint err;\n\tstruct super_block *sb = dir->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tconst struct qstr *name = &dentry->d_name;\n\tCLST ino = 0;\n\tstruct ntfs_inode *dir_ni = ntfs_i(dir);\n\tstruct ntfs_inode *ni = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_STD_INFO5 *std5;\n\tstruct ATTR_FILE_NAME *fname;\n\tstruct MFT_REC *rec;\n\tu32 asize, dsize, sd_size;\n\tenum FILE_ATTRIBUTE fa;\n\t__le32 security_id = SECURITY_ID_INVALID;\n\tCLST vcn;\n\tconst void *sd;\n\tu16 t16, nsize = 0, aid = 0;\n\tstruct INDEX_ROOT *root, *dir_root;\n\tstruct NTFS_DE *e, *new_de = NULL;\n\tstruct REPARSE_DATA_BUFFER *rp = NULL;\n\tbool rp_inserted = false;\n\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\n\tdir_root = indx_get_root(&dir_ni->dir, dir_ni, NULL, NULL);\n\tif (!dir_root) {\n\t\terr = -EINVAL;\n\t\tgoto out1;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\t/* Use parent's directory attributes. */\n\t\tfa = dir_ni->std_fa | FILE_ATTRIBUTE_DIRECTORY |\n\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t/*\n\t\t * By default child directory inherits parent attributes.\n\t\t * Root directory is hidden + system.\n\t\t * Make an exception for children in root.\n\t\t */\n\t\tif (dir->i_ino == MFT_REC_ROOT)\n\t\t\tfa &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);\n\t} else if (S_ISLNK(mode)) {\n\t\t/* It is good idea that link should be the same type (file/dir) as target */\n\t\tfa = FILE_ATTRIBUTE_REPARSE_POINT;\n\n\t\t/*\n\t\t * Linux: there are dir/file/symlink and so on.\n\t\t * NTFS: symlinks are \"dir + reparse\" or \"file + reparse\"\n\t\t * It is good idea to create:\n\t\t * dir + reparse if 'symname' points to directory\n\t\t * or\n\t\t * file + reparse if 'symname' points to file\n\t\t * Unfortunately kern_path hangs if symname contains 'dir'.\n\t\t */\n\n\t\t/*\n\t\t *\tstruct path path;\n\t\t *\n\t\t *\tif (!kern_path(symname, LOOKUP_FOLLOW, &path)){\n\t\t *\t\tstruct inode *target = d_inode(path.dentry);\n\t\t *\n\t\t *\t\tif (S_ISDIR(target->i_mode))\n\t\t *\t\t\tfa |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t *\t\t// if ( target->i_sb == sb ){\n\t\t *\t\t//\tuse relative path?\n\t\t *\t\t// }\n\t\t *\t\tpath_put(&path);\n\t\t *\t}\n\t\t */\n\t} else if (S_ISREG(mode)) {\n\t\tif (sbi->options->sparse) {\n\t\t\t/* Sparsed regular file, cause option 'sparse'. */\n\t\t\tfa = FILE_ATTRIBUTE_SPARSE_FILE |\n\t\t\t     FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else if (dir_ni->std_fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\t/* Compressed regular file, if parent is compressed. */\n\t\t\tfa = FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_ARCHIVE;\n\t\t} else {\n\t\t\t/* Regular file, default attributes. */\n\t\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t\t}\n\t} else {\n\t\tfa = FILE_ATTRIBUTE_ARCHIVE;\n\t}\n\n\t/* If option \"hide_dot_files\" then set hidden attribute for dot files. */\n\tif (sbi->options->hide_dot_files && name->name[0] == '.')\n\t\tfa |= FILE_ATTRIBUTE_HIDDEN;\n\n\tif (!(mode & 0222))\n\t\tfa |= FILE_ATTRIBUTE_READONLY;\n\n\t/* Allocate PATH_MAX bytes. */\n\tnew_de = __getname();\n\tif (!new_de) {\n\t\terr = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Mark rw ntfs as dirty. it will be cleared at umount. */\n\tntfs_set_state(sbi, NTFS_DIRTY_DIRTY);\n\n\t/* Step 1: allocate and fill new mft record. */\n\terr = ntfs_look_free_mft(sbi, &ino, false, NULL, NULL);\n\tif (err)\n\t\tgoto out2;\n\n\tni = ntfs_new_inode(sbi, ino, fa & FILE_ATTRIBUTE_DIRECTORY);\n\tif (IS_ERR(ni)) {\n\t\terr = PTR_ERR(ni);\n\t\tni = NULL;\n\t\tgoto out3;\n\t}\n\tinode = &ni->vfs_inode;\n\tinode_init_owner(mnt_userns, inode, dir, mode);\n\tmode = inode->i_mode;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = ni->i_crtime =\n\t\tcurrent_time(inode);\n\n\trec = ni->mi.mrec;\n\trec->hard_links = cpu_to_le16(1);\n\tattr = Add2Ptr(rec, le16_to_cpu(rec->attr_off));\n\n\t/* Get default security id. */\n\tsd = s_default_security;\n\tsd_size = sizeof(s_default_security);\n\n\tif (is_ntfs3(sbi)) {\n\t\tsecurity_id = dir_ni->std_security_id;\n\t\tif (le32_to_cpu(security_id) < SECURITY_ID_FIRST) {\n\t\t\tsecurity_id = sbi->security.def_security_id;\n\n\t\t\tif (security_id == SECURITY_ID_INVALID &&\n\t\t\t    !ntfs_insert_security(sbi, sd, sd_size,\n\t\t\t\t\t\t  &security_id, NULL))\n\t\t\t\tsbi->security.def_security_id = security_id;\n\t\t}\n\t}\n\n\t/* Insert standard info. */\n\tstd5 = Add2Ptr(attr, SIZEOF_RESIDENT);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\tdsize = sizeof(struct ATTR_STD_INFO);\n\t} else {\n\t\tdsize = sizeof(struct ATTR_STD_INFO5);\n\t\tstd5->security_id = security_id;\n\t\tni->std_security_id = security_id;\n\t}\n\tasize = SIZEOF_RESIDENT + dsize;\n\n\tattr->type = ATTR_STD;\n\tattr->size = cpu_to_le32(asize);\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.data_size = cpu_to_le32(dsize);\n\n\tstd5->cr_time = std5->m_time = std5->c_time = std5->a_time =\n\t\tkernel2nt(&inode->i_atime);\n\n\tni->std_fa = fa;\n\tstd5->fa = fa;\n\n\tattr = Add2Ptr(attr, asize);\n\n\t/* Insert file name. */\n\terr = fill_name_de(sbi, new_de, name, uni);\n\tif (err)\n\t\tgoto out4;\n\n\tmi_get_ref(&ni->mi, &new_de->ref);\n\n\tfname = (struct ATTR_FILE_NAME *)(new_de + 1);\n\n\tif (sbi->options->windows_names &&\n\t    !valid_windows_name(sbi, (struct le_str *)&fname->name_len)) {\n\t\terr = -EINVAL;\n\t\tgoto out4;\n\t}\n\n\tmi_get_ref(&dir_ni->mi, &fname->home);\n\tfname->dup.cr_time = fname->dup.m_time = fname->dup.c_time =\n\t\tfname->dup.a_time = std5->cr_time;\n\tfname->dup.alloc_size = fname->dup.data_size = 0;\n\tfname->dup.fa = std5->fa;\n\tfname->dup.ea_size = fname->dup.reparse = 0;\n\n\tdsize = le16_to_cpu(new_de->key_size);\n\tasize = ALIGN(SIZEOF_RESIDENT + dsize, 8);\n\n\tattr->type = ATTR_NAME;\n\tattr->size = cpu_to_le32(asize);\n\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\tattr->res.flags = RESIDENT_FLAG_INDEXED;\n\tattr->id = cpu_to_le16(aid++);\n\tattr->res.data_size = cpu_to_le32(dsize);\n\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), fname, dsize);\n\n\tattr = Add2Ptr(attr, asize);\n\n\tif (security_id == SECURITY_ID_INVALID) {\n\t\t/* Insert security attribute. */\n\t\tasize = SIZEOF_RESIDENT + ALIGN(sd_size, 8);\n\n\t\tattr->type = ATTR_SECURE;\n\t\tattr->size = cpu_to_le32(asize);\n\t\tattr->id = cpu_to_le16(aid++);\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_size = cpu_to_le32(sd_size);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), sd, sd_size);\n\n\t\tattr = Add2Ptr(attr, asize);\n\t}\n\n\tattr->id = cpu_to_le16(aid++);\n\tif (fa & FILE_ATTRIBUTE_DIRECTORY) {\n\t\t/*\n\t\t * Regular directory or symlink to directory.\n\t\t * Create root attribute.\n\t\t */\n\t\tdsize = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE);\n\t\tasize = sizeof(I30_NAME) + SIZEOF_RESIDENT + dsize;\n\n\t\tattr->type = ATTR_ROOT;\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\tattr->name_len = ARRAY_SIZE(I30_NAME);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off =\n\t\t\tcpu_to_le16(sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tattr->res.data_size = cpu_to_le32(dsize);\n\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), I30_NAME,\n\t\t       sizeof(I30_NAME));\n\n\t\troot = Add2Ptr(attr, sizeof(I30_NAME) + SIZEOF_RESIDENT);\n\t\tmemcpy(root, dir_root, offsetof(struct INDEX_ROOT, ihdr));\n\t\troot->ihdr.de_off =\n\t\t\tcpu_to_le32(sizeof(struct INDEX_HDR)); // 0x10\n\t\troot->ihdr.used = cpu_to_le32(sizeof(struct INDEX_HDR) +\n\t\t\t\t\t      sizeof(struct NTFS_DE));\n\t\troot->ihdr.total = root->ihdr.used;\n\n\t\te = Add2Ptr(root, sizeof(struct INDEX_ROOT));\n\t\te->size = cpu_to_le16(sizeof(struct NTFS_DE));\n\t\te->flags = NTFS_IE_LAST;\n\t} else if (S_ISLNK(mode)) {\n\t\t/*\n\t\t * Symlink to file.\n\t\t * Create empty resident data attribute.\n\t\t */\n\t\tasize = SIZEOF_RESIDENT;\n\n\t\t/* Insert empty ATTR_DATA */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t} else if (S_ISREG(mode)) {\n\t\t/*\n\t\t * Regular file. Create empty non resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->non_res = 1;\n\t\tattr->nres.evcn = cpu_to_le64(-1ll);\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else if (fa & FILE_ATTRIBUTE_COMPRESSED) {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT_EX + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_EX_LE;\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\t\tattr->nres.c_unit = COMPRESSION_UNIT;\n\t\t\tasize = SIZEOF_NONRESIDENT_EX + 8;\n\t\t} else {\n\t\t\tattr->size = cpu_to_le32(SIZEOF_NONRESIDENT + 8);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tasize = SIZEOF_NONRESIDENT + 8;\n\t\t}\n\t\tattr->nres.run_off = attr->name_off;\n\t} else {\n\t\t/*\n\t\t * Node. Create empty resident data attribute.\n\t\t */\n\t\tattr->type = ATTR_DATA;\n\t\tattr->size = cpu_to_le32(SIZEOF_RESIDENT);\n\t\tattr->name_off = SIZEOF_RESIDENT_LE;\n\t\tif (fa & FILE_ATTRIBUTE_SPARSE_FILE)\n\t\t\tattr->flags = ATTR_FLAG_SPARSED;\n\t\telse if (fa & FILE_ATTRIBUTE_COMPRESSED)\n\t\t\tattr->flags = ATTR_FLAG_COMPRESSED;\n\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\tasize = SIZEOF_RESIDENT;\n\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t}\n\n\tif (S_ISDIR(mode)) {\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out4;\n\t} else if (S_ISLNK(mode)) {\n\t\trp = ntfs_create_reparse_buffer(sbi, symname, size, &nsize);\n\n\t\tif (IS_ERR(rp)) {\n\t\t\terr = PTR_ERR(rp);\n\t\t\trp = NULL;\n\t\t\tgoto out4;\n\t\t}\n\n\t\t/*\n\t\t * Insert ATTR_REPARSE.\n\t\t */\n\t\tattr = Add2Ptr(attr, asize);\n\t\tattr->type = ATTR_REPARSE;\n\t\tattr->id = cpu_to_le16(aid++);\n\n\t\t/* Resident or non resident? */\n\t\tasize = ALIGN(SIZEOF_RESIDENT + nsize, 8);\n\t\tt16 = PtrOffset(rec, attr);\n\n\t\t/*\n\t\t * Below function 'ntfs_save_wsl_perm' requires 0x78 bytes.\n\t\t * It is good idea to keep extened attributes resident.\n\t\t */\n\t\tif (asize + t16 + 0x78 + 8 > sbi->record_size) {\n\t\t\tCLST alen;\n\t\t\tCLST clst = bytes_to_cluster(sbi, nsize);\n\n\t\t\t/* Bytes per runs. */\n\t\t\tt16 = sbi->record_size - t16 - SIZEOF_NONRESIDENT;\n\n\t\t\tattr->non_res = 1;\n\t\t\tattr->nres.evcn = cpu_to_le64(clst - 1);\n\t\t\tattr->name_off = SIZEOF_NONRESIDENT_LE;\n\t\t\tattr->nres.run_off = attr->name_off;\n\t\t\tattr->nres.data_size = cpu_to_le64(nsize);\n\t\t\tattr->nres.valid_size = attr->nres.data_size;\n\t\t\tattr->nres.alloc_size =\n\t\t\t\tcpu_to_le64(ntfs_up_cluster(sbi, nsize));\n\n\t\t\terr = attr_allocate_clusters(sbi, &ni->file.run, 0, 0,\n\t\t\t\t\t\t     clst, NULL, ALLOCATE_DEF,\n\t\t\t\t\t\t     &alen, 0, NULL, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out5;\n\n\t\t\terr = run_pack(&ni->file.run, 0, clst,\n\t\t\t\t       Add2Ptr(attr, SIZEOF_NONRESIDENT), t16,\n\t\t\t\t       &vcn);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out5;\n\n\t\t\tif (vcn != clst) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out5;\n\t\t\t}\n\n\t\t\tasize = SIZEOF_NONRESIDENT + ALIGN(err, 8);\n\t\t} else {\n\t\t\tattr->res.data_off = SIZEOF_RESIDENT_LE;\n\t\t\tattr->res.data_size = cpu_to_le32(nsize);\n\t\t\tmemcpy(Add2Ptr(attr, SIZEOF_RESIDENT), rp, nsize);\n\t\t\tnsize = 0;\n\t\t}\n\t\t/* Size of symlink equals the length of input string. */\n\t\tinode->i_size = size;\n\n\t\tattr->size = cpu_to_le32(asize);\n\n\t\terr = ntfs_insert_reparse(sbi, IO_REPARSE_TAG_SYMLINK,\n\t\t\t\t\t  &new_de->ref);\n\t\tif (err)\n\t\t\tgoto out5;\n\n\t\trp_inserted = true;\n\t}\n\n\tattr = Add2Ptr(attr, asize);\n\tattr->type = ATTR_END;\n\n\trec->used = cpu_to_le32(PtrOffset(rec, attr) + 8);\n\trec->next_attr_id = cpu_to_le16(aid);\n\n\t/* Step 2: Add new name in index. */\n\terr = indx_insert_entry(&dir_ni->dir, dir_ni, new_de, sbi, fnd, 0);\n\tif (err)\n\t\tgoto out6;\n\n\t/* Unlock parent directory before ntfs_init_acl. */\n\tif (!fnd)\n\t\tni_unlock(dir_ni);\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\tdir->i_mtime = dir->i_ctime = inode->i_atime;\n\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode->i_mapping->a_ops = &ntfs_aops;\n\t\tinode->i_size = size;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tinit_rwsem(&ni->file.run_lock);\n\t} else {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, dev);\n\t}\n\n#ifdef CONFIG_NTFS3_FS_POSIX_ACL\n\tif (!S_ISLNK(mode) && (sb->s_flags & SB_POSIXACL)) {\n\t\terr = ntfs_init_acl(mnt_userns, inode, dir);\n\t\tif (err)\n\t\t\tgoto out7;\n\t} else\n#endif\n\t{\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\t/* Write non resident data. */\n\tif (nsize) {\n\t\terr = ntfs_sb_write_run(sbi, &ni->file.run, 0, rp, nsize, 0);\n\t\tif (err)\n\t\t\tgoto out7;\n\t}\n\n\t/*\n\t * Call 'd_instantiate' after inode->i_op is set\n\t * but before finish_open.\n\t */\n\td_instantiate(dentry, inode);\n\n\tntfs_save_wsl_perm(inode);\n\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\t/* Normal exit. */\n\tgoto out2;\n\nout7:\n\n\t/* Undo 'indx_insert_entry'. */\n\tif (!fnd)\n\t\tni_lock_dir(dir_ni);\n\tindx_delete_entry(&dir_ni->dir, dir_ni, new_de + 1,\n\t\t\t  le16_to_cpu(new_de->key_size), sbi);\n\t/* ni_unlock(dir_ni); will be called later. */\nout6:\n\tif (rp_inserted)\n\t\tntfs_remove_reparse(sbi, IO_REPARSE_TAG_SYMLINK, &new_de->ref);\n\nout5:\n\tif (!S_ISDIR(mode))\n\t\trun_deallocate(sbi, &ni->file.run, false);\n\nout4:\n\tclear_rec_inuse(rec);\n\tclear_nlink(inode);\n\tni->mi.dirty = false;\n\tdiscard_new_inode(inode);\nout3:\n\tntfs_mark_rec_free(sbi, ino, false);\n\nout2:\n\t__putname(new_de);\n\tkfree(rp);\n\nout1:\n\tif (err) {\n\t\tif (!fnd)\n\t\t\tni_unlock(dir_ni);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\n\tif (!sanity_check_inode(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto bad_inode;\n\t}\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (f2fs_encrypted_inode(inode))\n\t\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tf2fs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
                        "code_after_change": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (f2fs_encrypted_inode(inode))\n\t\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tf2fs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
                        "cve_id": "CVE-2018-13098"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstruct inode *ntfs_iget5(struct super_block *sb, const struct MFT_REF *ref,\n\t\t\t const struct cpu_str *name)\n{\n\tstruct inode *inode;\n\n\tinode = iget5_locked(sb, ino_get(ref), ntfs_test_inode, ntfs_set_inode,\n\t\t\t     (void *)ref);\n\tif (unlikely(!inode))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (inode->i_state & I_NEW)\n\t\tinode = ntfs_read_mft(inode, name, ref);\n\telse if (ref->seq != ntfs_i(inode)->mi.mrec->seq) {\n\t\t/* Inode overlaps? */\n\t\t_ntfs_bad_inode(inode);\n\t}\n\n\tif (IS_ERR(inode) && name)\n\t\tntfs_set_state(sb->s_fs_info, NTFS_DIRTY_ERROR);\n\n\treturn inode;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\n\tif (!sanity_check_inode(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto bad_inode;\n\t}\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (f2fs_encrypted_inode(inode))\n\t\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tf2fs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (f2fs_encrypted_inode(inode))\n\t\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tf2fs_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2309,
            "cve_id": "CVE-2019-3459",
            "code_snippet": "static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,\n\t\t\t\tvoid *data, size_t size, u16 *result)\n{\n\tstruct l2cap_conf_req *req = data;\n\tvoid *ptr = req->data;\n\tvoid *endptr = data + size;\n\tint type, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\n\tBT_DBG(\"chan %p, rsp %p, len %d, req %p\", chan, rsp, len, data);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (val < L2CAP_DEFAULT_MIN_MTU) {\n\t\t\t\t*result = L2CAP_CONF_UNACCEPT;\n\t\t\t\tchan->imtu = L2CAP_DEFAULT_MIN_MTU;\n\t\t\t} else\n\t\t\t\tchan->imtu = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu,\n\t\t\t\t\t   endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2,\n\t\t\t\t\t   chan->flush_to, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&\n\t\t\t    rfc.mode != chan->mode)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tchan->fcs = 0;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->ack_win = min_t(u16, val, chan->ack_win);\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\n\t\t\t\t\t   chan->tx_win, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&efs, (void *)val, olen);\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs),\n\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (*result == L2CAP_CONF_PENDING)\n\t\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\t\tset_bit(CONF_RECV_NO_FCS,\n\t\t\t\t\t\t&chan->conf_state);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)\n\t\treturn -ECONNREFUSED;\n\n\tchan->mode = rfc.mode;\n\n\tif (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tif (!test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t\t      rfc.txwin_size);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->local_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->local_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tchan->local_acc_lat = le32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->local_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t}\n\t}\n\n\treq->dcid   = cpu_to_le16(chan->dcid);\n\treq->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}",
                        "code_after_change": "static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}",
                        "cve_id": "CVE-2019-3459"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,\n\t\t\t\tvoid *data, size_t size, u16 *result)\n{\n\tstruct l2cap_conf_req *req = data;\n\tvoid *ptr = req->data;\n\tvoid *endptr = data + size;\n\tint type, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\n\tBT_DBG(\"chan %p, rsp %p, len %d, req %p\", chan, rsp, len, data);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (val < L2CAP_DEFAULT_MIN_MTU) {\n\t\t\t\t*result = L2CAP_CONF_UNACCEPT;\n\t\t\t\tchan->imtu = L2CAP_DEFAULT_MIN_MTU;\n\t\t\t} else\n\t\t\t\tchan->imtu = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu,\n\t\t\t\t\t   endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2,\n\t\t\t\t\t   chan->flush_to, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&\n\t\t\t    rfc.mode != chan->mode)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tchan->fcs = 0;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->ack_win = min_t(u16, val, chan->ack_win);\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\n\t\t\t\t\t   chan->tx_win, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&efs, (void *)val, olen);\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs),\n\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (*result == L2CAP_CONF_PENDING)\n\t\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\t\tset_bit(CONF_RECV_NO_FCS,\n\t\t\t\t\t\t&chan->conf_state);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)\n\t\treturn -ECONNREFUSED;\n\n\tchan->mode = rfc.mode;\n\n\tif (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tif (!test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t\t      rfc.txwin_size);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->local_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->local_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tchan->local_acc_lat = le32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->local_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t}\n\t}\n\n\treq->dcid   = cpu_to_le16(chan->dcid);\n\treq->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 4182,
            "cve_id": "CVE-2023-39194",
            "code_snippet": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t\t     xfrma_policy, cb->extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* see addr_match(), (prefix length >> 5) << 2\n\t\t\t * will be used to compare xfrm_address_t\n\t\t\t */\n\t\t\tif (filter->splen > (sizeof(xfrm_address_t) << 3) ||\n\t\t\t    filter->dplen > (sizeof(xfrm_address_t) << 3)) {\n\t\t\t\tkfree(filter);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct xfrm_address_filter *filter = NULL;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\n\t\tstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\n\n\t\tfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (filter == NULL) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tfilter->family = xfilter->sadb_x_filter_family;\n\t\tfilter->splen = xfilter->sadb_x_filter_splen;\n\t\tfilter->dplen = xfilter->sadb_x_filter_dplen;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}",
                        "code_after_change": "static int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct xfrm_address_filter *filter = NULL;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\n\t\tstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\n\n\t\tif ((xfilter->sadb_x_filter_splen >=\n\t\t\t(sizeof(xfrm_address_t) << 3)) ||\n\t\t    (xfilter->sadb_x_filter_dplen >=\n\t\t\t(sizeof(xfrm_address_t) << 3))) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (filter == NULL) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tfilter->family = xfilter->sadb_x_filter_family;\n\t\tfilter->splen = xfilter->sadb_x_filter_splen;\n\t\tfilter->dplen = xfilter->sadb_x_filter_dplen;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}",
                        "cve_id": "CVE-2021-0605"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t\t     xfrma_policy, cb->extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* see addr_match(), (prefix length >> 5) << 2\n\t\t\t * will be used to compare xfrm_address_t\n\t\t\t */\n\t\t\tif (filter->splen > (sizeof(xfrm_address_t) << 3) ||\n\t\t\t    filter->dplen > (sizeof(xfrm_address_t) << 3)) {\n\t\t\t\tkfree(filter);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct xfrm_address_filter *filter = NULL;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\n\t\tstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\n\n\t\tfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (filter == NULL) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tfilter->family = xfilter->sadb_x_filter_family;\n\t\tfilter->splen = xfilter->sadb_x_filter_splen;\n\t\tfilter->dplen = xfilter->sadb_x_filter_dplen;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tu8 proto;\n\tstruct xfrm_address_filter *filter = NULL;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\n\tmutex_lock(&pfk->dump_lock);\n\tif (pfk->dump.dump != NULL) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0) {\n\t\tmutex_unlock(&pfk->dump_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\n\t\tstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\n\n\t\tif ((xfilter->sadb_x_filter_splen >=\n\t\t\t(sizeof(xfrm_address_t) << 3)) ||\n\t\t    (xfilter->sadb_x_filter_dplen >=\n\t\t\t(sizeof(xfrm_address_t) << 3))) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (filter == NULL) {\n\t\t\tmutex_unlock(&pfk->dump_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tfilter->family = xfilter->sadb_x_filter_family;\n\t\tfilter->splen = xfilter->sadb_x_filter_splen;\n\t\tfilter->dplen = xfilter->sadb_x_filter_dplen;\n\t}\n\n\tpfk->dump.msg_version = hdr->sadb_msg_version;\n\tpfk->dump.msg_portid = hdr->sadb_msg_pid;\n\tpfk->dump.dump = pfkey_dump_sa;\n\tpfk->dump.done = pfkey_dump_sa_done;\n\txfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\n\tmutex_unlock(&pfk->dump_lock);\n\n\treturn pfkey_do_dump(pfk);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3793,
            "cve_id": "CVE-2022-48502",
            "code_snippet": "int indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,\n\t      struct indx_node **node)\n{\n\tint err;\n\tstruct INDEX_BUFFER *ib;\n\tstruct runs_tree *run = &indx->alloc_run;\n\tstruct rw_semaphore *lock = &indx->run_lock;\n\tu64 vbo = (u64)vbn << indx->vbn2vbo_bits;\n\tu32 bytes = 1u << indx->index_bits;\n\tstruct indx_node *in = *node;\n\tconst struct INDEX_NAMES *name;\n\n\tif (!in) {\n\t\tin = kzalloc(sizeof(struct indx_node), GFP_NOFS);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tnb_put(&in->nb);\n\t}\n\n\tib = in->index;\n\tif (!ib) {\n\t\tib = kmalloc(bytes, GFP_NOFS);\n\t\tif (!ib) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (!err)\n\t\tgoto ok;\n\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err != -ENOENT)\n\t\tgoto out;\n\n\tname = &s_index_names[indx->type];\n\tdown_write(lock);\n\terr = attr_load_runs_range(ni, ATTR_ALLOC, name->name, name->name_len,\n\t\t\t\t   run, vbo, vbo + bytes);\n\tup_write(lock);\n\tif (err)\n\t\tgoto out;\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err)\n\t\tgoto out;\n\nok:\n\tif (!index_buf_check(ib, bytes, &vbn)) {\n\t\tntfs_inode_err(&ni->vfs_inode, \"directory corrupted\");\n\t\tntfs_set_state(ni->mi.sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (err == -E_NTFS_FIXUP) {\n\t\tntfs_write_bh(ni->mi.sbi, &ib->rhdr, &in->nb, 0);\n\t\terr = 0;\n\t}\n\n\t/* check for index header length */\n\tif (offsetof(struct INDEX_BUFFER, ihdr) + ib->ihdr.used > bytes) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tin->index = ib;\n\t*node = in;\n\nout:\n\tif (ib != in->index)\n\t\tkfree(ib);\n\n\tif (*node != in) {\n\t\tnb_put(&in->nb);\n\t\tkfree(in);\n\t}\n\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root))\n\t\t\tmemcpy(attr, a_root, asize);\n\t\telse {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}",
                        "code_after_change": "static int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root)) {\n\t\t\tmemcpy(attr, a_root, asize);\n\t\t} else {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,\n\t      struct indx_node **node)\n{\n\tint err;\n\tstruct INDEX_BUFFER *ib;\n\tstruct runs_tree *run = &indx->alloc_run;\n\tstruct rw_semaphore *lock = &indx->run_lock;\n\tu64 vbo = (u64)vbn << indx->vbn2vbo_bits;\n\tu32 bytes = 1u << indx->index_bits;\n\tstruct indx_node *in = *node;\n\tconst struct INDEX_NAMES *name;\n\n\tif (!in) {\n\t\tin = kzalloc(sizeof(struct indx_node), GFP_NOFS);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tnb_put(&in->nb);\n\t}\n\n\tib = in->index;\n\tif (!ib) {\n\t\tib = kmalloc(bytes, GFP_NOFS);\n\t\tif (!ib) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (!err)\n\t\tgoto ok;\n\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err != -ENOENT)\n\t\tgoto out;\n\n\tname = &s_index_names[indx->type];\n\tdown_write(lock);\n\terr = attr_load_runs_range(ni, ATTR_ALLOC, name->name, name->name_len,\n\t\t\t\t   run, vbo, vbo + bytes);\n\tup_write(lock);\n\tif (err)\n\t\tgoto out;\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err)\n\t\tgoto out;\n\nok:\n\tif (!index_buf_check(ib, bytes, &vbn)) {\n\t\tntfs_inode_err(&ni->vfs_inode, \"directory corrupted\");\n\t\tntfs_set_state(ni->mi.sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (err == -E_NTFS_FIXUP) {\n\t\tntfs_write_bh(ni->mi.sbi, &ib->rhdr, &in->nb, 0);\n\t\terr = 0;\n\t}\n\n\t/* check for index header length */\n\tif (offsetof(struct INDEX_BUFFER, ihdr) + ib->ihdr.used > bytes) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tin->index = ib;\n\t*node = in;\n\nout:\n\tif (ib != in->index)\n\t\tkfree(ib);\n\n\tif (*node != in) {\n\t\tnb_put(&in->nb);\n\t\tkfree(in);\n\t}\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root))\n\t\t\tmemcpy(attr, a_root, asize);\n\t\telse {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root)) {\n\t\t\tmemcpy(attr, a_root, asize);\n\t\t} else {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,\n\t      struct indx_node **node)\n{\n\tint err;\n\tstruct INDEX_BUFFER *ib;\n\tstruct runs_tree *run = &indx->alloc_run;\n\tstruct rw_semaphore *lock = &indx->run_lock;\n\tu64 vbo = (u64)vbn << indx->vbn2vbo_bits;\n\tu32 bytes = 1u << indx->index_bits;\n\tstruct indx_node *in = *node;\n\tconst struct INDEX_NAMES *name;\n\n\tif (!in) {\n\t\tin = kzalloc(sizeof(struct indx_node), GFP_NOFS);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tnb_put(&in->nb);\n\t}\n\n\tib = in->index;\n\tif (!ib) {\n\t\tib = kmalloc(bytes, GFP_NOFS);\n\t\tif (!ib) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (!err)\n\t\tgoto ok;\n\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err != -ENOENT)\n\t\tgoto out;\n\n\tname = &s_index_names[indx->type];\n\tdown_write(lock);\n\terr = attr_load_runs_range(ni, ATTR_ALLOC, name->name, name->name_len,\n\t\t\t\t   run, vbo, vbo + bytes);\n\tup_write(lock);\n\tif (err)\n\t\tgoto out;\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err)\n\t\tgoto out;\n\nok:\n\tif (!index_buf_check(ib, bytes, &vbn)) {\n\t\tntfs_inode_err(&ni->vfs_inode, \"directory corrupted\");\n\t\tntfs_set_state(ni->mi.sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (err == -E_NTFS_FIXUP) {\n\t\tntfs_write_bh(ni->mi.sbi, &ib->rhdr, &in->nb, 0);\n\t\terr = 0;\n\t}\n\n\t/* check for index header length */\n\tif (offsetof(struct INDEX_BUFFER, ihdr) + ib->ihdr.used > bytes) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tin->index = ib;\n\t*node = in;\n\nout:\n\tif (ib != in->index)\n\t\tkfree(ib);\n\n\tif (*node != in) {\n\t\tnb_put(&in->nb);\n\t\tkfree(in);\n\t}\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off)) {\n\t\tstruct EA_FULL *ea;\n\t\tsize_t ea_sz;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tea_sz = unpacked_ea_size(ea);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}",
                        "code_after_change": "static noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,\n\t      struct indx_node **node)\n{\n\tint err;\n\tstruct INDEX_BUFFER *ib;\n\tstruct runs_tree *run = &indx->alloc_run;\n\tstruct rw_semaphore *lock = &indx->run_lock;\n\tu64 vbo = (u64)vbn << indx->vbn2vbo_bits;\n\tu32 bytes = 1u << indx->index_bits;\n\tstruct indx_node *in = *node;\n\tconst struct INDEX_NAMES *name;\n\n\tif (!in) {\n\t\tin = kzalloc(sizeof(struct indx_node), GFP_NOFS);\n\t\tif (!in)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tnb_put(&in->nb);\n\t}\n\n\tib = in->index;\n\tif (!ib) {\n\t\tib = kmalloc(bytes, GFP_NOFS);\n\t\tif (!ib) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (!err)\n\t\tgoto ok;\n\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err != -ENOENT)\n\t\tgoto out;\n\n\tname = &s_index_names[indx->type];\n\tdown_write(lock);\n\terr = attr_load_runs_range(ni, ATTR_ALLOC, name->name, name->name_len,\n\t\t\t\t   run, vbo, vbo + bytes);\n\tup_write(lock);\n\tif (err)\n\t\tgoto out;\n\n\tdown_read(lock);\n\terr = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);\n\tup_read(lock);\n\tif (err == -E_NTFS_FIXUP)\n\t\tgoto ok;\n\n\tif (err)\n\t\tgoto out;\n\nok:\n\tif (!index_buf_check(ib, bytes, &vbn)) {\n\t\tntfs_inode_err(&ni->vfs_inode, \"directory corrupted\");\n\t\tntfs_set_state(ni->mi.sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (err == -E_NTFS_FIXUP) {\n\t\tntfs_write_bh(ni->mi.sbi, &ib->rhdr, &in->nb, 0);\n\t\terr = 0;\n\t}\n\n\t/* check for index header length */\n\tif (offsetof(struct INDEX_BUFFER, ihdr) + ib->ihdr.used > bytes) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tin->index = ib;\n\t*node = in;\n\nout:\n\tif (ib != in->index)\n\t\tkfree(ib);\n\n\tif (*node != in) {\n\t\tnb_put(&in->nb);\n\t\tkfree(in);\n\t}\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off)) {\n\t\tstruct EA_FULL *ea;\n\t\tsize_t ea_sz;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tea_sz = unpacked_ea_size(ea);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic noinline int ntfs_set_ea(struct inode *inode, const char *name,\n\t\t\t\tsize_t name_len, const void *value,\n\t\t\t\tsize_t val_size, int flags, bool locked)\n{\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct ntfs_sb_info *sbi = ni->mi.sbi;\n\tint err;\n\tstruct EA_INFO ea_info;\n\tconst struct EA_INFO *info;\n\tstruct EA_FULL *new_ea;\n\tstruct EA_FULL *ea_all = NULL;\n\tsize_t add, new_pack;\n\tu32 off, size, ea_sz;\n\t__le16 size_pack;\n\tstruct ATTRIB *attr;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct mft_inode *mi;\n\tstruct runs_tree ea_run;\n\tu64 new_sz;\n\tvoid *p;\n\n\tif (!locked)\n\t\tni_lock(ni);\n\n\trun_init(&ea_run);\n\n\tif (name_len > 255) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out;\n\t}\n\n\tadd = ALIGN(struct_size(ea_all, name, 1 + name_len + val_size), 4);\n\n\terr = ntfs_read_ea(ni, &ea_all, add, &info);\n\tif (err)\n\t\tgoto out;\n\n\tif (!info) {\n\t\tmemset(&ea_info, 0, sizeof(ea_info));\n\t\tsize = 0;\n\t\tsize_pack = 0;\n\t} else {\n\t\tmemcpy(&ea_info, info, sizeof(ea_info));\n\t\tsize = le32_to_cpu(ea_info.size);\n\t\tsize_pack = ea_info.size_pack;\n\t}\n\n\tif (info && find_ea(ea_all, size, name, name_len, &off, &ea_sz)) {\n\t\tstruct EA_FULL *ea;\n\n\t\tif (flags & XATTR_CREATE) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tea = Add2Ptr(ea_all, off);\n\n\t\t/*\n\t\t * Check simple case when we try to insert xattr with the same value\n\t\t * e.g. ntfs_save_wsl_perm\n\t\t */\n\t\tif (val_size && le16_to_cpu(ea->elength) == val_size &&\n\t\t    !memcmp(ea->name + ea->name_len + 1, value, val_size)) {\n\t\t\t/* xattr already contains the required value. */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove current xattr. */\n\t\tif (ea->flags & FILE_NEED_EA)\n\t\t\tle16_add_cpu(&ea_info.count, -1);\n\n\t\tle16_add_cpu(&ea_info.size_pack, 0 - packed_ea_size(ea));\n\n\t\tmemmove(ea, Add2Ptr(ea, ea_sz), size - off - ea_sz);\n\n\t\tsize -= ea_sz;\n\t\tmemset(Add2Ptr(ea_all, size), 0, ea_sz);\n\n\t\tea_info.size = cpu_to_le32(size);\n\n\t\tif ((flags & XATTR_REPLACE) && !val_size) {\n\t\t\t/* Remove xattr. */\n\t\t\tgoto update_ea;\n\t\t}\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!ea_all) {\n\t\t\tea_all = kzalloc(add, GFP_NOFS);\n\t\t\tif (!ea_all) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Append new xattr. */\n\tnew_ea = Add2Ptr(ea_all, size);\n\tnew_ea->size = cpu_to_le32(add);\n\tnew_ea->flags = 0;\n\tnew_ea->name_len = name_len;\n\tnew_ea->elength = cpu_to_le16(val_size);\n\tmemcpy(new_ea->name, name, name_len);\n\tnew_ea->name[name_len] = 0;\n\tmemcpy(new_ea->name + name_len + 1, value, val_size);\n\tnew_pack = le16_to_cpu(ea_info.size_pack) + packed_ea_size(new_ea);\n\tea_info.size_pack = cpu_to_le16(new_pack);\n\t/* New size of ATTR_EA. */\n\tsize += add;\n\tea_info.size = cpu_to_le32(size);\n\n\t/*\n\t * 1. Check ea_info.size_pack for overflow.\n\t * 2. New attibute size must fit value from $AttrDef\n\t */\n\tif (new_pack > 0xffff || size > sbi->ea_max_size) {\n\t\tntfs_inode_warn(\n\t\t\tinode,\n\t\t\t\"The size of extended attributes must not exceed 64KiB\");\n\t\terr = -EFBIG; // -EINVAL?\n\t\tgoto out;\n\t}\n\nupdate_ea:\n\n\tif (!info) {\n\t\t/* Create xattr. */\n\t\tif (!size) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ni_insert_resident(ni, sizeof(struct EA_INFO),\n\t\t\t\t\t ATTR_EA_INFO, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ni_insert_resident(ni, 0, ATTR_EA, NULL, 0, NULL, NULL,\n\t\t\t\t\t NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnew_sz = size;\n\terr = attr_set_size(ni, ATTR_EA, NULL, 0, &ea_run, new_sz, &new_sz,\n\t\t\t    false, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA_INFO, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA_INFO */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else {\n\t\tp = resident_data_ex(attr, sizeof(struct EA_INFO));\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, &ea_info, sizeof(struct EA_INFO));\n\t\tmi->dirty = true;\n\t}\n\n\tle = NULL;\n\tattr = ni_find_attr(ni, NULL, &le, ATTR_EA, NULL, 0, NULL, &mi);\n\tif (!attr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!size) {\n\t\t/* Delete xattr, ATTR_EA */\n\t\tni_remove_attr_le(ni, attr, mi, le);\n\t} else if (attr->non_res) {\n\t\terr = attr_load_runs_range(ni, ATTR_EA, NULL, 0, &ea_run, 0,\n\t\t\t\t\t   size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ntfs_sb_write_run(sbi, &ea_run, 0, ea_all, size, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tp = resident_data_ex(attr, size);\n\t\tif (!p) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(p, ea_all, size);\n\t\tmi->dirty = true;\n\t}\n\n\t/* Check if we delete the last xattr. */\n\tif (size)\n\t\tni->ni_flags |= NI_FLAG_EA;\n\telse\n\t\tni->ni_flags &= ~NI_FLAG_EA;\n\n\tif (ea_info.size_pack != size_pack)\n\t\tni->ni_flags |= NI_FLAG_UPDATE_PARENT;\n\tmark_inode_dirty(&ni->vfs_inode);\n\nout:\n\tif (!locked)\n\t\tni_unlock(ni);\n\n\trun_close(&ea_run);\n\tkfree(ea_all);\n\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 1552,
            "cve_id": "CVE-2017-8240",
            "code_snippet": "static void msm_pinctrl_setup_pm_reset(struct msm_pinctrl *pctrl)\n{\n\tint i;\n\tconst struct msm_function *func = pctrl->soc->functions;\n\n\tfor (i = 0; i < pctrl->soc->nfunctions; i++)\n\t\tif (!strcmp(func[i].name, \"ps_hold\")) {\n\t\t\tpctrl->restart_nb.notifier_call = msm_ps_hold_restart;\n\t\t\tpctrl->restart_nb.priority = 128;\n\t\t\tif (register_restart_handler(&pctrl->restart_nb))\n\t\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\t\"failed to setup restart handler.\\n\");\n\t\t\tbreak;\n\t\t}\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2021-3444"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void msm_pinctrl_setup_pm_reset(struct msm_pinctrl *pctrl)\n{\n\tint i;\n\tconst struct msm_function *func = pctrl->soc->functions;\n\n\tfor (i = 0; i < pctrl->soc->nfunctions; i++)\n\t\tif (!strcmp(func[i].name, \"ps_hold\")) {\n\t\t\tpctrl->restart_nb.notifier_call = msm_ps_hold_restart;\n\t\t\tpctrl->restart_nb.priority = 128;\n\t\t\tif (register_restart_handler(&pctrl->restart_nb))\n\t\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\t\"failed to setup restart handler.\\n\");\n\t\t\tbreak;\n\t\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tvoid *control_header;\n\tint i, protocol;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\tcontrol_header = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t NULL, UAC_HEADER);\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tif (!control_header) {\n\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tvoid *control_header;\n\tint i, protocol;\n\tint rest_bytes;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\tcontrol_header = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t NULL, UAC_HEADER);\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tif (!control_header) {\n\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trest_bytes = (void *)(host_iface->extra + host_iface->extralen) -\n\t\tcontrol_header;\n\n\t/* just to be sure -- this shouldn't hit at all */\n\tif (rest_bytes <= 0) {\n\t\tdev_err(&dev->dev, \"invalid control header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n\n\t\tif (rest_bytes < sizeof(*h1)) {\n\t\t\tdev_err(&dev->dev, \"too short v1 buffer descriptor\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < h1->bLength) {\n\t\t\tdev_err(&dev->dev, \"invalid buffer length (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-16529"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void msm_pinctrl_setup_pm_reset(struct msm_pinctrl *pctrl)\n{\n\tint i;\n\tconst struct msm_function *func = pctrl->soc->functions;\n\n\tfor (i = 0; i < pctrl->soc->nfunctions; i++)\n\t\tif (!strcmp(func[i].name, \"ps_hold\")) {\n\t\t\tpctrl->restart_nb.notifier_call = msm_ps_hold_restart;\n\t\t\tpctrl->restart_nb.priority = 128;\n\t\t\tif (register_restart_handler(&pctrl->restart_nb))\n\t\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\t\"failed to setup restart handler.\\n\");\n\t\t\tbreak;\n\t\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tvoid *control_header;\n\tint i, protocol;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\tcontrol_header = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t NULL, UAC_HEADER);\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tif (!control_header) {\n\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tvoid *control_header;\n\tint i, protocol;\n\tint rest_bytes;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\tcontrol_header = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t NULL, UAC_HEADER);\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tif (!control_header) {\n\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trest_bytes = (void *)(host_iface->extra + host_iface->extralen) -\n\t\tcontrol_header;\n\n\t/* just to be sure -- this shouldn't hit at all */\n\tif (rest_bytes <= 0) {\n\t\tdev_err(&dev->dev, \"invalid control header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n\n\t\tif (rest_bytes < sizeof(*h1)) {\n\t\t\tdev_err(&dev->dev, \"too short v1 buffer descriptor\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < h1->bLength) {\n\t\t\tdev_err(&dev->dev, \"invalid buffer length (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "code_after_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "cve_id": "CVE-2023-37453"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void msm_pinctrl_setup_pm_reset(struct msm_pinctrl *pctrl)\n{\n\tint i;\n\tconst struct msm_function *func = pctrl->soc->functions;\n\n\tfor (i = 0; i < pctrl->soc->nfunctions; i++)\n\t\tif (!strcmp(func[i].name, \"ps_hold\")) {\n\t\t\tpctrl->restart_nb.notifier_call = msm_ps_hold_restart;\n\t\t\tpctrl->restart_nb.priority = 128;\n\t\t\tif (register_restart_handler(&pctrl->restart_nb))\n\t\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\t\"failed to setup restart handler.\\n\");\n\t\t\tbreak;\n\t\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2307,
            "cve_id": "CVE-2019-3459",
            "code_snippet": "static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *endptr = data + data_size;\n\tvoid *req = chan->conf_req;\n\tint len = chan->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\tu8 remote_efs = 0;\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\tset_bit(CONF_RECV_NO_FCS, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tremote_efs = 1;\n\t\t\tmemcpy(&efs, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\t\tset_bit(CONF_EWS_RECV, &chan->conf_state);\n\t\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t\t\tchan->remote_tx_win = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->num_conf_rsp || chan->num_conf_req > 1)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {\n\t\t\tchan->mode = l2cap_select_mode(rfc.mode,\n\t\t\t\t\t\t       chan->conn->feat_mask);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (remote_efs) {\n\t\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\t\t\telse\n\t\t\t\treturn -ECONNREFUSED;\n\t\t}\n\n\t\tif (chan->mode != rfc.mode)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = chan->mode;\n\n\t\tif (chan->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tchan->omtu = mtu;\n\t\t\tset_bit(CONF_MTU_DONE, &chan->conf_state);\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);\n\n\t\tif (remote_efs) {\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype) {\n\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\t\tif (chan->num_conf_req >= 1)\n\t\t\t\t\treturn -ECONNREFUSED;\n\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t} else {\n\t\t\t\t/* Send PENDING Conf Rsp */\n\t\t\t\tresult = L2CAP_CONF_PENDING;\n\t\t\t\tset_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\t\t\t}\n\t\t}\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tif (!test_bit(CONF_EWS_RECV, &chan->conf_state))\n\t\t\t\tchan->remote_tx_win = rfc.txwin_size;\n\t\t\telse\n\t\t\t\trfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;\n\n\t\t\tchan->remote_max_tx = rfc.max_transmit;\n\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\t   sizeof(rfc), (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->remote_id = efs.id;\n\t\t\t\tchan->remote_stype = efs.stype;\n\t\t\t\tchan->remote_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->remote_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t\tchan->remote_acc_lat =\n\t\t\t\t\tle32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->remote_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = chan->mode;\n\t\t}\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\t}\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}",
                        "code_after_change": "static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}",
                        "cve_id": "CVE-2019-3459"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *endptr = data + data_size;\n\tvoid *req = chan->conf_req;\n\tint len = chan->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\tu8 remote_efs = 0;\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\tset_bit(CONF_RECV_NO_FCS, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tremote_efs = 1;\n\t\t\tmemcpy(&efs, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\t\tset_bit(CONF_EWS_RECV, &chan->conf_state);\n\t\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t\t\tchan->remote_tx_win = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->num_conf_rsp || chan->num_conf_req > 1)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {\n\t\t\tchan->mode = l2cap_select_mode(rfc.mode,\n\t\t\t\t\t\t       chan->conn->feat_mask);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (remote_efs) {\n\t\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\t\t\telse\n\t\t\t\treturn -ECONNREFUSED;\n\t\t}\n\n\t\tif (chan->mode != rfc.mode)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = chan->mode;\n\n\t\tif (chan->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tchan->omtu = mtu;\n\t\t\tset_bit(CONF_MTU_DONE, &chan->conf_state);\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);\n\n\t\tif (remote_efs) {\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype) {\n\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\t\tif (chan->num_conf_req >= 1)\n\t\t\t\t\treturn -ECONNREFUSED;\n\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t} else {\n\t\t\t\t/* Send PENDING Conf Rsp */\n\t\t\t\tresult = L2CAP_CONF_PENDING;\n\t\t\t\tset_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\t\t\t}\n\t\t}\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tif (!test_bit(CONF_EWS_RECV, &chan->conf_state))\n\t\t\t\tchan->remote_tx_win = rfc.txwin_size;\n\t\t\telse\n\t\t\t\trfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;\n\n\t\t\tchan->remote_max_tx = rfc.max_transmit;\n\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\t   sizeof(rfc), (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->remote_id = efs.id;\n\t\t\t\tchan->remote_stype = efs.stype;\n\t\t\t\tchan->remote_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->remote_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t\tchan->remote_acc_lat =\n\t\t\t\t\tle32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->remote_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = chan->mode;\n\t\t}\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\t}\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1431,
            "cve_id": "CVE-2017-18344",
            "code_snippet": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * The timespec64 based conversion is suboptimal, but it's not\n\t * worth to implement yet another callback.\n\t */\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
                        "code_after_change": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-18344"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * The timespec64 based conversion is suboptimal, but it's not\n\t * worth to implement yet another callback.\n\t */\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nint common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1368,
            "cve_id": "CVE-2017-17741",
            "code_snippet": "static int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);\n\treturn X86EMUL_IO_NEEDED;\n}",
                        "code_after_change": "static int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);\n\treturn X86EMUL_IO_NEEDED;\n}",
                        "cve_id": "CVE-2017-17741"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);\n\treturn X86EMUL_IO_NEEDED;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);\n\treturn X86EMUL_IO_NEEDED;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, *(u64 *)val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-17741"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, *(u64 *)val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,\n\t\t\t\t\t addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}",
                        "code_after_change": "static int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,\n\t\t\t\t\t addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}",
                        "cve_id": "CVE-2017-17741"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,\n\t\t\t\t\t addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,\n\t\t\t\t\t addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2655,
            "cve_id": "CVE-2020-28097",
            "code_snippet": "static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t/* Redrawing not needed */\n}",
                        "code_after_change": "static int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\treturn 0;\t\t/* Redrawing not needed */\n}",
                        "cve_id": "CVE-2020-28097"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t/* Redrawing not needed */\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\t/*\n\t * We need to save screen size here as it's the only way\n\t * we can spot the screen has been resized and we need to\n\t * set size of freshly allocated screens ourselves.\n\t */\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\t/* We can only copy out the size of the video buffer here,\n\t * otherwise we get into VGA BIOS */\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\treturn 0;\t\t/* Redrawing not needed */\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1984,
            "cve_id": "CVE-2019-15090",
            "code_snippet": "void\nqedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), func, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void\nqedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}",
                        "code_after_change": "void\nqedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}",
                        "cve_id": "CVE-2019-15090"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid\nqedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), func, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}\n'''\nRelated vulnerability code snippet:\n'''\nvoid\nqedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nvoid\nqedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "void\nqedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}",
                        "code_after_change": "void\nqedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}",
                        "cve_id": "CVE-2019-15090"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid\nqedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), func, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}\n'''\nRelated vulnerability code snippet:\n'''\nvoid\nqedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nvoid\nqedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "void\nqedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       nfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\n\tva_end(va);\n}",
                        "code_after_change": "void\nqedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       func, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\n\tva_end(va);\n}",
                        "cve_id": "CVE-2019-15090"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid\nqedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), func, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}\n'''\nRelated vulnerability code snippet:\n'''\nvoid\nqedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       nfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\n\tva_end(va);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nvoid\nqedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       func, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\n\tva_end(va);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2290,
            "cve_id": "CVE-2019-2101",
            "code_snippet": "static int uvc_parse_standard_control(struct uvc_device *dev,\n\tconst unsigned char *buffer, int buflen)\n{\n\tstruct usb_device *udev = dev->udev;\n\tstruct uvc_entity *unit, *term;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *alts = dev->intf->cur_altsetting;\n\tunsigned int i, n, p, len;\n\tu16 type;\n\n\tswitch (buffer[2]) {\n\tcase UVC_VC_HEADER:\n\t\tn = buflen >= 12 ? buffer[11] : 0;\n\n\t\tif (buflen < 12 + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d HEADER error\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev->uvc_version = get_unaligned_le16(&buffer[3]);\n\t\tdev->clock_frequency = get_unaligned_le32(&buffer[7]);\n\n\t\t/* Parse all USB Video Streaming interfaces. */\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tintf = usb_ifnum_to_if(udev, buffer[12+i]);\n\t\t\tif (intf == NULL) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d \"\n\t\t\t\t\t\"interface %d doesn't exists\\n\",\n\t\t\t\t\tudev->devnum, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuvc_parse_streaming(dev, intf);\n\t\t}\n\t\tbreak;\n\n\tcase UVC_VC_INPUT_TERMINAL:\n\t\tif (buflen < 8) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * Reject invalid terminal types that would cause issues:\n\t\t *\n\t\t * - The high byte must be non-zero, otherwise it would be\n\t\t *   confused with a unit.\n\t\t *\n\t\t * - Bit 15 must be 0, as we use it internally as a terminal\n\t\t *   direction flag.\n\t\t *\n\t\t * Other unknown types are accepted.\n\t\t */\n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0x7f00) == 0 || (type & 0x8000) != 0) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL %d has invalid \"\n\t\t\t\t\"type 0x%04x, skipping\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber,\n\t\t\t\tbuffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tn = 0;\n\t\tp = 0;\n\t\tlen = 8;\n\n\t\tif (type == UVC_ITT_CAMERA) {\n\t\t\tn = buflen >= 15 ? buffer[14] : 0;\n\t\t\tlen = 15;\n\n\t\t} else if (type == UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tn = buflen >= 9 ? buffer[8] : 0;\n\t\t\tp = buflen >= 10 + n ? buffer[9+n] : 0;\n\t\t\tlen = 10;\n\t\t}\n\n\t\tif (buflen < len + n + p) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_INPUT, buffer[3],\n\t\t\t\t\t1, n + p);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA) {\n\t\t\tterm->camera.bControlSize = n;\n\t\t\tterm->camera.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->camera.wObjectiveFocalLengthMin =\n\t\t\t\tget_unaligned_le16(&buffer[8]);\n\t\t\tterm->camera.wObjectiveFocalLengthMax =\n\t\t\t\tget_unaligned_le16(&buffer[10]);\n\t\t\tterm->camera.wOcularFocalLength =\n\t\t\t\tget_unaligned_le16(&buffer[12]);\n\t\t\tmemcpy(term->camera.bmControls, &buffer[15], n);\n\t\t} else if (UVC_ENTITY_TYPE(term) ==\n\t\t\t   UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tterm->media.bControlSize = n;\n\t\t\tterm->media.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->media.bTransportModeSize = p;\n\t\t\tterm->media.bmTransportModes = (u8 *)term\n\t\t\t\t\t\t     + sizeof(*term) + n;\n\t\t\tmemcpy(term->media.bmControls, &buffer[9], n);\n\t\t\tmemcpy(term->media.bmTransportModes, &buffer[10+n], p);\n\t\t}\n\n\t\tif (buffer[7] != 0)\n\t\t\tusb_string(udev, buffer[7], term->name,\n\t\t\t\t   sizeof(term->name));\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA)\n\t\t\tsprintf(term->name, \"Camera %u\", buffer[3]);\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_MEDIA_TRANSPORT_INPUT)\n\t\t\tsprintf(term->name, \"Media %u\", buffer[3]);\n\t\telse\n\t\t\tsprintf(term->name, \"Input %u\", buffer[3]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_OUTPUT_TERMINAL:\n\t\tif (buflen < 9) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d OUTPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Make sure the terminal type MSB is not null, otherwise it\n\t\t * could be confused with a unit.\n\t\t */\n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0xff00) == 0) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d OUTPUT_TERMINAL %d has invalid \"\n\t\t\t\t\"type 0x%04x, skipping\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber, buffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_OUTPUT, buffer[3],\n\t\t\t\t\t1, 0);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(term->baSourceID, &buffer[7], 1);\n\n\t\tif (buffer[8] != 0)\n\t\t\tusb_string(udev, buffer[8], term->name,\n\t\t\t\t   sizeof(term->name));\n\t\telse\n\t\t\tsprintf(term->name, \"Output %u\", buffer[3]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_SELECTOR_UNIT:\n\t\tp = buflen >= 5 ? buffer[4] : 0;\n\n\t\tif (buflen < 5 || buflen < 6 + p) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d SELECTOR_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, 0);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[5], p);\n\n\t\tif (buffer[5+p] != 0)\n\t\t\tusb_string(udev, buffer[5+p], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Selector %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_PROCESSING_UNIT:\n\t\tn = buflen >= 8 ? buffer[7] : 0;\n\t\tp = dev->uvc_version >= 0x0110 ? 10 : 9;\n\n\t\tif (buflen < p + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d PROCESSING_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], 2, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[4], 1);\n\t\tunit->processing.wMaxMultiplier =\n\t\t\tget_unaligned_le16(&buffer[5]);\n\t\tunit->processing.bControlSize = buffer[7];\n\t\tunit->processing.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->processing.bmControls, &buffer[8], n);\n\t\tif (dev->uvc_version >= 0x0110)\n\t\t\tunit->processing.bmVideoStandards = buffer[9+n];\n\n\t\tif (buffer[8+n] != 0)\n\t\t\tusb_string(udev, buffer[8+n], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Processing %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_EXTENSION_UNIT:\n\t\tp = buflen >= 22 ? buffer[21] : 0;\n\t\tn = buflen >= 24 + p ? buffer[22+p] : 0;\n\n\t\tif (buflen < 24 + p + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d EXTENSION_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->extension.guidExtensionCode, &buffer[4], 16);\n\t\tunit->extension.bNumControls = buffer[20];\n\t\tmemcpy(unit->baSourceID, &buffer[22], p);\n\t\tunit->extension.bControlSize = buffer[22+p];\n\t\tunit->extension.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->extension.bmControls, &buffer[23+p], n);\n\n\t\tif (buffer[23+p+n] != 0)\n\t\t\tusb_string(udev, buffer[23+p+n], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Extension %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tdefault:\n\t\tuvc_trace(UVC_TRACE_DESCR, \"Found an unknown CS_INTERFACE \"\n\t\t\t\"descriptor (%u)\\n\", buffer[2]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int uclogic_params_init(struct uclogic_params *params,\n\t\t\tstruct hid_device *hdev)\n{\n\tint rc;\n\tstruct usb_device *udev = hid_to_usb_dev(hdev);\n\t__u8  bNumInterfaces = udev->config->desc.bNumInterfaces;\n\tstruct usb_interface *iface = to_usb_interface(hdev->dev.parent);\n\t__u8 bInterfaceNumber = iface->cur_altsetting->desc.bInterfaceNumber;\n\tbool found;\n\t/* The resulting parameters (noop) */\n\tstruct uclogic_params p = {0, };\n\n\t/* Check arguments */\n\tif (params == NULL || hdev == NULL ||\n\t    !hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Set replacement report descriptor if the original matches the\n\t * specified size. Otherwise keep interface unchanged.\n\t */\n#define WITH_OPT_DESC(_orig_desc_token, _new_desc_token) \\\n\tuclogic_params_init_with_opt_desc(                  \\\n\t\t&p, hdev,                                   \\\n\t\tUCLOGIC_RDESC_##_orig_desc_token##_SIZE,    \\\n\t\tuclogic_rdesc_##_new_desc_token##_arr,      \\\n\t\tuclogic_rdesc_##_new_desc_token##_size)\n\n#define VID_PID(_vid, _pid) \\\n\t(((__u32)(_vid) << 16) | ((__u32)(_pid) & U16_MAX))\n\n\t/*\n\t * Handle specific interfaces for specific tablets.\n\t *\n\t * Observe the following logic:\n\t *\n\t * If the interface is recognized as producing certain useful input:\n\t *\tMark interface as valid.\n\t *\tOutput interface parameters.\n\t * Else, if the interface is recognized as *not* producing any useful\n\t * input:\n\t *\tMark interface as invalid.\n\t * Else:\n\t *\tMark interface as valid.\n\t *\tOutput noop parameters.\n\t *\n\t * Rule of thumb: it is better to disable a broken interface than let\n\t *\t\t  it spew garbage input.\n\t */\n\n\tswitch (VID_PID(hdev->vendor, hdev->product)) {\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_PF1209):\n\t\trc = WITH_OPT_DESC(PF1209_ORIG, pf1209_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp4030u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U):\n\t\tif (hdev->dev_rsize == UCLOGIC_RDESC_WP5540U_V2_ORIG_SIZE) {\n\t\t\tif (bInterfaceNumber == 0) {\n\t\t\t\t/* Try to probe v1 pen parameters */\n\t\t\t\trc = uclogic_params_pen_init_v1(&p.pen,\n\t\t\t\t\t\t\t\t&found, hdev);\n\t\t\t\tif (rc != 0) {\n\t\t\t\t\thid_err(hdev,\n\t\t\t\t\t\t\"pen probing failed: %d\\n\",\n\t\t\t\t\t\trc);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\thid_warn(hdev,\n\t\t\t\t\t\t \"pen parameters not found\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp5540u_fixed);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp8060u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP1062):\n\t\trc = WITH_OPT_DESC(WP1062_ORIG, wp1062_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850):\n\t\tswitch (bInterfaceNumber) {\n\t\tcase 0:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG0, twhl850_fixed0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG1, twhl850_fixed1);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG2, twhl850_fixed2);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60):\n\t\t/*\n\t\t * If it is not a three-interface version, which is known to\n\t\t * respond to initialization.\n\t\t */\n\t\tif (bNumInterfaces != 3) {\n\t\t\tswitch (bInterfaceNumber) {\n\t\t\tcase 0:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG0,\n\t\t\t\t\t\t\ttwha60_fixed0);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG1,\n\t\t\t\t\t\t\ttwha60_fixed1);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_HS64):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_YIYNOVA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_81):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_DRAWIMAGE_G3):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_45):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_47):\n\t\trc = uclogic_params_huion_init(&p, hdev);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GP0610):\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GT5040):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G540):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G640):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_RAINBOW_CV720):\n\t\t/* If this is the pen interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01):\n\t\t/* If this is the pen and frame interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* Initialize frame parameters */\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_arr,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_TRUST,\n\t\t     USB_DEVICE_ID_TRUST_PANORA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_G5):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_arr,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_size,\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_ID);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tp.frame.re_lsb =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_RE_LSB;\n\t\t\tp.frame.dev_id_byte =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_DEV_ID_BYTE;\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_EX07S):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_arr,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\t}\n\n#undef VID_PID\n#undef WITH_OPT_DESC\n\n\t/* Output parameters */\n\tmemcpy(params, &p, sizeof(*params));\n\tmemset(&p, 0, sizeof(p));\n\trc = 0;\ncleanup:\n\tuclogic_params_cleanup(&p);\n\treturn rc;\n}",
                        "code_after_change": "int uclogic_params_init(struct uclogic_params *params,\n\t\t\tstruct hid_device *hdev)\n{\n\tint rc;\n\tstruct usb_device *udev = hid_to_usb_dev(hdev);\n\t__u8  bNumInterfaces = udev->config->desc.bNumInterfaces;\n\tstruct usb_interface *iface = to_usb_interface(hdev->dev.parent);\n\t__u8 bInterfaceNumber = iface->cur_altsetting->desc.bInterfaceNumber;\n\tbool found;\n\t/* The resulting parameters (noop) */\n\tstruct uclogic_params p = {0, };\n\n\t/* Check arguments */\n\tif (params == NULL || hdev == NULL || !hid_is_usb(hdev)) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Set replacement report descriptor if the original matches the\n\t * specified size. Otherwise keep interface unchanged.\n\t */\n#define WITH_OPT_DESC(_orig_desc_token, _new_desc_token) \\\n\tuclogic_params_init_with_opt_desc(                  \\\n\t\t&p, hdev,                                   \\\n\t\tUCLOGIC_RDESC_##_orig_desc_token##_SIZE,    \\\n\t\tuclogic_rdesc_##_new_desc_token##_arr,      \\\n\t\tuclogic_rdesc_##_new_desc_token##_size)\n\n#define VID_PID(_vid, _pid) \\\n\t(((__u32)(_vid) << 16) | ((__u32)(_pid) & U16_MAX))\n\n\t/*\n\t * Handle specific interfaces for specific tablets.\n\t *\n\t * Observe the following logic:\n\t *\n\t * If the interface is recognized as producing certain useful input:\n\t *\tMark interface as valid.\n\t *\tOutput interface parameters.\n\t * Else, if the interface is recognized as *not* producing any useful\n\t * input:\n\t *\tMark interface as invalid.\n\t * Else:\n\t *\tMark interface as valid.\n\t *\tOutput noop parameters.\n\t *\n\t * Rule of thumb: it is better to disable a broken interface than let\n\t *\t\t  it spew garbage input.\n\t */\n\n\tswitch (VID_PID(hdev->vendor, hdev->product)) {\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_PF1209):\n\t\trc = WITH_OPT_DESC(PF1209_ORIG, pf1209_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp4030u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U):\n\t\tif (hdev->dev_rsize == UCLOGIC_RDESC_WP5540U_V2_ORIG_SIZE) {\n\t\t\tif (bInterfaceNumber == 0) {\n\t\t\t\t/* Try to probe v1 pen parameters */\n\t\t\t\trc = uclogic_params_pen_init_v1(&p.pen,\n\t\t\t\t\t\t\t\t&found, hdev);\n\t\t\t\tif (rc != 0) {\n\t\t\t\t\thid_err(hdev,\n\t\t\t\t\t\t\"pen probing failed: %d\\n\",\n\t\t\t\t\t\trc);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\thid_warn(hdev,\n\t\t\t\t\t\t \"pen parameters not found\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp5540u_fixed);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp8060u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP1062):\n\t\trc = WITH_OPT_DESC(WP1062_ORIG, wp1062_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850):\n\t\tswitch (bInterfaceNumber) {\n\t\tcase 0:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG0, twhl850_fixed0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG1, twhl850_fixed1);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG2, twhl850_fixed2);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60):\n\t\t/*\n\t\t * If it is not a three-interface version, which is known to\n\t\t * respond to initialization.\n\t\t */\n\t\tif (bNumInterfaces != 3) {\n\t\t\tswitch (bInterfaceNumber) {\n\t\t\tcase 0:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG0,\n\t\t\t\t\t\t\ttwha60_fixed0);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG1,\n\t\t\t\t\t\t\ttwha60_fixed1);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_HS64):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_YIYNOVA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_81):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_DRAWIMAGE_G3):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_45):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_47):\n\t\trc = uclogic_params_huion_init(&p, hdev);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GP0610):\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GT5040):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G540):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G640):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_RAINBOW_CV720):\n\t\t/* If this is the pen interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01):\n\t\t/* If this is the pen and frame interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* Initialize frame parameters */\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_arr,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_TRUST,\n\t\t     USB_DEVICE_ID_TRUST_PANORA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_G5):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_arr,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_size,\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_ID);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tp.frame.re_lsb =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_RE_LSB;\n\t\t\tp.frame.dev_id_byte =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_DEV_ID_BYTE;\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_EX07S):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_arr,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\t}\n\n#undef VID_PID\n#undef WITH_OPT_DESC\n\n\t/* Output parameters */\n\tmemcpy(params, &p, sizeof(*params));\n\tmemset(&p, 0, sizeof(p));\n\trc = 0;\ncleanup:\n\tuclogic_params_cleanup(&p);\n\treturn rc;\n}",
                        "cve_id": "CVE-2022-20132"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int uvc_parse_standard_control(struct uvc_device *dev,\n\tconst unsigned char *buffer, int buflen)\n{\n\tstruct usb_device *udev = dev->udev;\n\tstruct uvc_entity *unit, *term;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *alts = dev->intf->cur_altsetting;\n\tunsigned int i, n, p, len;\n\tu16 type;\n\n\tswitch (buffer[2]) {\n\tcase UVC_VC_HEADER:\n\t\tn = buflen >= 12 ? buffer[11] : 0;\n\n\t\tif (buflen < 12 + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d HEADER error\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev->uvc_version = get_unaligned_le16(&buffer[3]);\n\t\tdev->clock_frequency = get_unaligned_le32(&buffer[7]);\n\n\t\t/* Parse all USB Video Streaming interfaces. */\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tintf = usb_ifnum_to_if(udev, buffer[12+i]);\n\t\t\tif (intf == NULL) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d \"\n\t\t\t\t\t\"interface %d doesn't exists\\n\",\n\t\t\t\t\tudev->devnum, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuvc_parse_streaming(dev, intf);\n\t\t}\n\t\tbreak;\n\n\tcase UVC_VC_INPUT_TERMINAL:\n\t\tif (buflen < 8) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * Reject invalid terminal types that would cause issues:\n\t\t *\n\t\t * - The high byte must be non-zero, otherwise it would be\n\t\t *   confused with a unit.\n\t\t *\n\t\t * - Bit 15 must be 0, as we use it internally as a terminal\n\t\t *   direction flag.\n\t\t *\n\t\t * Other unknown types are accepted.\n\t\t */\n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0x7f00) == 0 || (type & 0x8000) != 0) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL %d has invalid \"\n\t\t\t\t\"type 0x%04x, skipping\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber,\n\t\t\t\tbuffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tn = 0;\n\t\tp = 0;\n\t\tlen = 8;\n\n\t\tif (type == UVC_ITT_CAMERA) {\n\t\t\tn = buflen >= 15 ? buffer[14] : 0;\n\t\t\tlen = 15;\n\n\t\t} else if (type == UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tn = buflen >= 9 ? buffer[8] : 0;\n\t\t\tp = buflen >= 10 + n ? buffer[9+n] : 0;\n\t\t\tlen = 10;\n\t\t}\n\n\t\tif (buflen < len + n + p) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_INPUT, buffer[3],\n\t\t\t\t\t1, n + p);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA) {\n\t\t\tterm->camera.bControlSize = n;\n\t\t\tterm->camera.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->camera.wObjectiveFocalLengthMin =\n\t\t\t\tget_unaligned_le16(&buffer[8]);\n\t\t\tterm->camera.wObjectiveFocalLengthMax =\n\t\t\t\tget_unaligned_le16(&buffer[10]);\n\t\t\tterm->camera.wOcularFocalLength =\n\t\t\t\tget_unaligned_le16(&buffer[12]);\n\t\t\tmemcpy(term->camera.bmControls, &buffer[15], n);\n\t\t} else if (UVC_ENTITY_TYPE(term) ==\n\t\t\t   UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tterm->media.bControlSize = n;\n\t\t\tterm->media.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->media.bTransportModeSize = p;\n\t\t\tterm->media.bmTransportModes = (u8 *)term\n\t\t\t\t\t\t     + sizeof(*term) + n;\n\t\t\tmemcpy(term->media.bmControls, &buffer[9], n);\n\t\t\tmemcpy(term->media.bmTransportModes, &buffer[10+n], p);\n\t\t}\n\n\t\tif (buffer[7] != 0)\n\t\t\tusb_string(udev, buffer[7], term->name,\n\t\t\t\t   sizeof(term->name));\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA)\n\t\t\tsprintf(term->name, \"Camera %u\", buffer[3]);\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_MEDIA_TRANSPORT_INPUT)\n\t\t\tsprintf(term->name, \"Media %u\", buffer[3]);\n\t\telse\n\t\t\tsprintf(term->name, \"Input %u\", buffer[3]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_OUTPUT_TERMINAL:\n\t\tif (buflen < 9) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d OUTPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Make sure the terminal type MSB is not null, otherwise it\n\t\t * could be confused with a unit.\n\t\t */\n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0xff00) == 0) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d OUTPUT_TERMINAL %d has invalid \"\n\t\t\t\t\"type 0x%04x, skipping\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber, buffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_OUTPUT, buffer[3],\n\t\t\t\t\t1, 0);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(term->baSourceID, &buffer[7], 1);\n\n\t\tif (buffer[8] != 0)\n\t\t\tusb_string(udev, buffer[8], term->name,\n\t\t\t\t   sizeof(term->name));\n\t\telse\n\t\t\tsprintf(term->name, \"Output %u\", buffer[3]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_SELECTOR_UNIT:\n\t\tp = buflen >= 5 ? buffer[4] : 0;\n\n\t\tif (buflen < 5 || buflen < 6 + p) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d SELECTOR_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, 0);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[5], p);\n\n\t\tif (buffer[5+p] != 0)\n\t\t\tusb_string(udev, buffer[5+p], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Selector %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_PROCESSING_UNIT:\n\t\tn = buflen >= 8 ? buffer[7] : 0;\n\t\tp = dev->uvc_version >= 0x0110 ? 10 : 9;\n\n\t\tif (buflen < p + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d PROCESSING_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], 2, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[4], 1);\n\t\tunit->processing.wMaxMultiplier =\n\t\t\tget_unaligned_le16(&buffer[5]);\n\t\tunit->processing.bControlSize = buffer[7];\n\t\tunit->processing.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->processing.bmControls, &buffer[8], n);\n\t\tif (dev->uvc_version >= 0x0110)\n\t\t\tunit->processing.bmVideoStandards = buffer[9+n];\n\n\t\tif (buffer[8+n] != 0)\n\t\t\tusb_string(udev, buffer[8+n], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Processing %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_EXTENSION_UNIT:\n\t\tp = buflen >= 22 ? buffer[21] : 0;\n\t\tn = buflen >= 24 + p ? buffer[22+p] : 0;\n\n\t\tif (buflen < 24 + p + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d EXTENSION_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->extension.guidExtensionCode, &buffer[4], 16);\n\t\tunit->extension.bNumControls = buffer[20];\n\t\tmemcpy(unit->baSourceID, &buffer[22], p);\n\t\tunit->extension.bControlSize = buffer[22+p];\n\t\tunit->extension.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->extension.bmControls, &buffer[23+p], n);\n\n\t\tif (buffer[23+p+n] != 0)\n\t\t\tusb_string(udev, buffer[23+p+n], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Extension %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tdefault:\n\t\tuvc_trace(UVC_TRACE_DESCR, \"Found an unknown CS_INTERFACE \"\n\t\t\t\"descriptor (%u)\\n\", buffer[2]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nint uclogic_params_init(struct uclogic_params *params,\n\t\t\tstruct hid_device *hdev)\n{\n\tint rc;\n\tstruct usb_device *udev = hid_to_usb_dev(hdev);\n\t__u8  bNumInterfaces = udev->config->desc.bNumInterfaces;\n\tstruct usb_interface *iface = to_usb_interface(hdev->dev.parent);\n\t__u8 bInterfaceNumber = iface->cur_altsetting->desc.bInterfaceNumber;\n\tbool found;\n\t/* The resulting parameters (noop) */\n\tstruct uclogic_params p = {0, };\n\n\t/* Check arguments */\n\tif (params == NULL || hdev == NULL ||\n\t    !hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Set replacement report descriptor if the original matches the\n\t * specified size. Otherwise keep interface unchanged.\n\t */\n#define WITH_OPT_DESC(_orig_desc_token, _new_desc_token) \\\n\tuclogic_params_init_with_opt_desc(                  \\\n\t\t&p, hdev,                                   \\\n\t\tUCLOGIC_RDESC_##_orig_desc_token##_SIZE,    \\\n\t\tuclogic_rdesc_##_new_desc_token##_arr,      \\\n\t\tuclogic_rdesc_##_new_desc_token##_size)\n\n#define VID_PID(_vid, _pid) \\\n\t(((__u32)(_vid) << 16) | ((__u32)(_pid) & U16_MAX))\n\n\t/*\n\t * Handle specific interfaces for specific tablets.\n\t *\n\t * Observe the following logic:\n\t *\n\t * If the interface is recognized as producing certain useful input:\n\t *\tMark interface as valid.\n\t *\tOutput interface parameters.\n\t * Else, if the interface is recognized as *not* producing any useful\n\t * input:\n\t *\tMark interface as invalid.\n\t * Else:\n\t *\tMark interface as valid.\n\t *\tOutput noop parameters.\n\t *\n\t * Rule of thumb: it is better to disable a broken interface than let\n\t *\t\t  it spew garbage input.\n\t */\n\n\tswitch (VID_PID(hdev->vendor, hdev->product)) {\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_PF1209):\n\t\trc = WITH_OPT_DESC(PF1209_ORIG, pf1209_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp4030u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U):\n\t\tif (hdev->dev_rsize == UCLOGIC_RDESC_WP5540U_V2_ORIG_SIZE) {\n\t\t\tif (bInterfaceNumber == 0) {\n\t\t\t\t/* Try to probe v1 pen parameters */\n\t\t\t\trc = uclogic_params_pen_init_v1(&p.pen,\n\t\t\t\t\t\t\t\t&found, hdev);\n\t\t\t\tif (rc != 0) {\n\t\t\t\t\thid_err(hdev,\n\t\t\t\t\t\t\"pen probing failed: %d\\n\",\n\t\t\t\t\t\trc);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\thid_warn(hdev,\n\t\t\t\t\t\t \"pen parameters not found\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp5540u_fixed);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp8060u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP1062):\n\t\trc = WITH_OPT_DESC(WP1062_ORIG, wp1062_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850):\n\t\tswitch (bInterfaceNumber) {\n\t\tcase 0:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG0, twhl850_fixed0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG1, twhl850_fixed1);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG2, twhl850_fixed2);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60):\n\t\t/*\n\t\t * If it is not a three-interface version, which is known to\n\t\t * respond to initialization.\n\t\t */\n\t\tif (bNumInterfaces != 3) {\n\t\t\tswitch (bInterfaceNumber) {\n\t\t\tcase 0:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG0,\n\t\t\t\t\t\t\ttwha60_fixed0);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG1,\n\t\t\t\t\t\t\ttwha60_fixed1);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_HS64):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_YIYNOVA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_81):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_DRAWIMAGE_G3):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_45):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_47):\n\t\trc = uclogic_params_huion_init(&p, hdev);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GP0610):\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GT5040):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G540):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G640):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_RAINBOW_CV720):\n\t\t/* If this is the pen interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01):\n\t\t/* If this is the pen and frame interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* Initialize frame parameters */\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_arr,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_TRUST,\n\t\t     USB_DEVICE_ID_TRUST_PANORA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_G5):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_arr,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_size,\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_ID);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tp.frame.re_lsb =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_RE_LSB;\n\t\t\tp.frame.dev_id_byte =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_DEV_ID_BYTE;\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_EX07S):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_arr,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\t}\n\n#undef VID_PID\n#undef WITH_OPT_DESC\n\n\t/* Output parameters */\n\tmemcpy(params, &p, sizeof(*params));\n\tmemset(&p, 0, sizeof(p));\n\trc = 0;\ncleanup:\n\tuclogic_params_cleanup(&p);\n\treturn rc;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint uclogic_params_init(struct uclogic_params *params,\n\t\t\tstruct hid_device *hdev)\n{\n\tint rc;\n\tstruct usb_device *udev = hid_to_usb_dev(hdev);\n\t__u8  bNumInterfaces = udev->config->desc.bNumInterfaces;\n\tstruct usb_interface *iface = to_usb_interface(hdev->dev.parent);\n\t__u8 bInterfaceNumber = iface->cur_altsetting->desc.bInterfaceNumber;\n\tbool found;\n\t/* The resulting parameters (noop) */\n\tstruct uclogic_params p = {0, };\n\n\t/* Check arguments */\n\tif (params == NULL || hdev == NULL || !hid_is_usb(hdev)) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Set replacement report descriptor if the original matches the\n\t * specified size. Otherwise keep interface unchanged.\n\t */\n#define WITH_OPT_DESC(_orig_desc_token, _new_desc_token) \\\n\tuclogic_params_init_with_opt_desc(                  \\\n\t\t&p, hdev,                                   \\\n\t\tUCLOGIC_RDESC_##_orig_desc_token##_SIZE,    \\\n\t\tuclogic_rdesc_##_new_desc_token##_arr,      \\\n\t\tuclogic_rdesc_##_new_desc_token##_size)\n\n#define VID_PID(_vid, _pid) \\\n\t(((__u32)(_vid) << 16) | ((__u32)(_pid) & U16_MAX))\n\n\t/*\n\t * Handle specific interfaces for specific tablets.\n\t *\n\t * Observe the following logic:\n\t *\n\t * If the interface is recognized as producing certain useful input:\n\t *\tMark interface as valid.\n\t *\tOutput interface parameters.\n\t * Else, if the interface is recognized as *not* producing any useful\n\t * input:\n\t *\tMark interface as invalid.\n\t * Else:\n\t *\tMark interface as valid.\n\t *\tOutput noop parameters.\n\t *\n\t * Rule of thumb: it is better to disable a broken interface than let\n\t *\t\t  it spew garbage input.\n\t */\n\n\tswitch (VID_PID(hdev->vendor, hdev->product)) {\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_PF1209):\n\t\trc = WITH_OPT_DESC(PF1209_ORIG, pf1209_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp4030u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U):\n\t\tif (hdev->dev_rsize == UCLOGIC_RDESC_WP5540U_V2_ORIG_SIZE) {\n\t\t\tif (bInterfaceNumber == 0) {\n\t\t\t\t/* Try to probe v1 pen parameters */\n\t\t\t\trc = uclogic_params_pen_init_v1(&p.pen,\n\t\t\t\t\t\t\t\t&found, hdev);\n\t\t\t\tif (rc != 0) {\n\t\t\t\t\thid_err(hdev,\n\t\t\t\t\t\t\"pen probing failed: %d\\n\",\n\t\t\t\t\t\trc);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\thid_warn(hdev,\n\t\t\t\t\t\t \"pen parameters not found\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp5540u_fixed);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp8060u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP1062):\n\t\trc = WITH_OPT_DESC(WP1062_ORIG, wp1062_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850):\n\t\tswitch (bInterfaceNumber) {\n\t\tcase 0:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG0, twhl850_fixed0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG1, twhl850_fixed1);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG2, twhl850_fixed2);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60):\n\t\t/*\n\t\t * If it is not a three-interface version, which is known to\n\t\t * respond to initialization.\n\t\t */\n\t\tif (bNumInterfaces != 3) {\n\t\t\tswitch (bInterfaceNumber) {\n\t\t\tcase 0:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG0,\n\t\t\t\t\t\t\ttwha60_fixed0);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG1,\n\t\t\t\t\t\t\ttwha60_fixed1);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_HS64):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_YIYNOVA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_81):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_DRAWIMAGE_G3):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_45):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_47):\n\t\trc = uclogic_params_huion_init(&p, hdev);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GP0610):\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GT5040):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G540):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G640):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_RAINBOW_CV720):\n\t\t/* If this is the pen interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01):\n\t\t/* If this is the pen and frame interface */\n\t\tif (bInterfaceNumber == 1) {\n\t\t\t/* Probe v1 pen parameters */\n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* Initialize frame parameters */\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_arr,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\t/* TODO: Consider marking the interface invalid */\n\t\t\tuclogic_params_init_with_pen_unused(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_TRUST,\n\t\t     USB_DEVICE_ID_TRUST_PANORA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_G5):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_arr,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_size,\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_ID);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tp.frame.re_lsb =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_RE_LSB;\n\t\t\tp.frame.dev_id_byte =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_DEV_ID_BYTE;\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_EX07S):\n\t\t/* Ignore non-pen interfaces */\n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_arr,\n\t\t\t\tuclogic_rdesc_ugee_ex07_buttonpad_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating buttonpad parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\t}\n\n#undef VID_PID\n#undef WITH_OPT_DESC\n\n\t/* Output parameters */\n\tmemcpy(params, &p, sizeof(*params));\n\tmemset(&p, 0, sizeof(p));\n\trc = 0;\ncleanup:\n\tuclogic_params_cleanup(&p);\n\treturn rc;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\t\tlength = cap->bLength;\n\n\t\tif (total_len < length)\n\t\t\tbreak;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}",
                        "code_after_change": "int usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\n\t\tif (total_len < sizeof(*cap) || total_len < cap->bLength) {\n\t\t\tdev->bos->desc->bNumDeviceCaps = i;\n\t\t\tbreak;\n\t\t}\n\t\tlength = cap->bLength;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-16535"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int uvc_parse_standard_control(struct uvc_device *dev,\n\tconst unsigned char *buffer, int buflen)\n{\n\tstruct usb_device *udev = dev->udev;\n\tstruct uvc_entity *unit, *term;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *alts = dev->intf->cur_altsetting;\n\tunsigned int i, n, p, len;\n\tu16 type;\n\n\tswitch (buffer[2]) {\n\tcase UVC_VC_HEADER:\n\t\tn = buflen >= 12 ? buffer[11] : 0;\n\n\t\tif (buflen < 12 + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d HEADER error\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev->uvc_version = get_unaligned_le16(&buffer[3]);\n\t\tdev->clock_frequency = get_unaligned_le32(&buffer[7]);\n\n\t\t/* Parse all USB Video Streaming interfaces. */\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tintf = usb_ifnum_to_if(udev, buffer[12+i]);\n\t\t\tif (intf == NULL) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d \"\n\t\t\t\t\t\"interface %d doesn't exists\\n\",\n\t\t\t\t\tudev->devnum, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuvc_parse_streaming(dev, intf);\n\t\t}\n\t\tbreak;\n\n\tcase UVC_VC_INPUT_TERMINAL:\n\t\tif (buflen < 8) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * Reject invalid terminal types that would cause issues:\n\t\t *\n\t\t * - The high byte must be non-zero, otherwise it would be\n\t\t *   confused with a unit.\n\t\t *\n\t\t * - Bit 15 must be 0, as we use it internally as a terminal\n\t\t *   direction flag.\n\t\t *\n\t\t * Other unknown types are accepted.\n\t\t */\n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0x7f00) == 0 || (type & 0x8000) != 0) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL %d has invalid \"\n\t\t\t\t\"type 0x%04x, skipping\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber,\n\t\t\t\tbuffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tn = 0;\n\t\tp = 0;\n\t\tlen = 8;\n\n\t\tif (type == UVC_ITT_CAMERA) {\n\t\t\tn = buflen >= 15 ? buffer[14] : 0;\n\t\t\tlen = 15;\n\n\t\t} else if (type == UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tn = buflen >= 9 ? buffer[8] : 0;\n\t\t\tp = buflen >= 10 + n ? buffer[9+n] : 0;\n\t\t\tlen = 10;\n\t\t}\n\n\t\tif (buflen < len + n + p) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d INPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_INPUT, buffer[3],\n\t\t\t\t\t1, n + p);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA) {\n\t\t\tterm->camera.bControlSize = n;\n\t\t\tterm->camera.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->camera.wObjectiveFocalLengthMin =\n\t\t\t\tget_unaligned_le16(&buffer[8]);\n\t\t\tterm->camera.wObjectiveFocalLengthMax =\n\t\t\t\tget_unaligned_le16(&buffer[10]);\n\t\t\tterm->camera.wOcularFocalLength =\n\t\t\t\tget_unaligned_le16(&buffer[12]);\n\t\t\tmemcpy(term->camera.bmControls, &buffer[15], n);\n\t\t} else if (UVC_ENTITY_TYPE(term) ==\n\t\t\t   UVC_ITT_MEDIA_TRANSPORT_INPUT) {\n\t\t\tterm->media.bControlSize = n;\n\t\t\tterm->media.bmControls = (u8 *)term + sizeof(*term);\n\t\t\tterm->media.bTransportModeSize = p;\n\t\t\tterm->media.bmTransportModes = (u8 *)term\n\t\t\t\t\t\t     + sizeof(*term) + n;\n\t\t\tmemcpy(term->media.bmControls, &buffer[9], n);\n\t\t\tmemcpy(term->media.bmTransportModes, &buffer[10+n], p);\n\t\t}\n\n\t\tif (buffer[7] != 0)\n\t\t\tusb_string(udev, buffer[7], term->name,\n\t\t\t\t   sizeof(term->name));\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA)\n\t\t\tsprintf(term->name, \"Camera %u\", buffer[3]);\n\t\telse if (UVC_ENTITY_TYPE(term) == UVC_ITT_MEDIA_TRANSPORT_INPUT)\n\t\t\tsprintf(term->name, \"Media %u\", buffer[3]);\n\t\telse\n\t\t\tsprintf(term->name, \"Input %u\", buffer[3]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_OUTPUT_TERMINAL:\n\t\tif (buflen < 9) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d OUTPUT_TERMINAL error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Make sure the terminal type MSB is not null, otherwise it\n\t\t * could be confused with a unit.\n\t\t */\n\t\ttype = get_unaligned_le16(&buffer[4]);\n\t\tif ((type & 0xff00) == 0) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d OUTPUT_TERMINAL %d has invalid \"\n\t\t\t\t\"type 0x%04x, skipping\\n\", udev->devnum,\n\t\t\t\talts->desc.bInterfaceNumber, buffer[3], type);\n\t\t\treturn 0;\n\t\t}\n\n\t\tterm = uvc_alloc_entity(type | UVC_TERM_OUTPUT, buffer[3],\n\t\t\t\t\t1, 0);\n\t\tif (term == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(term->baSourceID, &buffer[7], 1);\n\n\t\tif (buffer[8] != 0)\n\t\t\tusb_string(udev, buffer[8], term->name,\n\t\t\t\t   sizeof(term->name));\n\t\telse\n\t\t\tsprintf(term->name, \"Output %u\", buffer[3]);\n\n\t\tlist_add_tail(&term->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_SELECTOR_UNIT:\n\t\tp = buflen >= 5 ? buffer[4] : 0;\n\n\t\tif (buflen < 5 || buflen < 6 + p) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d SELECTOR_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, 0);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[5], p);\n\n\t\tif (buffer[5+p] != 0)\n\t\t\tusb_string(udev, buffer[5+p], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Selector %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_PROCESSING_UNIT:\n\t\tn = buflen >= 8 ? buffer[7] : 0;\n\t\tp = dev->uvc_version >= 0x0110 ? 10 : 9;\n\n\t\tif (buflen < p + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d PROCESSING_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], 2, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->baSourceID, &buffer[4], 1);\n\t\tunit->processing.wMaxMultiplier =\n\t\t\tget_unaligned_le16(&buffer[5]);\n\t\tunit->processing.bControlSize = buffer[7];\n\t\tunit->processing.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->processing.bmControls, &buffer[8], n);\n\t\tif (dev->uvc_version >= 0x0110)\n\t\t\tunit->processing.bmVideoStandards = buffer[9+n];\n\n\t\tif (buffer[8+n] != 0)\n\t\t\tusb_string(udev, buffer[8+n], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Processing %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tcase UVC_VC_EXTENSION_UNIT:\n\t\tp = buflen >= 22 ? buffer[21] : 0;\n\t\tn = buflen >= 24 + p ? buffer[22+p] : 0;\n\n\t\tif (buflen < 24 + p + n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videocontrol \"\n\t\t\t\t\"interface %d EXTENSION_UNIT error\\n\",\n\t\t\t\tudev->devnum, alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tunit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, n);\n\t\tif (unit == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(unit->extension.guidExtensionCode, &buffer[4], 16);\n\t\tunit->extension.bNumControls = buffer[20];\n\t\tmemcpy(unit->baSourceID, &buffer[22], p);\n\t\tunit->extension.bControlSize = buffer[22+p];\n\t\tunit->extension.bmControls = (u8 *)unit + sizeof(*unit);\n\t\tmemcpy(unit->extension.bmControls, &buffer[23+p], n);\n\n\t\tif (buffer[23+p+n] != 0)\n\t\t\tusb_string(udev, buffer[23+p+n], unit->name,\n\t\t\t\t   sizeof(unit->name));\n\t\telse\n\t\t\tsprintf(unit->name, \"Extension %u\", buffer[3]);\n\n\t\tlist_add_tail(&unit->list, &dev->entities);\n\t\tbreak;\n\n\tdefault:\n\t\tuvc_trace(UVC_TRACE_DESCR, \"Found an unknown CS_INTERFACE \"\n\t\t\t\"descriptor (%u)\\n\", buffer[2]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nint usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\t\tlength = cap->bLength;\n\n\t\tif (total_len < length)\n\t\t\tbreak;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\n\t\tif (total_len < sizeof(*cap) || total_len < cap->bLength) {\n\t\t\tdev->bos->desc->bNumDeviceCaps = i;\n\t\t\tbreak;\n\t\t}\n\t\tlength = cap->bLength;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3765,
            "cve_id": "CVE-2022-47520",
            "code_snippet": "void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\t\t\t\tstruct cfg80211_crypto_settings *crypto)\n{\n\tstruct wilc_join_bss_param *param;\n\tstruct ieee80211_p2p_noa_attr noa_attr;\n\tu8 rates_len = 0;\n\tconst u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;\n\tconst u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;\n\tint ret;\n\tconst struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn NULL;\n\n\tparam->beacon_period = cpu_to_le16(bss->beacon_interval);\n\tparam->cap_info = cpu_to_le16(bss->capability);\n\tparam->bss_type = WILC_FW_BSS_TYPE_INFRA;\n\tparam->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tether_addr_copy(param->bssid, bss->bssid);\n\n\tssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (ssid_elm) {\n\t\tif (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)\n\t\t\tmemcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);\n\t}\n\n\ttim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tif (tim_elm && tim_elm[1] >= 2)\n\t\tparam->dtim_period = tim_elm[3];\n\n\tmemset(param->p_suites, 0xFF, 3);\n\tmemset(param->akm_suites, 0xFF, 3);\n\n\trates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);\n\tif (rates_ie) {\n\t\trates_len = rates_ie[1];\n\t\tif (rates_len > WILC_MAX_RATES_SUPPORTED)\n\t\t\trates_len = WILC_MAX_RATES_SUPPORTED;\n\t\tparam->supp_rates[0] = rates_len;\n\t\tmemcpy(&param->supp_rates[1], rates_ie + 2, rates_len);\n\t}\n\n\tif (rates_len < WILC_MAX_RATES_SUPPORTED) {\n\t\tsupp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t\t ies->data, ies->len);\n\t\tif (supp_rates_ie) {\n\t\t\tu8 ext_rates = supp_rates_ie[1];\n\n\t\t\tif (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))\n\t\t\t\tparam->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;\n\t\t\telse\n\t\t\t\tparam->supp_rates[0] += ext_rates;\n\n\t\t\tmemcpy(&param->supp_rates[rates_len + 1],\n\t\t\t       supp_rates_ie + 2,\n\t\t\t       (param->supp_rates[0] - rates_len));\n\t\t}\n\t}\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);\n\tif (ht_ie)\n\t\tparam->ht_capable = true;\n\n\tret = cfg80211_get_p2p_attr(ies->data, ies->len,\n\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t    (u8 *)&noa_attr, sizeof(noa_attr));\n\tif (ret > 0) {\n\t\tparam->tsf_lo = cpu_to_le32(ies->tsf);\n\t\tparam->noa_enabled = 1;\n\t\tparam->idx = noa_attr.index;\n\t\tif (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {\n\t\t\tparam->opp_enabled = 1;\n\t\t\tparam->opp_en.ct_window = noa_attr.oppps_ctwindow;\n\t\t\tparam->opp_en.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_en.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_en.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_en.start_time = noa_attr.desc[0].start_time;\n\t\t} else {\n\t\t\tparam->opp_enabled = 0;\n\t\t\tparam->opp_dis.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_dis.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_dis.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_dis.start_time = noa_attr.desc[0].start_time;\n\t\t}\n\t}\n\twmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wmm_ie) {\n\t\tstruct ieee80211_wmm_param_ie *ie;\n\n\t\tie = (struct ieee80211_wmm_param_ie *)wmm_ie;\n\t\tif ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&\n\t\t    ie->version == 1) {\n\t\t\tparam->wmm_cap = true;\n\t\t\tif (ie->qos_info & BIT(7))\n\t\t\t\tparam->uapsd_cap = true;\n\t\t}\n\t}\n\n\twpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wpa_ie) {\n\t\tparam->mode_802_11i = 1;\n\t\tparam->rsn_found = true;\n\t}\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n\tif (rsn_ie) {\n\t\tint rsn_ie_len = sizeof(struct element) + rsn_ie[1];\n\t\tint offset = 8;\n\n\t\t/* extract RSN capabilities */\n\t\tif (offset < rsn_ie_len) {\n\t\t\t/* skip over pairwise suites */\n\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n\n\t\t\tif (offset < rsn_ie_len) {\n\t\t\t\t/* skip over authentication suites */\n\t\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n\n\t\t\t\tif (offset + 1 < rsn_ie_len) {\n\t\t\t\t\tparam->mode_802_11i = 2;\n\t\t\t\t\tparam->rsn_found = true;\n\t\t\t\t\tmemcpy(param->rsn_cap, &rsn_ie[offset], 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (param->rsn_found) {\n\t\tint i;\n\n\t\tparam->rsn_grp_policy = crypto->cipher_group & 0xFF;\n\t\tfor (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)\n\t\t\tparam->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;\n\n\t\tfor (i = 0; i < crypto->n_akm_suites && i < 3; i++)\n\t\t\tparam->akm_suites[i] = crypto->akm_suites[i] & 0xFF;\n\t}\n\n\treturn (void *)param;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "code_after_change": "static int technisat_usb2_get_ir(struct dvb_usb_device *d)\n{\n\tstruct technisat_usb2_state *state = d->priv;\n\tstruct ir_raw_event ev;\n\tu8 *buf = state->buf;\n\tint i, ret;\n\n\tbuf[0] = GET_IR_DATA_VENDOR_REQUEST;\n\tbuf[1] = 0x08;\n\tbuf[2] = 0x8f;\n\tbuf[3] = MINIMUM_IR_BIT_TRANSITION_TICK_COUNT;\n\tbuf[4] = MAXIMUM_IR_BIT_TIME_TICK_COUNT;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t0, 0,\n\t\t\tbuf, 5, 500);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t0x8080, 0,\n\t\t\tbuf, 62, 500);\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 1)\n\t\treturn 0; /* no key pressed */\n\n\t/* decoding */\n\n#if 0\n\tdeb_rc(\"RC: %d \", ret);\n\tdebug_dump(buf + 1, ret, deb_rc);\n#endif\n\n\tev.pulse = 0;\n\tfor (i = 1; i < ARRAY_SIZE(state->buf); i++) {\n\t\tif (buf[i] == 0xff) {\n\t\t\tev.pulse = 0;\n\t\t\tev.duration = 888888*2;\n\t\t\tir_raw_event_store(d->rc_dev, &ev);\n\t\t\tbreak;\n\t\t}\n\n\t\tev.pulse = !ev.pulse;\n\t\tev.duration = (buf[i] * FIRMWARE_CLOCK_DIVISOR *\n\t\t\t       FIRMWARE_CLOCK_TICK) / 1000;\n\t\tir_raw_event_store(d->rc_dev, &ev);\n\t}\n\n\tir_raw_event_handle(d->rc_dev);\n\n\treturn 1;\n}",
                        "cve_id": "CVE-2016-10208"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\t\t\t\tstruct cfg80211_crypto_settings *crypto)\n{\n\tstruct wilc_join_bss_param *param;\n\tstruct ieee80211_p2p_noa_attr noa_attr;\n\tu8 rates_len = 0;\n\tconst u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;\n\tconst u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;\n\tint ret;\n\tconst struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn NULL;\n\n\tparam->beacon_period = cpu_to_le16(bss->beacon_interval);\n\tparam->cap_info = cpu_to_le16(bss->capability);\n\tparam->bss_type = WILC_FW_BSS_TYPE_INFRA;\n\tparam->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tether_addr_copy(param->bssid, bss->bssid);\n\n\tssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (ssid_elm) {\n\t\tif (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)\n\t\t\tmemcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);\n\t}\n\n\ttim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tif (tim_elm && tim_elm[1] >= 2)\n\t\tparam->dtim_period = tim_elm[3];\n\n\tmemset(param->p_suites, 0xFF, 3);\n\tmemset(param->akm_suites, 0xFF, 3);\n\n\trates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);\n\tif (rates_ie) {\n\t\trates_len = rates_ie[1];\n\t\tif (rates_len > WILC_MAX_RATES_SUPPORTED)\n\t\t\trates_len = WILC_MAX_RATES_SUPPORTED;\n\t\tparam->supp_rates[0] = rates_len;\n\t\tmemcpy(&param->supp_rates[1], rates_ie + 2, rates_len);\n\t}\n\n\tif (rates_len < WILC_MAX_RATES_SUPPORTED) {\n\t\tsupp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t\t ies->data, ies->len);\n\t\tif (supp_rates_ie) {\n\t\t\tu8 ext_rates = supp_rates_ie[1];\n\n\t\t\tif (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))\n\t\t\t\tparam->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;\n\t\t\telse\n\t\t\t\tparam->supp_rates[0] += ext_rates;\n\n\t\t\tmemcpy(&param->supp_rates[rates_len + 1],\n\t\t\t       supp_rates_ie + 2,\n\t\t\t       (param->supp_rates[0] - rates_len));\n\t\t}\n\t}\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);\n\tif (ht_ie)\n\t\tparam->ht_capable = true;\n\n\tret = cfg80211_get_p2p_attr(ies->data, ies->len,\n\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t    (u8 *)&noa_attr, sizeof(noa_attr));\n\tif (ret > 0) {\n\t\tparam->tsf_lo = cpu_to_le32(ies->tsf);\n\t\tparam->noa_enabled = 1;\n\t\tparam->idx = noa_attr.index;\n\t\tif (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {\n\t\t\tparam->opp_enabled = 1;\n\t\t\tparam->opp_en.ct_window = noa_attr.oppps_ctwindow;\n\t\t\tparam->opp_en.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_en.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_en.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_en.start_time = noa_attr.desc[0].start_time;\n\t\t} else {\n\t\t\tparam->opp_enabled = 0;\n\t\t\tparam->opp_dis.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_dis.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_dis.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_dis.start_time = noa_attr.desc[0].start_time;\n\t\t}\n\t}\n\twmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wmm_ie) {\n\t\tstruct ieee80211_wmm_param_ie *ie;\n\n\t\tie = (struct ieee80211_wmm_param_ie *)wmm_ie;\n\t\tif ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&\n\t\t    ie->version == 1) {\n\t\t\tparam->wmm_cap = true;\n\t\t\tif (ie->qos_info & BIT(7))\n\t\t\t\tparam->uapsd_cap = true;\n\t\t}\n\t}\n\n\twpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wpa_ie) {\n\t\tparam->mode_802_11i = 1;\n\t\tparam->rsn_found = true;\n\t}\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n\tif (rsn_ie) {\n\t\tint rsn_ie_len = sizeof(struct element) + rsn_ie[1];\n\t\tint offset = 8;\n\n\t\t/* extract RSN capabilities */\n\t\tif (offset < rsn_ie_len) {\n\t\t\t/* skip over pairwise suites */\n\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n\n\t\t\tif (offset < rsn_ie_len) {\n\t\t\t\t/* skip over authentication suites */\n\t\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n\n\t\t\t\tif (offset + 1 < rsn_ie_len) {\n\t\t\t\t\tparam->mode_802_11i = 2;\n\t\t\t\t\tparam->rsn_found = true;\n\t\t\t\t\tmemcpy(param->rsn_cap, &rsn_ie[offset], 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (param->rsn_found) {\n\t\tint i;\n\n\t\tparam->rsn_grp_policy = crypto->cipher_group & 0xFF;\n\t\tfor (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)\n\t\t\tparam->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;\n\n\t\tfor (i = 0; i < crypto->n_akm_suites && i < 3; i++)\n\t\t\tparam->akm_suites[i] = crypto->akm_suites[i] & 0xFF;\n\t}\n\n\treturn (void *)param;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int technisat_usb2_get_ir(struct dvb_usb_device *d)\n{\n\tstruct technisat_usb2_state *state = d->priv;\n\tstruct ir_raw_event ev;\n\tu8 *buf = state->buf;\n\tint i, ret;\n\n\tbuf[0] = GET_IR_DATA_VENDOR_REQUEST;\n\tbuf[1] = 0x08;\n\tbuf[2] = 0x8f;\n\tbuf[3] = MINIMUM_IR_BIT_TRANSITION_TICK_COUNT;\n\tbuf[4] = MAXIMUM_IR_BIT_TIME_TICK_COUNT;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t0, 0,\n\t\t\tbuf, 5, 500);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tbuf[1] = 0;\n\tbuf[2] = 0;\n\tret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\n\t\t\tGET_IR_DATA_VENDOR_REQUEST,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t0x8080, 0,\n\t\t\tbuf, 62, 500);\n\nunlock:\n\tmutex_unlock(&d->i2c_mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 1)\n\t\treturn 0; /* no key pressed */\n\n\t/* decoding */\n\n#if 0\n\tdeb_rc(\"RC: %d \", ret);\n\tdebug_dump(buf + 1, ret, deb_rc);\n#endif\n\n\tev.pulse = 0;\n\tfor (i = 1; i < ARRAY_SIZE(state->buf); i++) {\n\t\tif (buf[i] == 0xff) {\n\t\t\tev.pulse = 0;\n\t\t\tev.duration = 888888*2;\n\t\t\tir_raw_event_store(d->rc_dev, &ev);\n\t\t\tbreak;\n\t\t}\n\n\t\tev.pulse = !ev.pulse;\n\t\tev.duration = (buf[i] * FIRMWARE_CLOCK_DIVISOR *\n\t\t\t       FIRMWARE_CLOCK_TICK) / 1000;\n\t\tir_raw_event_store(d->rc_dev, &ev);\n\t}\n\n\tir_raw_event_handle(d->rc_dev);\n\n\treturn 1;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* Validate length */\n\tif (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))\n\t\treturn -EINVAL;\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}",
                        "code_after_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "cve_id": "CVE-2015-9289"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\t\t\t\tstruct cfg80211_crypto_settings *crypto)\n{\n\tstruct wilc_join_bss_param *param;\n\tstruct ieee80211_p2p_noa_attr noa_attr;\n\tu8 rates_len = 0;\n\tconst u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;\n\tconst u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;\n\tint ret;\n\tconst struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn NULL;\n\n\tparam->beacon_period = cpu_to_le16(bss->beacon_interval);\n\tparam->cap_info = cpu_to_le16(bss->capability);\n\tparam->bss_type = WILC_FW_BSS_TYPE_INFRA;\n\tparam->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tether_addr_copy(param->bssid, bss->bssid);\n\n\tssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (ssid_elm) {\n\t\tif (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)\n\t\t\tmemcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);\n\t}\n\n\ttim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tif (tim_elm && tim_elm[1] >= 2)\n\t\tparam->dtim_period = tim_elm[3];\n\n\tmemset(param->p_suites, 0xFF, 3);\n\tmemset(param->akm_suites, 0xFF, 3);\n\n\trates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);\n\tif (rates_ie) {\n\t\trates_len = rates_ie[1];\n\t\tif (rates_len > WILC_MAX_RATES_SUPPORTED)\n\t\t\trates_len = WILC_MAX_RATES_SUPPORTED;\n\t\tparam->supp_rates[0] = rates_len;\n\t\tmemcpy(&param->supp_rates[1], rates_ie + 2, rates_len);\n\t}\n\n\tif (rates_len < WILC_MAX_RATES_SUPPORTED) {\n\t\tsupp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t\t ies->data, ies->len);\n\t\tif (supp_rates_ie) {\n\t\t\tu8 ext_rates = supp_rates_ie[1];\n\n\t\t\tif (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))\n\t\t\t\tparam->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;\n\t\t\telse\n\t\t\t\tparam->supp_rates[0] += ext_rates;\n\n\t\t\tmemcpy(&param->supp_rates[rates_len + 1],\n\t\t\t       supp_rates_ie + 2,\n\t\t\t       (param->supp_rates[0] - rates_len));\n\t\t}\n\t}\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);\n\tif (ht_ie)\n\t\tparam->ht_capable = true;\n\n\tret = cfg80211_get_p2p_attr(ies->data, ies->len,\n\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t    (u8 *)&noa_attr, sizeof(noa_attr));\n\tif (ret > 0) {\n\t\tparam->tsf_lo = cpu_to_le32(ies->tsf);\n\t\tparam->noa_enabled = 1;\n\t\tparam->idx = noa_attr.index;\n\t\tif (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {\n\t\t\tparam->opp_enabled = 1;\n\t\t\tparam->opp_en.ct_window = noa_attr.oppps_ctwindow;\n\t\t\tparam->opp_en.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_en.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_en.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_en.start_time = noa_attr.desc[0].start_time;\n\t\t} else {\n\t\t\tparam->opp_enabled = 0;\n\t\t\tparam->opp_dis.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_dis.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_dis.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_dis.start_time = noa_attr.desc[0].start_time;\n\t\t}\n\t}\n\twmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wmm_ie) {\n\t\tstruct ieee80211_wmm_param_ie *ie;\n\n\t\tie = (struct ieee80211_wmm_param_ie *)wmm_ie;\n\t\tif ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&\n\t\t    ie->version == 1) {\n\t\t\tparam->wmm_cap = true;\n\t\t\tif (ie->qos_info & BIT(7))\n\t\t\t\tparam->uapsd_cap = true;\n\t\t}\n\t}\n\n\twpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wpa_ie) {\n\t\tparam->mode_802_11i = 1;\n\t\tparam->rsn_found = true;\n\t}\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n\tif (rsn_ie) {\n\t\tint rsn_ie_len = sizeof(struct element) + rsn_ie[1];\n\t\tint offset = 8;\n\n\t\t/* extract RSN capabilities */\n\t\tif (offset < rsn_ie_len) {\n\t\t\t/* skip over pairwise suites */\n\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n\n\t\t\tif (offset < rsn_ie_len) {\n\t\t\t\t/* skip over authentication suites */\n\t\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n\n\t\t\t\tif (offset + 1 < rsn_ie_len) {\n\t\t\t\t\tparam->mode_802_11i = 2;\n\t\t\t\t\tparam->rsn_found = true;\n\t\t\t\t\tmemcpy(param->rsn_cap, &rsn_ie[offset], 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (param->rsn_found) {\n\t\tint i;\n\n\t\tparam->rsn_grp_policy = crypto->cipher_group & 0xFF;\n\t\tfor (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)\n\t\t\tparam->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;\n\n\t\tfor (i = 0; i < crypto->n_akm_suites && i < 3; i++)\n\t\t\tparam->akm_suites[i] = crypto->akm_suites[i] & 0xFF;\n\t}\n\n\treturn (void *)param;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* Validate length */\n\tif (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))\n\t\treturn -EINVAL;\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "code_after_change": "static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Validate length */\n\tif (d->msg_len > sizeof(d->msg))\n                return -EINVAL;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2019-15927"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nvoid *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\t\t\t\tstruct cfg80211_crypto_settings *crypto)\n{\n\tstruct wilc_join_bss_param *param;\n\tstruct ieee80211_p2p_noa_attr noa_attr;\n\tu8 rates_len = 0;\n\tconst u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;\n\tconst u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;\n\tint ret;\n\tconst struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn NULL;\n\n\tparam->beacon_period = cpu_to_le16(bss->beacon_interval);\n\tparam->cap_info = cpu_to_le16(bss->capability);\n\tparam->bss_type = WILC_FW_BSS_TYPE_INFRA;\n\tparam->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tether_addr_copy(param->bssid, bss->bssid);\n\n\tssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (ssid_elm) {\n\t\tif (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)\n\t\t\tmemcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);\n\t}\n\n\ttim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tif (tim_elm && tim_elm[1] >= 2)\n\t\tparam->dtim_period = tim_elm[3];\n\n\tmemset(param->p_suites, 0xFF, 3);\n\tmemset(param->akm_suites, 0xFF, 3);\n\n\trates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);\n\tif (rates_ie) {\n\t\trates_len = rates_ie[1];\n\t\tif (rates_len > WILC_MAX_RATES_SUPPORTED)\n\t\t\trates_len = WILC_MAX_RATES_SUPPORTED;\n\t\tparam->supp_rates[0] = rates_len;\n\t\tmemcpy(&param->supp_rates[1], rates_ie + 2, rates_len);\n\t}\n\n\tif (rates_len < WILC_MAX_RATES_SUPPORTED) {\n\t\tsupp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t\t ies->data, ies->len);\n\t\tif (supp_rates_ie) {\n\t\t\tu8 ext_rates = supp_rates_ie[1];\n\n\t\t\tif (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))\n\t\t\t\tparam->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;\n\t\t\telse\n\t\t\t\tparam->supp_rates[0] += ext_rates;\n\n\t\t\tmemcpy(&param->supp_rates[rates_len + 1],\n\t\t\t       supp_rates_ie + 2,\n\t\t\t       (param->supp_rates[0] - rates_len));\n\t\t}\n\t}\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);\n\tif (ht_ie)\n\t\tparam->ht_capable = true;\n\n\tret = cfg80211_get_p2p_attr(ies->data, ies->len,\n\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t    (u8 *)&noa_attr, sizeof(noa_attr));\n\tif (ret > 0) {\n\t\tparam->tsf_lo = cpu_to_le32(ies->tsf);\n\t\tparam->noa_enabled = 1;\n\t\tparam->idx = noa_attr.index;\n\t\tif (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {\n\t\t\tparam->opp_enabled = 1;\n\t\t\tparam->opp_en.ct_window = noa_attr.oppps_ctwindow;\n\t\t\tparam->opp_en.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_en.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_en.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_en.start_time = noa_attr.desc[0].start_time;\n\t\t} else {\n\t\t\tparam->opp_enabled = 0;\n\t\t\tparam->opp_dis.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_dis.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_dis.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_dis.start_time = noa_attr.desc[0].start_time;\n\t\t}\n\t}\n\twmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wmm_ie) {\n\t\tstruct ieee80211_wmm_param_ie *ie;\n\n\t\tie = (struct ieee80211_wmm_param_ie *)wmm_ie;\n\t\tif ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&\n\t\t    ie->version == 1) {\n\t\t\tparam->wmm_cap = true;\n\t\t\tif (ie->qos_info & BIT(7))\n\t\t\t\tparam->uapsd_cap = true;\n\t\t}\n\t}\n\n\twpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wpa_ie) {\n\t\tparam->mode_802_11i = 1;\n\t\tparam->rsn_found = true;\n\t}\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n\tif (rsn_ie) {\n\t\tint rsn_ie_len = sizeof(struct element) + rsn_ie[1];\n\t\tint offset = 8;\n\n\t\t/* extract RSN capabilities */\n\t\tif (offset < rsn_ie_len) {\n\t\t\t/* skip over pairwise suites */\n\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n\n\t\t\tif (offset < rsn_ie_len) {\n\t\t\t\t/* skip over authentication suites */\n\t\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n\n\t\t\t\tif (offset + 1 < rsn_ie_len) {\n\t\t\t\t\tparam->mode_802_11i = 2;\n\t\t\t\t\tparam->rsn_found = true;\n\t\t\t\t\tmemcpy(param->rsn_cap, &rsn_ie[offset], 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (param->rsn_found) {\n\t\tint i;\n\n\t\tparam->rsn_grp_policy = crypto->cipher_group & 0xFF;\n\t\tfor (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)\n\t\t\tparam->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;\n\n\t\tfor (i = 0; i < crypto->n_akm_suites && i < 3; i++)\n\t\t\tparam->akm_suites[i] = crypto->akm_suites[i] & 0xFF;\n\t}\n\n\treturn (void *)param;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tint i, ret;\n\n\t/* Validate length */\n\tif (d->msg_len > sizeof(d->msg))\n                return -EINVAL;\n\n\t/* Dump DiSEqC message */\n\tif (debug) {\n\t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n\t\tprintk(\") toneburst=%d\\n\", toneburst);\n\t}\n\n\t/* DiSEqC message */\n\tfor (i = 0; i < d->msg_len; i++)\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 1252,
            "cve_id": "CVE-2017-11600",
            "code_snippet": "int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\n\t/* Stage 0 - sanity checks */\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\n\tif (dir >= XFRM_POLICY_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Stage 1 - find policy */\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Stage 2 - find and update state(s) */\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Stage 3 - update policy */\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\n\t/* Stage 4 - delete old state(s) */\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\n\t/* Stage 5 - announce */\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\n\txfrm_pol_put(pol);\n\n\treturn 0;\nout:\n\treturn err;\n\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static int f2fs_move_inline_dirents(struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tvoid *inline_dentry)\n{\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr src, dst;\n\tint err;\n\n\tpage = f2fs_grab_cache_page(dir->i_mapping, 0, false);\n\tif (!page) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tif (unlikely(dn.data_blkaddr != NEW_ADDR)) {\n\t\tf2fs_put_dnode(&dn);\n\t\tset_sbi_flag(F2FS_P_SB(page), SBI_NEED_FSCK);\n\t\tf2fs_msg(F2FS_P_SB(page)->sb, KERN_WARNING,\n\t\t\t\"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"\n\t\t\t\"run fsck to fix.\",\n\t\t\t__func__, dir->i_ino, dn.data_blkaddr);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tf2fs_wait_on_page_writeback(page, DATA, true);\n\n\tdentry_blk = page_address(page);\n\n\tmake_dentry_ptr_inline(dir, &src, inline_dentry);\n\tmake_dentry_ptr_block(dir, &dst, dentry_blk);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dst.bitmap, src.bitmap, src.nr_bitmap);\n\tmemset(dst.bitmap + src.nr_bitmap, 0, dst.nr_bitmap - src.nr_bitmap);\n\t/*\n\t * we do not need to zero out remainder part of dentry and filename\n\t * field, since we have used bitmap for marking the usage status of\n\t * them, besides, we can also ignore copying/zeroing reserved space\n\t * of dentry block, because them haven't been used so far.\n\t */\n\tmemcpy(dst.dentry, src.dentry, SIZE_OF_DIR_ENTRY * src.max);\n\tmemcpy(dst.filename, src.filename, src.max * F2FS_SLOT_LEN);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\t/* clear inline dir and flag after data writeback */\n\tf2fs_truncate_inline_inode(dir, ipage, 0);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(dir, FI_INLINE_DENTRY);\n\n\tf2fs_i_depth_write(dir, 1);\n\tif (i_size_read(dir) < PAGE_SIZE)\n\t\tf2fs_i_size_write(dir, PAGE_SIZE);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
                        "cve_id": "CVE-2020-14314"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\n\t/* Stage 0 - sanity checks */\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\n\tif (dir >= XFRM_POLICY_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Stage 1 - find policy */\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Stage 2 - find and update state(s) */\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Stage 3 - update policy */\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\n\t/* Stage 4 - delete old state(s) */\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\n\t/* Stage 5 - announce */\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\n\txfrm_pol_put(pol);\n\n\treturn 0;\nout:\n\treturn err;\n\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int f2fs_move_inline_dirents(struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tvoid *inline_dentry)\n{\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tstruct f2fs_dentry_ptr src, dst;\n\tint err;\n\n\tpage = f2fs_grab_cache_page(dir->i_mapping, 0, false);\n\tif (!page) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tif (unlikely(dn.data_blkaddr != NEW_ADDR)) {\n\t\tf2fs_put_dnode(&dn);\n\t\tset_sbi_flag(F2FS_P_SB(page), SBI_NEED_FSCK);\n\t\tf2fs_msg(F2FS_P_SB(page)->sb, KERN_WARNING,\n\t\t\t\"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"\n\t\t\t\"run fsck to fix.\",\n\t\t\t__func__, dir->i_ino, dn.data_blkaddr);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tf2fs_wait_on_page_writeback(page, DATA, true);\n\n\tdentry_blk = page_address(page);\n\n\tmake_dentry_ptr_inline(dir, &src, inline_dentry);\n\tmake_dentry_ptr_block(dir, &dst, dentry_blk);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dst.bitmap, src.bitmap, src.nr_bitmap);\n\tmemset(dst.bitmap + src.nr_bitmap, 0, dst.nr_bitmap - src.nr_bitmap);\n\t/*\n\t * we do not need to zero out remainder part of dentry and filename\n\t * field, since we have used bitmap for marking the usage status of\n\t * them, besides, we can also ignore copying/zeroing reserved space\n\t * of dentry block, because them haven't been used so far.\n\t */\n\tmemcpy(dst.dentry, src.dentry, SIZE_OF_DIR_ENTRY * src.max);\n\tmemcpy(dst.filename, src.filename, src.max * F2FS_SLOT_LEN);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\t/* clear inline dir and flag after data writeback */\n\tf2fs_truncate_inline_inode(dir, ipage, 0);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(dir, FI_INLINE_DENTRY);\n\n\tf2fs_i_depth_write(dir, 1);\n\tif (i_size_read(dir) < PAGE_SIZE)\n\t\tf2fs_i_size_write(dir, PAGE_SIZE);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\n\t/* Stage 0 - sanity checks */\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\n\tif (dir >= XFRM_POLICY_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Stage 1 - find policy */\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Stage 2 - find and update state(s) */\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Stage 3 - update policy */\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\n\t/* Stage 4 - delete old state(s) */\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\n\t/* Stage 5 - announce */\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\n\txfrm_pol_put(pol);\n\n\treturn 0;\nout:\n\treturn err;\n\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec))\n\t\tgoto Ok;\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\nOk:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg) ||\n\t\t    skb->len < nlh->nlmsg_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}",
                        "code_after_change": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2016-7917"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\n\t/* Stage 0 - sanity checks */\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\n\tif (dir >= XFRM_POLICY_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Stage 1 - find policy */\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* Stage 2 - find and update state(s) */\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Stage 3 - update policy */\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\n\t/* Stage 4 - delete old state(s) */\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\n\t/* Stage 5 - announce */\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\n\txfrm_pol_put(pol);\n\n\treturn 0;\nout:\n\treturn err;\n\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\n\treturn err;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg) ||\n\t\t    skb->len < nlh->nlmsg_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\t\tis_root = true;\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2265,
            "cve_id": "CVE-2019-19927",
            "code_snippet": "static void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n\t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (++p != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (++p != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t/* Check that we don't go over the pool limit */\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don't go over the pool limit */\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "code_after_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "cve_id": "CVE-2023-37453"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n\t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (++p != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (++p != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t/* Check that we don't go over the pool limit */\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don't go over the pool limit */\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tif (!vga_init_done) {\n\t\tvgacon_scrollback_startup();\n\t\tvga_init_done = true;\n\t}\n\n\treturn display_desc;\n}",
                        "code_after_change": "static const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tvga_init_done = true;\n\n\treturn display_desc;\n}",
                        "cve_id": "CVE-2020-28097"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n\t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (++p != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (++p != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t/* Check that we don't go over the pool limit */\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don't go over the pool limit */\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tif (!vga_init_done) {\n\t\tvgacon_scrollback_startup();\n\t\tvga_init_done = true;\n\t}\n\n\treturn display_desc;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic const char *vgacon_startup(void)\n{\n\tconst char *display_desc = NULL;\n\tu16 saved1, saved2;\n\tvolatile u16 *p;\n\n\tif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\n\t    screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\n\t      no_vga:\n#ifdef CONFIG_DUMMY_CONSOLE\n\t\tconswitchp = &dummy_con;\n\t\treturn conswitchp->con_startup();\n#else\n\t\treturn NULL;\n#endif\n\t}\n\n\t/* boot_params.screen_info reasonably initialized? */\n\tif ((screen_info.orig_video_lines == 0) ||\n\t    (screen_info.orig_video_cols  == 0))\n\t\tgoto no_vga;\n\n\t/* VGA16 modes are not handled by VGACON */\n\tif ((screen_info.orig_video_mode == 0x0D) ||\t/* 320x200/4 */\n\t    (screen_info.orig_video_mode == 0x0E) ||\t/* 640x200/4 */\n\t    (screen_info.orig_video_mode == 0x10) ||\t/* 640x350/4 */\n\t    (screen_info.orig_video_mode == 0x12) ||\t/* 640x480/4 */\n\t    (screen_info.orig_video_mode == 0x6A))\t/* 800x600/4 (VESA) */\n\t\tgoto no_vga;\n\n\tvga_video_num_lines = screen_info.orig_video_lines;\n\tvga_video_num_columns = screen_info.orig_video_cols;\n\tvgastate.vgabase = NULL;\n\n\tif (screen_info.orig_video_mode == 7) {\n\t\t/* Monochrome display */\n\t\tvga_vram_base = 0xb0000;\n\t\tvga_video_port_reg = VGA_CRT_IM;\n\t\tvga_video_port_val = VGA_CRT_DM;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tstatic struct resource ega_console_resource =\n\t\t\t    { .name\t= \"ega\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_EGAM;\n\t\t\tvga_vram_size = 0x8000;\n\t\t\tdisplay_desc = \"EGA+\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &ega_console_resource);\n\t\t} else {\n\t\t\tstatic struct resource mda1_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3B0,\n\t\t\t      .end\t= 0x3BB };\n\t\t\tstatic struct resource mda2_console_resource =\n\t\t\t    { .name\t= \"mda\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3BF,\n\t\t\t      .end\t= 0x3BF };\n\t\t\tvga_video_type = VIDEO_TYPE_MDA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda1_console_resource);\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &mda2_console_resource);\n\t\t\tvga_video_font_height = 14;\n\t\t}\n\t} else {\n\t\t/* If not, it is color. */\n\t\tvga_can_do_color = true;\n\t\tvga_vram_base = 0xb8000;\n\t\tvga_video_port_reg = VGA_CRT_IC;\n\t\tvga_video_port_val = VGA_CRT_DC;\n\t\tif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\n\t\t\tint i;\n\n\t\t\tvga_vram_size = 0x8000;\n\n\t\t\tif (!screen_info.orig_video_isVGA) {\n\t\t\t\tstatic struct resource ega_console_resource =\n\t\t\t\t    { .name\t= \"ega\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_EGAC;\n\t\t\t\tdisplay_desc = \"EGA\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &ega_console_resource);\n\t\t\t} else {\n\t\t\t\tstatic struct resource vga_console_resource =\n\t\t\t\t    { .name\t= \"vga+\",\n\t\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t\t      .start\t= 0x3C0,\n\t\t\t\t      .end\t= 0x3DF };\n\t\t\t\tvga_video_type = VIDEO_TYPE_VGAC;\n\t\t\t\tdisplay_desc = \"VGA+\";\n\t\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t\t &vga_console_resource);\n\n\t\t\t\t/*\n\t\t\t\t * Normalise the palette registers, to point\n\t\t\t\t * the 16 screen colours to the first 16\n\t\t\t\t * DAC entries.\n\t\t\t\t */\n\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tinb_p(VGA_IS1_RC);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t\toutb_p(i, VGA_ATT_W);\n\t\t\t\t}\n\t\t\t\toutb_p(0x20, VGA_ATT_W);\n\n\t\t\t\t/*\n\t\t\t\t * Now set the DAC registers back to their\n\t\t\t\t * default values\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\toutb_p(color_table[i], VGA_PEL_IW);\n\t\t\t\t\toutb_p(default_red[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_grn[i], VGA_PEL_D);\n\t\t\t\t\toutb_p(default_blu[i], VGA_PEL_D);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstatic struct resource cga_console_resource =\n\t\t\t    { .name\t= \"cga\",\n\t\t\t      .flags\t= IORESOURCE_IO,\n\t\t\t      .start\t= 0x3D4,\n\t\t\t      .end\t= 0x3D5 };\n\t\t\tvga_video_type = VIDEO_TYPE_CGA;\n\t\t\tvga_vram_size = 0x2000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t\trequest_resource(&ioport_resource,\n\t\t\t\t\t &cga_console_resource);\n\t\t\tvga_video_font_height = 8;\n\t\t}\n\t}\n\n\tvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\n\tvga_vram_end = vga_vram_base + vga_vram_size;\n\n\t/*\n\t *      Find out if there is a graphics card present.\n\t *      Are there smarter methods around?\n\t */\n\tp = (volatile u16 *) vga_vram_base;\n\tsaved1 = scr_readw(p);\n\tsaved2 = scr_readw(p + 1);\n\tscr_writew(0xAA55, p);\n\tscr_writew(0x55AA, p + 1);\n\tif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(0x55AA, p);\n\tscr_writew(0xAA55, p + 1);\n\tif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\n\t\tscr_writew(saved1, p);\n\t\tscr_writew(saved2, p + 1);\n\t\tgoto no_vga;\n\t}\n\tscr_writew(saved1, p);\n\tscr_writew(saved2, p + 1);\n\n\tif (vga_video_type == VIDEO_TYPE_EGAC\n\t    || vga_video_type == VIDEO_TYPE_VGAC\n\t    || vga_video_type == VIDEO_TYPE_EGAM) {\n\t\tvga_hardscroll_enabled = vga_hardscroll_user_enable;\n\t\tvga_default_font_height = screen_info.orig_video_points;\n\t\tvga_video_font_height = screen_info.orig_video_points;\n\t\t/* This may be suboptimal but is a safe bet - go with it */\n\t\tvga_scan_lines =\n\t\t    vga_video_font_height * vga_video_num_lines;\n\t}\n\n\tvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\n\tvgacon_yres = vga_scan_lines;\n\n\tvga_init_done = true;\n\n\treturn display_desc;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "code_after_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2016-10208"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n\t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (++p != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (++p != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t/* Check that we don't go over the pool limit */\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don't go over the pool limit */\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2379,
            "cve_id": "CVE-2020-0427",
            "code_snippet": "static void dt_free_map(struct pinctrl_dev *pctldev,\n\t\t     struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\n\tfor (i = 0; i < num_maps; ++i) {\n\t\tkfree_const(map[i].dev_name);\n\t\tmap[i].dev_name = NULL;\n\t}\n\n\tif (pctldev) {\n\t\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\t\tif (ops->dt_free_map)\n\t\t\tops->dt_free_map(pctldev, map, num_maps);\n\t} else {\n\t\t/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */\n\t\tkfree(map);\n\t}\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2021-3444"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void dt_free_map(struct pinctrl_dev *pctldev,\n\t\t     struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\n\tfor (i = 0; i < num_maps; ++i) {\n\t\tkfree_const(map[i].dev_name);\n\t\tmap[i].dev_name = NULL;\n\t}\n\n\tif (pctldev) {\n\t\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\t\tif (ops->dt_free_map)\n\t\t\tops->dt_free_map(pctldev, map, num_maps);\n\t} else {\n\t\t/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */\n\t\tkfree(map);\n\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "code_after_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2019-15927"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void dt_free_map(struct pinctrl_dev *pctldev,\n\t\t     struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\n\tfor (i = 0; i < num_maps; ++i) {\n\t\tkfree_const(map[i].dev_name);\n\t\tmap[i].dev_name = NULL;\n\t}\n\n\tif (pctldev) {\n\t\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\t\tif (ops->dt_free_map)\n\t\t\tops->dt_free_map(pctldev, map, num_maps);\n\t} else {\n\t\t/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */\n\t\tkfree(map);\n\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "cve_id": "CVE-2020-14314"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void dt_free_map(struct pinctrl_dev *pctldev,\n\t\t     struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\n\tfor (i = 0; i < num_maps; ++i) {\n\t\tkfree_const(map[i].dev_name);\n\t\tmap[i].dev_name = NULL;\n\t}\n\n\tif (pctldev) {\n\t\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\t\tif (ops->dt_free_map)\n\t\t\tops->dt_free_map(pctldev, map, num_maps);\n\t} else {\n\t\t/* There is no pctldev for PIN_MAP_TYPE_DUMMY_STATE */\n\t\tkfree(map);\n\t}\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2380,
            "cve_id": "CVE-2020-0427",
            "code_snippet": "static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t/* Initialize common mapping table entry fields */\n\tfor (i = 0; i < num_maps; i++) {\n\t\tconst char *devname;\n\n\t\tdevname = kstrdup_const(dev_name(p->dev), GFP_KERNEL);\n\t\tif (!devname)\n\t\t\tgoto err_free_map;\n\n\t\tmap[i].dev_name = devname;\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t/* Remember the converted mapping table entries */\n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map)\n\t\tgoto err_free_map;\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_map(map, num_maps, false);\n\nerr_free_map:\n\tdt_free_map(pctldev, map, num_maps);\n\treturn -ENOMEM;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "code_after_change": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
                        "cve_id": "CVE-2020-14314"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t/* Initialize common mapping table entry fields */\n\tfor (i = 0; i < num_maps; i++) {\n\t\tconst char *devname;\n\n\t\tdevname = kstrdup_const(dev_name(p->dev), GFP_KERNEL);\n\t\tif (!devname)\n\t\t\tgoto err_free_map;\n\n\t\tmap[i].dev_name = devname;\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t/* Remember the converted mapping table entries */\n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map)\n\t\tgoto err_free_map;\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_map(map, num_maps, false);\n\nerr_free_map:\n\tdt_free_map(pctldev, map, num_maps);\n\treturn -ENOMEM;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "code_after_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "cve_id": "CVE-2019-15927"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t/* Initialize common mapping table entry fields */\n\tfor (i = 0; i < num_maps; i++) {\n\t\tconst char *devname;\n\n\t\tdevname = kstrdup_const(dev_name(p->dev), GFP_KERNEL);\n\t\tif (!devname)\n\t\t\tgoto err_free_map;\n\n\t\tmap[i].dev_name = devname;\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t/* Remember the converted mapping table entries */\n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map)\n\t\tgoto err_free_map;\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_map(map, num_maps, false);\n\nerr_free_map:\n\tdt_free_map(pctldev, map, num_maps);\n\treturn -ENOMEM;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2021-3444"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t/* Initialize common mapping table entry fields */\n\tfor (i = 0; i < num_maps; i++) {\n\t\tconst char *devname;\n\n\t\tdevname = kstrdup_const(dev_name(p->dev), GFP_KERNEL);\n\t\tif (!devname)\n\t\t\tgoto err_free_map;\n\n\t\tmap[i].dev_name = devname;\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t/* Remember the converted mapping table entries */\n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map)\n\t\tgoto err_free_map;\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_map(map, num_maps, false);\n\nerr_free_map:\n\tdt_free_map(pctldev, map, num_maps);\n\treturn -ENOMEM;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 3016,
            "cve_id": "CVE-2021-3506",
            "code_snippet": "static void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(journal, i));\n\n\t\tif (f2fs_check_nid_range(sbi, nid))\n\t\t\tcontinue;\n\n\t\traw_ne = nat_in_journal(journal, i);\n\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = __alloc_nat_entry(nid, true);\n\t\t\t__init_nat_entry(nm_i, ne, &raw_ne, true);\n\t\t}\n\n\t\t/*\n\t\t * if a free nat in journal has not been used after last\n\t\t * checkpoint, we should remove it from available nids,\n\t\t * since later we will add it again.\n\t\t */\n\t\tif (!get_nat_flag(ne, IS_DIRTY) &&\n\t\t\t\tle32_to_cpu(raw_ne.block_addr) == NULL_ADDR) {\n\t\t\tspin_lock(&nm_i->nid_list_lock);\n\t\t\tnm_i->available_nids--;\n\t\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\t}\n\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t}\n\tupdate_nats_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "code_after_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "cve_id": "CVE-2016-10208"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(journal, i));\n\n\t\tif (f2fs_check_nid_range(sbi, nid))\n\t\t\tcontinue;\n\n\t\traw_ne = nat_in_journal(journal, i);\n\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = __alloc_nat_entry(nid, true);\n\t\t\t__init_nat_entry(nm_i, ne, &raw_ne, true);\n\t\t}\n\n\t\t/*\n\t\t * if a free nat in journal has not been used after last\n\t\t * checkpoint, we should remove it from available nids,\n\t\t * since later we will add it again.\n\t\t */\n\t\tif (!get_nat_flag(ne, IS_DIRTY) &&\n\t\t\t\tle32_to_cpu(raw_ne.block_addr) == NULL_ADDR) {\n\t\t\tspin_lock(&nm_i->nid_list_lock);\n\t\t\tnm_i->available_nids--;\n\t\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\t}\n\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t}\n\tupdate_nats_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int sanity_check_raw_super(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tblock_t segment_count, segs_per_sec, secs_per_zone, segment_count_main;\n\tblock_t total_sections, blocks_per_seg;\n\tstruct f2fs_super_block *raw_super = (struct f2fs_super_block *)\n\t\t\t\t\t(bh->b_data + F2FS_SUPER_OFFSET);\n\tunsigned int blocksize;\n\tsize_t crc_offset = 0;\n\t__u32 crc = 0;\n\n\tif (le32_to_cpu(raw_super->magic) != F2FS_SUPER_MAGIC) {\n\t\tf2fs_info(sbi, \"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\t  F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check checksum_offset and crc in superblock */\n\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_SB_CHKSUM)) {\n\t\tcrc_offset = le32_to_cpu(raw_super->checksum_offset);\n\t\tif (crc_offset !=\n\t\t\toffsetof(struct f2fs_super_block, crc)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum offset: %zu\",\n\t\t\t\t  crc_offset);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tcrc = le32_to_cpu(raw_super->crc);\n\t\tif (!f2fs_crc_valid(sbi, crc, raw_super, crc_offset)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum value: %u\", crc);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid page_cache_size (%lu), supports only 4KB\",\n\t\t\t  PAGE_SIZE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_info(sbi, \"Invalid blocksize (%u), supports only 4KB\",\n\t\t\t  blocksize);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check log blocks per segment */\n\tif (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {\n\t\tf2fs_info(sbi, \"Invalid log blocks per segment (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_blocks_per_seg));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectorsize (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tsegment_count = le32_to_cpu(raw_super->segment_count);\n\tsegment_count_main = le32_to_cpu(raw_super->segment_count_main);\n\tsegs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsecs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\ttotal_sections = le32_to_cpu(raw_super->section_count);\n\n\t/* blocks_per_seg should be 512, given the above check */\n\tblocks_per_seg = 1 << le32_to_cpu(raw_super->log_blocks_per_seg);\n\n\tif (segment_count > F2FS_MAX_SEGMENT ||\n\t\t\t\tsegment_count < F2FS_MIN_SEGMENTS) {\n\t\tf2fs_info(sbi, \"Invalid segment count (%u)\", segment_count);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (total_sections > segment_count_main || total_sections < 1 ||\n\t\t\tsegs_per_sec > segment_count || !segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u, %u x %u)\",\n\t\t\t  segment_count, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif ((segment_count / segs_per_sec) < total_sections) {\n\t\tf2fs_info(sbi, \"Small segment_count (%u < %u * %u)\",\n\t\t\t  segment_count, segs_per_sec, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count > (le64_to_cpu(raw_super->block_count) >> 9)) {\n\t\tf2fs_info(sbi, \"Wrong segment_count / block_count (%u > %llu)\",\n\t\t\t  segment_count, le64_to_cpu(raw_super->block_count));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (RDEV(0).path[0]) {\n\t\tblock_t dev_seg_count = le32_to_cpu(RDEV(0).total_segments);\n\t\tint i = 1;\n\n\t\twhile (i < MAX_DEVICES && RDEV(i).path[0]) {\n\t\t\tdev_seg_count += le32_to_cpu(RDEV(i).total_segments);\n\t\t\ti++;\n\t\t}\n\t\tif (segment_count != dev_seg_count) {\n\t\t\tf2fs_info(sbi, \"Segment count (%u) mismatch with total segments from devices (%u)\",\n\t\t\t\t\tsegment_count, dev_seg_count);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else {\n\t\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_BLKZONED) &&\n\t\t\t\t\t!bdev_is_zoned(sbi->sb->s_bdev)) {\n\t\t\tf2fs_info(sbi, \"Zoned block device path is missing\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\tif (secs_per_zone > total_sections || !secs_per_zone) {\n\t\tf2fs_info(sbi, \"Wrong secs_per_zone / total_sections (%u, %u)\",\n\t\t\t  secs_per_zone, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->extension_count) > F2FS_MAX_EXTENSION ||\n\t\t\traw_super->hot_ext_count > F2FS_MAX_EXTENSION ||\n\t\t\t(le32_to_cpu(raw_super->extension_count) +\n\t\t\traw_super->hot_ext_count) > F2FS_MAX_EXTENSION) {\n\t\tf2fs_info(sbi, \"Corrupted extension count (%u + %u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->extension_count),\n\t\t\t  raw_super->hot_ext_count,\n\t\t\t  F2FS_MAX_EXTENSION);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (le32_to_cpu(raw_super->cp_payload) >\n\t\t\t\t(blocks_per_seg - F2FS_CP_PACKS)) {\n\t\tf2fs_info(sbi, \"Insane cp_payload (%u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->cp_payload),\n\t\t\t  blocks_per_seg - F2FS_CP_PACKS);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check reserved ino info */\n\tif (le32_to_cpu(raw_super->node_ino) != 1 ||\n\t\tle32_to_cpu(raw_super->meta_ino) != 2 ||\n\t\tle32_to_cpu(raw_super->root_ino) != 3) {\n\t\tf2fs_info(sbi, \"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",\n\t\t\t  le32_to_cpu(raw_super->node_ino),\n\t\t\t  le32_to_cpu(raw_super->meta_ino),\n\t\t\t  le32_to_cpu(raw_super->root_ino));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check CP/SIT/NAT/SSA/MAIN_AREA area boundary */\n\tif (sanity_check_area_boundary(sbi, bh))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}",
                        "code_after_change": "static int sanity_check_raw_super(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tblock_t segment_count, segs_per_sec, secs_per_zone, segment_count_main;\n\tblock_t total_sections, blocks_per_seg;\n\tstruct f2fs_super_block *raw_super = (struct f2fs_super_block *)\n\t\t\t\t\t(bh->b_data + F2FS_SUPER_OFFSET);\n\tunsigned int blocksize;\n\tsize_t crc_offset = 0;\n\t__u32 crc = 0;\n\n\tif (le32_to_cpu(raw_super->magic) != F2FS_SUPER_MAGIC) {\n\t\tf2fs_info(sbi, \"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\t  F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check checksum_offset and crc in superblock */\n\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_SB_CHKSUM)) {\n\t\tcrc_offset = le32_to_cpu(raw_super->checksum_offset);\n\t\tif (crc_offset !=\n\t\t\toffsetof(struct f2fs_super_block, crc)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum offset: %zu\",\n\t\t\t\t  crc_offset);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tcrc = le32_to_cpu(raw_super->crc);\n\t\tif (!f2fs_crc_valid(sbi, crc, raw_super, crc_offset)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum value: %u\", crc);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid page_cache_size (%lu), supports only 4KB\",\n\t\t\t  PAGE_SIZE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_info(sbi, \"Invalid blocksize (%u), supports only 4KB\",\n\t\t\t  blocksize);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check log blocks per segment */\n\tif (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {\n\t\tf2fs_info(sbi, \"Invalid log blocks per segment (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_blocks_per_seg));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectorsize (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tsegment_count = le32_to_cpu(raw_super->segment_count);\n\tsegment_count_main = le32_to_cpu(raw_super->segment_count_main);\n\tsegs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsecs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\ttotal_sections = le32_to_cpu(raw_super->section_count);\n\n\t/* blocks_per_seg should be 512, given the above check */\n\tblocks_per_seg = 1 << le32_to_cpu(raw_super->log_blocks_per_seg);\n\n\tif (segment_count > F2FS_MAX_SEGMENT ||\n\t\t\t\tsegment_count < F2FS_MIN_SEGMENTS) {\n\t\tf2fs_info(sbi, \"Invalid segment count (%u)\", segment_count);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (total_sections > segment_count_main || total_sections < 1 ||\n\t\t\tsegs_per_sec > segment_count || !segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u, %u x %u)\",\n\t\t\t  segment_count, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count_main != total_sections * segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u != %u * %u)\",\n\t\t\t  segment_count_main, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif ((segment_count / segs_per_sec) < total_sections) {\n\t\tf2fs_info(sbi, \"Small segment_count (%u < %u * %u)\",\n\t\t\t  segment_count, segs_per_sec, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count > (le64_to_cpu(raw_super->block_count) >> 9)) {\n\t\tf2fs_info(sbi, \"Wrong segment_count / block_count (%u > %llu)\",\n\t\t\t  segment_count, le64_to_cpu(raw_super->block_count));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (RDEV(0).path[0]) {\n\t\tblock_t dev_seg_count = le32_to_cpu(RDEV(0).total_segments);\n\t\tint i = 1;\n\n\t\twhile (i < MAX_DEVICES && RDEV(i).path[0]) {\n\t\t\tdev_seg_count += le32_to_cpu(RDEV(i).total_segments);\n\t\t\ti++;\n\t\t}\n\t\tif (segment_count != dev_seg_count) {\n\t\t\tf2fs_info(sbi, \"Segment count (%u) mismatch with total segments from devices (%u)\",\n\t\t\t\t\tsegment_count, dev_seg_count);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else {\n\t\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_BLKZONED) &&\n\t\t\t\t\t!bdev_is_zoned(sbi->sb->s_bdev)) {\n\t\t\tf2fs_info(sbi, \"Zoned block device path is missing\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\tif (secs_per_zone > total_sections || !secs_per_zone) {\n\t\tf2fs_info(sbi, \"Wrong secs_per_zone / total_sections (%u, %u)\",\n\t\t\t  secs_per_zone, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->extension_count) > F2FS_MAX_EXTENSION ||\n\t\t\traw_super->hot_ext_count > F2FS_MAX_EXTENSION ||\n\t\t\t(le32_to_cpu(raw_super->extension_count) +\n\t\t\traw_super->hot_ext_count) > F2FS_MAX_EXTENSION) {\n\t\tf2fs_info(sbi, \"Corrupted extension count (%u + %u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->extension_count),\n\t\t\t  raw_super->hot_ext_count,\n\t\t\t  F2FS_MAX_EXTENSION);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (le32_to_cpu(raw_super->cp_payload) >\n\t\t\t\t(blocks_per_seg - F2FS_CP_PACKS)) {\n\t\tf2fs_info(sbi, \"Insane cp_payload (%u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->cp_payload),\n\t\t\t  blocks_per_seg - F2FS_CP_PACKS);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check reserved ino info */\n\tif (le32_to_cpu(raw_super->node_ino) != 1 ||\n\t\tle32_to_cpu(raw_super->meta_ino) != 2 ||\n\t\tle32_to_cpu(raw_super->root_ino) != 3) {\n\t\tf2fs_info(sbi, \"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",\n\t\t\t  le32_to_cpu(raw_super->node_ino),\n\t\t\t  le32_to_cpu(raw_super->meta_ino),\n\t\t\t  le32_to_cpu(raw_super->root_ino));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check CP/SIT/NAT/SSA/MAIN_AREA area boundary */\n\tif (sanity_check_area_boundary(sbi, bh))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2019-19449"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void remove_nats_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tstruct nat_entry *ne;\n\t\tstruct f2fs_nat_entry raw_ne;\n\t\tnid_t nid = le32_to_cpu(nid_in_journal(journal, i));\n\n\t\tif (f2fs_check_nid_range(sbi, nid))\n\t\t\tcontinue;\n\n\t\traw_ne = nat_in_journal(journal, i);\n\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (!ne) {\n\t\t\tne = __alloc_nat_entry(nid, true);\n\t\t\t__init_nat_entry(nm_i, ne, &raw_ne, true);\n\t\t}\n\n\t\t/*\n\t\t * if a free nat in journal has not been used after last\n\t\t * checkpoint, we should remove it from available nids,\n\t\t * since later we will add it again.\n\t\t */\n\t\tif (!get_nat_flag(ne, IS_DIRTY) &&\n\t\t\t\tle32_to_cpu(raw_ne.block_addr) == NULL_ADDR) {\n\t\t\tspin_lock(&nm_i->nid_list_lock);\n\t\t\tnm_i->available_nids--;\n\t\t\tspin_unlock(&nm_i->nid_list_lock);\n\t\t}\n\n\t\t__set_nat_cache_dirty(nm_i, ne);\n\t}\n\tupdate_nats_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int sanity_check_raw_super(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tblock_t segment_count, segs_per_sec, secs_per_zone, segment_count_main;\n\tblock_t total_sections, blocks_per_seg;\n\tstruct f2fs_super_block *raw_super = (struct f2fs_super_block *)\n\t\t\t\t\t(bh->b_data + F2FS_SUPER_OFFSET);\n\tunsigned int blocksize;\n\tsize_t crc_offset = 0;\n\t__u32 crc = 0;\n\n\tif (le32_to_cpu(raw_super->magic) != F2FS_SUPER_MAGIC) {\n\t\tf2fs_info(sbi, \"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\t  F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check checksum_offset and crc in superblock */\n\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_SB_CHKSUM)) {\n\t\tcrc_offset = le32_to_cpu(raw_super->checksum_offset);\n\t\tif (crc_offset !=\n\t\t\toffsetof(struct f2fs_super_block, crc)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum offset: %zu\",\n\t\t\t\t  crc_offset);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tcrc = le32_to_cpu(raw_super->crc);\n\t\tif (!f2fs_crc_valid(sbi, crc, raw_super, crc_offset)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum value: %u\", crc);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid page_cache_size (%lu), supports only 4KB\",\n\t\t\t  PAGE_SIZE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_info(sbi, \"Invalid blocksize (%u), supports only 4KB\",\n\t\t\t  blocksize);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check log blocks per segment */\n\tif (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {\n\t\tf2fs_info(sbi, \"Invalid log blocks per segment (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_blocks_per_seg));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectorsize (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tsegment_count = le32_to_cpu(raw_super->segment_count);\n\tsegment_count_main = le32_to_cpu(raw_super->segment_count_main);\n\tsegs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsecs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\ttotal_sections = le32_to_cpu(raw_super->section_count);\n\n\t/* blocks_per_seg should be 512, given the above check */\n\tblocks_per_seg = 1 << le32_to_cpu(raw_super->log_blocks_per_seg);\n\n\tif (segment_count > F2FS_MAX_SEGMENT ||\n\t\t\t\tsegment_count < F2FS_MIN_SEGMENTS) {\n\t\tf2fs_info(sbi, \"Invalid segment count (%u)\", segment_count);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (total_sections > segment_count_main || total_sections < 1 ||\n\t\t\tsegs_per_sec > segment_count || !segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u, %u x %u)\",\n\t\t\t  segment_count, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif ((segment_count / segs_per_sec) < total_sections) {\n\t\tf2fs_info(sbi, \"Small segment_count (%u < %u * %u)\",\n\t\t\t  segment_count, segs_per_sec, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count > (le64_to_cpu(raw_super->block_count) >> 9)) {\n\t\tf2fs_info(sbi, \"Wrong segment_count / block_count (%u > %llu)\",\n\t\t\t  segment_count, le64_to_cpu(raw_super->block_count));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (RDEV(0).path[0]) {\n\t\tblock_t dev_seg_count = le32_to_cpu(RDEV(0).total_segments);\n\t\tint i = 1;\n\n\t\twhile (i < MAX_DEVICES && RDEV(i).path[0]) {\n\t\t\tdev_seg_count += le32_to_cpu(RDEV(i).total_segments);\n\t\t\ti++;\n\t\t}\n\t\tif (segment_count != dev_seg_count) {\n\t\t\tf2fs_info(sbi, \"Segment count (%u) mismatch with total segments from devices (%u)\",\n\t\t\t\t\tsegment_count, dev_seg_count);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else {\n\t\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_BLKZONED) &&\n\t\t\t\t\t!bdev_is_zoned(sbi->sb->s_bdev)) {\n\t\t\tf2fs_info(sbi, \"Zoned block device path is missing\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\tif (secs_per_zone > total_sections || !secs_per_zone) {\n\t\tf2fs_info(sbi, \"Wrong secs_per_zone / total_sections (%u, %u)\",\n\t\t\t  secs_per_zone, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->extension_count) > F2FS_MAX_EXTENSION ||\n\t\t\traw_super->hot_ext_count > F2FS_MAX_EXTENSION ||\n\t\t\t(le32_to_cpu(raw_super->extension_count) +\n\t\t\traw_super->hot_ext_count) > F2FS_MAX_EXTENSION) {\n\t\tf2fs_info(sbi, \"Corrupted extension count (%u + %u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->extension_count),\n\t\t\t  raw_super->hot_ext_count,\n\t\t\t  F2FS_MAX_EXTENSION);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (le32_to_cpu(raw_super->cp_payload) >\n\t\t\t\t(blocks_per_seg - F2FS_CP_PACKS)) {\n\t\tf2fs_info(sbi, \"Insane cp_payload (%u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->cp_payload),\n\t\t\t  blocks_per_seg - F2FS_CP_PACKS);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check reserved ino info */\n\tif (le32_to_cpu(raw_super->node_ino) != 1 ||\n\t\tle32_to_cpu(raw_super->meta_ino) != 2 ||\n\t\tle32_to_cpu(raw_super->root_ino) != 3) {\n\t\tf2fs_info(sbi, \"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",\n\t\t\t  le32_to_cpu(raw_super->node_ino),\n\t\t\t  le32_to_cpu(raw_super->meta_ino),\n\t\t\t  le32_to_cpu(raw_super->root_ino));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check CP/SIT/NAT/SSA/MAIN_AREA area boundary */\n\tif (sanity_check_area_boundary(sbi, bh))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int sanity_check_raw_super(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tblock_t segment_count, segs_per_sec, secs_per_zone, segment_count_main;\n\tblock_t total_sections, blocks_per_seg;\n\tstruct f2fs_super_block *raw_super = (struct f2fs_super_block *)\n\t\t\t\t\t(bh->b_data + F2FS_SUPER_OFFSET);\n\tunsigned int blocksize;\n\tsize_t crc_offset = 0;\n\t__u32 crc = 0;\n\n\tif (le32_to_cpu(raw_super->magic) != F2FS_SUPER_MAGIC) {\n\t\tf2fs_info(sbi, \"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\t  F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check checksum_offset and crc in superblock */\n\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_SB_CHKSUM)) {\n\t\tcrc_offset = le32_to_cpu(raw_super->checksum_offset);\n\t\tif (crc_offset !=\n\t\t\toffsetof(struct f2fs_super_block, crc)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum offset: %zu\",\n\t\t\t\t  crc_offset);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tcrc = le32_to_cpu(raw_super->crc);\n\t\tif (!f2fs_crc_valid(sbi, crc, raw_super, crc_offset)) {\n\t\t\tf2fs_info(sbi, \"Invalid SB checksum value: %u\", crc);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid page_cache_size (%lu), supports only 4KB\",\n\t\t\t  PAGE_SIZE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_info(sbi, \"Invalid blocksize (%u), supports only 4KB\",\n\t\t\t  blocksize);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check log blocks per segment */\n\tif (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {\n\t\tf2fs_info(sbi, \"Invalid log blocks per segment (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_blocks_per_seg));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectorsize (%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_info(sbi, \"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\t  le32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\t  le32_to_cpu(raw_super->log_sectorsize));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tsegment_count = le32_to_cpu(raw_super->segment_count);\n\tsegment_count_main = le32_to_cpu(raw_super->segment_count_main);\n\tsegs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsecs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\ttotal_sections = le32_to_cpu(raw_super->section_count);\n\n\t/* blocks_per_seg should be 512, given the above check */\n\tblocks_per_seg = 1 << le32_to_cpu(raw_super->log_blocks_per_seg);\n\n\tif (segment_count > F2FS_MAX_SEGMENT ||\n\t\t\t\tsegment_count < F2FS_MIN_SEGMENTS) {\n\t\tf2fs_info(sbi, \"Invalid segment count (%u)\", segment_count);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (total_sections > segment_count_main || total_sections < 1 ||\n\t\t\tsegs_per_sec > segment_count || !segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u, %u x %u)\",\n\t\t\t  segment_count, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count_main != total_sections * segs_per_sec) {\n\t\tf2fs_info(sbi, \"Invalid segment/section count (%u != %u * %u)\",\n\t\t\t  segment_count_main, total_sections, segs_per_sec);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif ((segment_count / segs_per_sec) < total_sections) {\n\t\tf2fs_info(sbi, \"Small segment_count (%u < %u * %u)\",\n\t\t\t  segment_count, segs_per_sec, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (segment_count > (le64_to_cpu(raw_super->block_count) >> 9)) {\n\t\tf2fs_info(sbi, \"Wrong segment_count / block_count (%u > %llu)\",\n\t\t\t  segment_count, le64_to_cpu(raw_super->block_count));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (RDEV(0).path[0]) {\n\t\tblock_t dev_seg_count = le32_to_cpu(RDEV(0).total_segments);\n\t\tint i = 1;\n\n\t\twhile (i < MAX_DEVICES && RDEV(i).path[0]) {\n\t\t\tdev_seg_count += le32_to_cpu(RDEV(i).total_segments);\n\t\t\ti++;\n\t\t}\n\t\tif (segment_count != dev_seg_count) {\n\t\t\tf2fs_info(sbi, \"Segment count (%u) mismatch with total segments from devices (%u)\",\n\t\t\t\t\tsegment_count, dev_seg_count);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else {\n\t\tif (__F2FS_HAS_FEATURE(raw_super, F2FS_FEATURE_BLKZONED) &&\n\t\t\t\t\t!bdev_is_zoned(sbi->sb->s_bdev)) {\n\t\t\tf2fs_info(sbi, \"Zoned block device path is missing\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\tif (secs_per_zone > total_sections || !secs_per_zone) {\n\t\tf2fs_info(sbi, \"Wrong secs_per_zone / total_sections (%u, %u)\",\n\t\t\t  secs_per_zone, total_sections);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (le32_to_cpu(raw_super->extension_count) > F2FS_MAX_EXTENSION ||\n\t\t\traw_super->hot_ext_count > F2FS_MAX_EXTENSION ||\n\t\t\t(le32_to_cpu(raw_super->extension_count) +\n\t\t\traw_super->hot_ext_count) > F2FS_MAX_EXTENSION) {\n\t\tf2fs_info(sbi, \"Corrupted extension count (%u + %u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->extension_count),\n\t\t\t  raw_super->hot_ext_count,\n\t\t\t  F2FS_MAX_EXTENSION);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (le32_to_cpu(raw_super->cp_payload) >\n\t\t\t\t(blocks_per_seg - F2FS_CP_PACKS)) {\n\t\tf2fs_info(sbi, \"Insane cp_payload (%u > %u)\",\n\t\t\t  le32_to_cpu(raw_super->cp_payload),\n\t\t\t  blocks_per_seg - F2FS_CP_PACKS);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check reserved ino info */\n\tif (le32_to_cpu(raw_super->node_ino) != 1 ||\n\t\tle32_to_cpu(raw_super->meta_ino) != 2 ||\n\t\tle32_to_cpu(raw_super->root_ino) != 3) {\n\t\tf2fs_info(sbi, \"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",\n\t\t\t  le32_to_cpu(raw_super->node_ino),\n\t\t\t  le32_to_cpu(raw_super->meta_ino),\n\t\t\t  le32_to_cpu(raw_super->root_ino));\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check CP/SIT/NAT/SSA/MAIN_AREA area boundary */\n\tif (sanity_check_area_boundary(sbi, bh))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2422,
            "cve_id": "CVE-2020-10769",
            "code_snippet": "int crypto_authenc_extractkeys(struct crypto_authenc_keys *keys, const u8 *key,\n\t\t\t       unsigned int keylen)\n{\n\tstruct rtattr *rta = (struct rtattr *)key;\n\tstruct crypto_authenc_key_param *param;\n\n\tif (!RTA_OK(rta, keylen))\n\t\treturn -EINVAL;\n\tif (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)\n\t\treturn -EINVAL;\n\n\t/*\n\t * RTA_OK() didn't align the rtattr's payload when validating that it\n\t * fits in the buffer.  Yet, the keys should start on the next 4-byte\n\t * aligned boundary.  To avoid confusion, require that the rtattr\n\t * payload be exactly the param struct, which has a 4-byte aligned size.\n\t */\n\tif (RTA_PAYLOAD(rta) != sizeof(*param))\n\t\treturn -EINVAL;\n\tBUILD_BUG_ON(sizeof(*param) % RTA_ALIGNTO);\n\n\tparam = RTA_DATA(rta);\n\tkeys->enckeylen = be32_to_cpu(param->enckeylen);\n\n\tkey += rta->rta_len;\n\tkeylen -= rta->rta_len;\n\n\tif (keylen < keys->enckeylen)\n\t\treturn -EINVAL;\n\n\tkeys->authkeylen = keylen - keys->enckeylen;\n\tkeys->authkey = key;\n\tkeys->enckey = key + keys->authkeylen;\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}",
                        "code_after_change": "static int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}",
                        "cve_id": "CVE-2020-0430"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nint crypto_authenc_extractkeys(struct crypto_authenc_keys *keys, const u8 *key,\n\t\t\t       unsigned int keylen)\n{\n\tstruct rtattr *rta = (struct rtattr *)key;\n\tstruct crypto_authenc_key_param *param;\n\n\tif (!RTA_OK(rta, keylen))\n\t\treturn -EINVAL;\n\tif (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)\n\t\treturn -EINVAL;\n\n\t/*\n\t * RTA_OK() didn't align the rtattr's payload when validating that it\n\t * fits in the buffer.  Yet, the keys should start on the next 4-byte\n\t * aligned boundary.  To avoid confusion, require that the rtattr\n\t * payload be exactly the param struct, which has a 4-byte aligned size.\n\t */\n\tif (RTA_PAYLOAD(rta) != sizeof(*param))\n\t\treturn -EINVAL;\n\tBUILD_BUG_ON(sizeof(*param) % RTA_ALIGNTO);\n\n\tparam = RTA_DATA(rta);\n\tkeys->enckeylen = be32_to_cpu(param->enckeylen);\n\n\tkey += rta->rta_len;\n\tkeylen -= rta->rta_len;\n\n\tif (keylen < keys->enckeylen)\n\t\treturn -EINVAL;\n\n\tkeys->authkeylen = keylen - keys->enckeylen;\n\tkeys->authkey = key;\n\tkeys->enckey = key + keys->authkeylen;\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2808,
            "cve_id": "CVE-2020-8835",
            "code_snippet": "static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,\n\t\t\t\tstruct bpf_reg_state *false_reg, u64 val,\n\t\t\t\tu8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JGT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JGT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSGT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSGT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JLT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JLT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSLT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSLT ? sval + 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\tif (is_jmp32) {\n\t\t__reg_bound_offset32(false_reg);\n\t\t__reg_bound_offset32(true_reg);\n\t}\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}",
                        "code_after_change": "static void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}",
                        "cve_id": "CVE-2020-8835"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void reg_set_min_max_inv(struct bpf_reg_state *true_reg,\n\t\t\t\tstruct bpf_reg_state *false_reg, u64 val,\n\t\t\t\tu8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JGT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JGT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSGT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSGT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JLT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JLT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSLT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSLT ? sval + 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\tif (is_jmp32) {\n\t\t__reg_bound_offset32(false_reg);\n\t\t__reg_bound_offset32(true_reg);\n\t}\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 589,
            "cve_id": "CVE-2014-7825",
            "code_snippet": "static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\tftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\tirq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
                        "code_after_change": "static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
                        "cve_id": "CVE-2014-7825"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */\n\tftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\tirq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */\n\tftrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->enter_event->event.type, size, irq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args, entry->args);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 2753,
            "cve_id": "CVE-2020-36386",
            "code_snippet": "static void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data;\n\t__be16 *p = (__be16 *)(skb->data + offset);\n\tint grehlen = offset + 4;\n\tstruct ip6_tnl *t;\n\t__be16 flags;\n\n\tflags = p[0];\n\tif (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {\n\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n\t\t\treturn;\n\t\tif (flags&GRE_KEY) {\n\t\t\tgrehlen += 4;\n\t\t\tif (flags&GRE_CSUM)\n\t\t\t\tgrehlen += 4;\n\t\t}\n\t}\n\n\t/* If only 8 bytes returned, keyed message will be dropped here */\n\tif (!pskb_may_pull(skb, grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tp = (__be16 *)(skb->data + offset);\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\tflags & GRE_KEY ?\n\t\t\t\t*(((__be32 *)p) + (grehlen / 4) - 1) : 0,\n\t\t\t\tp[1]);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}",
                        "code_after_change": "static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct gre_base_hdr *greh;\n\tconst struct ipv6hdr *ipv6h;\n\tint grehlen = sizeof(*greh);\n\tstruct ip6_tnl *t;\n\tint key_off = 0;\n\t__be16 flags;\n\t__be32 key;\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tflags = greh->flags;\n\tif (flags & (GRE_VERSION | GRE_ROUTING))\n\t\treturn;\n\tif (flags & GRE_CSUM)\n\t\tgrehlen += 4;\n\tif (flags & GRE_KEY) {\n\t\tkey_off = grehlen + offset;\n\t\tgrehlen += 4;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tkey = key_off ? *(__be32 *)(skb->data + key_off) : 0;\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\t key, greh->protocol);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}",
                        "cve_id": "CVE-2017-5897"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data;\n\t__be16 *p = (__be16 *)(skb->data + offset);\n\tint grehlen = offset + 4;\n\tstruct ip6_tnl *t;\n\t__be16 flags;\n\n\tflags = p[0];\n\tif (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {\n\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n\t\t\treturn;\n\t\tif (flags&GRE_KEY) {\n\t\t\tgrehlen += 4;\n\t\t\tif (flags&GRE_CSUM)\n\t\t\t\tgrehlen += 4;\n\t\t}\n\t}\n\n\t/* If only 8 bytes returned, keyed message will be dropped here */\n\tif (!pskb_may_pull(skb, grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tp = (__be16 *)(skb->data + offset);\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\tflags & GRE_KEY ?\n\t\t\t\t*(((__be32 *)p) + (grehlen / 4) - 1) : 0,\n\t\t\t\tp[1]);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct gre_base_hdr *greh;\n\tconst struct ipv6hdr *ipv6h;\n\tint grehlen = sizeof(*greh);\n\tstruct ip6_tnl *t;\n\tint key_off = 0;\n\t__be16 flags;\n\t__be32 key;\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tflags = greh->flags;\n\tif (flags & (GRE_VERSION | GRE_ROUTING))\n\t\treturn;\n\tif (flags & GRE_CSUM)\n\t\tgrehlen += 4;\n\tif (flags & GRE_KEY) {\n\t\tkey_off = grehlen + offset;\n\t\tgrehlen += 4;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tkey = key_off ? *(__be32 *)(skb->data + key_off) : 0;\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\t key, greh->protocol);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tu32 flags = 0;\n\tint err;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tattr = nla[NFTA_TABLE_NAME];\n\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tif (PTR_ERR(table) != -ENOENT)\n\t\t\treturn PTR_ERR(table);\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updtable(&ctx);\n\t}\n\n\tif (nla[NFTA_TABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\n\t\tif (flags & ~NFT_TABLE_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENOMEM;\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (table == NULL)\n\t\tgoto err_kzalloc;\n\n\ttable->name = nla_strdup(attr, GFP_KERNEL);\n\tif (table->name == NULL)\n\t\tgoto err_strdup;\n\n\tif (nla[NFTA_TABLE_USERDATA]) {\n\t\ttable->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);\n\t\tif (table->udata == NULL)\n\t\t\tgoto err_table_udata;\n\n\t\ttable->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);\n\t}\n\n\terr = rhltable_init(&table->chains_ht, &nft_chain_ht_params);\n\tif (err)\n\t\tgoto err_chain_ht;\n\n\tINIT_LIST_HEAD(&table->chains);\n\tINIT_LIST_HEAD(&table->sets);\n\tINIT_LIST_HEAD(&table->objects);\n\tINIT_LIST_HEAD(&table->flowtables);\n\ttable->family = family;\n\ttable->flags = flags;\n\ttable->handle = ++table_handle;\n\tif (table->flags & NFT_TABLE_F_OWNER)\n\t\ttable->nlpid = NETLINK_CB(skb).portid;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\terr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\tlist_add_tail_rcu(&table->list, &nft_net->tables);\n\treturn 0;\nerr_trans:\n\trhltable_destroy(&table->chains_ht);\nerr_chain_ht:\n\tkfree(table->udata);\nerr_table_udata:\n\tkfree(table->name);\nerr_strdup:\n\tkfree(table);\nerr_kzalloc:\n\treturn err;\n}",
                        "code_after_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "cve_id": "CVE-2023-6040"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tu32 flags = 0;\n\tint err;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tattr = nla[NFTA_TABLE_NAME];\n\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tif (PTR_ERR(table) != -ENOENT)\n\t\t\treturn PTR_ERR(table);\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updtable(&ctx);\n\t}\n\n\tif (nla[NFTA_TABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\n\t\tif (flags & ~NFT_TABLE_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENOMEM;\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (table == NULL)\n\t\tgoto err_kzalloc;\n\n\ttable->name = nla_strdup(attr, GFP_KERNEL);\n\tif (table->name == NULL)\n\t\tgoto err_strdup;\n\n\tif (nla[NFTA_TABLE_USERDATA]) {\n\t\ttable->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);\n\t\tif (table->udata == NULL)\n\t\t\tgoto err_table_udata;\n\n\t\ttable->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);\n\t}\n\n\terr = rhltable_init(&table->chains_ht, &nft_chain_ht_params);\n\tif (err)\n\t\tgoto err_chain_ht;\n\n\tINIT_LIST_HEAD(&table->chains);\n\tINIT_LIST_HEAD(&table->sets);\n\tINIT_LIST_HEAD(&table->objects);\n\tINIT_LIST_HEAD(&table->flowtables);\n\ttable->family = family;\n\ttable->flags = flags;\n\ttable->handle = ++table_handle;\n\tif (table->flags & NFT_TABLE_F_OWNER)\n\t\ttable->nlpid = NETLINK_CB(skb).portid;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\terr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\tlist_add_tail_rcu(&table->list, &nft_net->tables);\n\treturn 0;\nerr_trans:\n\trhltable_destroy(&table->chains_ht);\nerr_chain_ht:\n\tkfree(table->udata);\nerr_table_udata:\n\tkfree(table->name);\nerr_strdup:\n\tkfree(table);\nerr_kzalloc:\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = desc->bNrInPins;\n\tif (desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
                        "code_after_change": "static int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tu32 flags = 0;\n\tint err;\n\n\tif (!nft_supported_family(family))\n\t\treturn -EOPNOTSUPP;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tattr = nla[NFTA_TABLE_NAME];\n\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tif (PTR_ERR(table) != -ENOENT)\n\t\t\treturn PTR_ERR(table);\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updtable(&ctx);\n\t}\n\n\tif (nla[NFTA_TABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\n\t\tif (flags & ~NFT_TABLE_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENOMEM;\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (table == NULL)\n\t\tgoto err_kzalloc;\n\n\ttable->name = nla_strdup(attr, GFP_KERNEL);\n\tif (table->name == NULL)\n\t\tgoto err_strdup;\n\n\tif (nla[NFTA_TABLE_USERDATA]) {\n\t\ttable->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);\n\t\tif (table->udata == NULL)\n\t\t\tgoto err_table_udata;\n\n\t\ttable->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);\n\t}\n\n\terr = rhltable_init(&table->chains_ht, &nft_chain_ht_params);\n\tif (err)\n\t\tgoto err_chain_ht;\n\n\tINIT_LIST_HEAD(&table->chains);\n\tINIT_LIST_HEAD(&table->sets);\n\tINIT_LIST_HEAD(&table->objects);\n\tINIT_LIST_HEAD(&table->flowtables);\n\ttable->family = family;\n\ttable->flags = flags;\n\ttable->handle = ++table_handle;\n\tif (table->flags & NFT_TABLE_F_OWNER)\n\t\ttable->nlpid = NETLINK_CB(skb).portid;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\terr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\tlist_add_tail_rcu(&table->list, &nft_net->tables);\n\treturn 0;\nerr_trans:\n\trhltable_destroy(&table->chains_ht);\nerr_chain_ht:\n\tkfree(table->udata);\nerr_table_udata:\n\tkfree(table->name);\nerr_strdup:\n\tkfree(table);\nerr_kzalloc:\n\treturn err;\n}",
                        "cve_id": "CVE-2019-15927"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\n\tif (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\n\thci_dev_lock(hdev);\n\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\n\thci_dev_unlock(hdev);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\tif (!(controls[valinfo->control / 8] &\n\t\t\t\t\t(1 << ((valinfo->control % 8) - 1))))\n\t\t\t\tcontinue;\n\t\t} else { /* UAC_VERSION_2/3 */\n\t\t\tif (!uac_v2v3_control_is_readable(controls[valinfo->control / 8],\n\t\t\t\t\t\t\t  valinfo->control))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tmap = find_map(state->map, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\tif (state->mixer->protocol > UAC_VERSION_1 &&\n\t\t    !uac_v2v3_control_is_writeable(controls[valinfo->control / 8],\n\t\t\t\t\t\t   valinfo->control))\n\t\t\tcval->master_readonly = 1;\n\n\t\t/* get min/max values */\n\t\tswitch (type) {\n\t\tcase UAC_PROCESS_UP_DOWNMIX: {\n\t\t\tbool mode_sel = false;\n\n\t\t\tswitch (state->mixer->protocol) {\n\t\t\tcase UAC_VERSION_1:\n\t\t\tcase UAC_VERSION_2:\n\t\t\tdefault:\n\t\t\t\tif (cval->control == UAC_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\tcase UAC_VERSION_3:\n\t\t\t\tif (cval->control == UAC3_UD_MODE_SELECT)\n\t\t\t\t\tmode_sel = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mode_sel) {\n\t\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc,\n\t\t\t\t\t\t\t\tstate->mixer->protocol);\n\t\t\t\tcval->min = 1;\n\t\t\t\tcval->max = control_spec[0];\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_XU_CLOCK_RATE:\n\t\t\t/*\n\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t * samplerate control quirk\n\t\t\t */\n\t\t\tcval->min = 0;\n\t\t\tcval->max = 5;\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state->chip,\n\t\t\t\t\t\t\t       nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t      const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct net *net = info->net;\n\tconst struct nlattr *attr;\n\tstruct nft_table *table;\n\tstruct nft_ctx ctx;\n\tu32 flags = 0;\n\tint err;\n\n\tif (!nft_supported_family(family))\n\t\treturn -EOPNOTSUPP;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\tattr = nla[NFTA_TABLE_NAME];\n\ttable = nft_table_lookup(net, attr, family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tif (PTR_ERR(table) != -ENOENT)\n\t\t\treturn PTR_ERR(table);\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, attr);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\t\treturn nf_tables_updtable(&ctx);\n\t}\n\n\tif (nla[NFTA_TABLE_FLAGS]) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\n\t\tif (flags & ~NFT_TABLE_F_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = -ENOMEM;\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (table == NULL)\n\t\tgoto err_kzalloc;\n\n\ttable->name = nla_strdup(attr, GFP_KERNEL);\n\tif (table->name == NULL)\n\t\tgoto err_strdup;\n\n\tif (nla[NFTA_TABLE_USERDATA]) {\n\t\ttable->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);\n\t\tif (table->udata == NULL)\n\t\t\tgoto err_table_udata;\n\n\t\ttable->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);\n\t}\n\n\terr = rhltable_init(&table->chains_ht, &nft_chain_ht_params);\n\tif (err)\n\t\tgoto err_chain_ht;\n\n\tINIT_LIST_HEAD(&table->chains);\n\tINIT_LIST_HEAD(&table->sets);\n\tINIT_LIST_HEAD(&table->objects);\n\tINIT_LIST_HEAD(&table->flowtables);\n\ttable->family = family;\n\ttable->flags = flags;\n\ttable->handle = ++table_handle;\n\tif (table->flags & NFT_TABLE_F_OWNER)\n\t\ttable->nlpid = NETLINK_CB(skb).portid;\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\terr = nft_trans_table_add(&ctx, NFT_MSG_NEWTABLE);\n\tif (err < 0)\n\t\tgoto err_trans;\n\n\tlist_add_tail_rcu(&table->list, &nft_net->tables);\n\treturn 0;\nerr_trans:\n\trhltable_destroy(&table->chains_ht);\nerr_chain_ht:\n\tkfree(table->udata);\nerr_table_udata:\n\tkfree(table->name);\nerr_strdup:\n\tkfree(table);\nerr_kzalloc:\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 1784,
            "cve_id": "CVE-2018-20854",
            "code_snippet": "static int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}",
                        "code_after_change": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}",
                        "cve_id": "CVE-2018-20854"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3767,
            "cve_id": "CVE-2022-47938",
            "code_snippet": "static int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n\t\t\t\t  struct smb2_hdr *hdr)\n{\n\tint ret = 0;\n\n\t*off = 0;\n\t*len = 0;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_TREE_CONNECT:\n\t\t*off = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathOffset);\n\t\t*len = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t{\n\t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength) {\n\t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsLength);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\t\tbreak;\n\t}\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferLength);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);\n\t\tbreak;\n\tcase SMB2_LOCK:\n\t{\n\t\tint lock_count;\n\n\t\t/*\n\t\t * smb2_lock request size is 48 included single\n\t\t * smb2_lock_element structure size.\n\t\t */\n\t\tlock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount) - 1;\n\t\tif (lock_count > 0) {\n\t\t\t*off = __SMB2_HEADER_STRUCTURE_SIZE + 48;\n\t\t\t*len = sizeof(struct smb2_lock_element) * lock_count;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputCount);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\tif (*off > 4096) {\n\t\tksmbd_debug(SMB, \"offset %d too large\\n\", *off);\n\t\tret = -EINVAL;\n\t} else if ((u64)*off + *len > MAX_STREAM_PROT_LEN) {\n\t\tksmbd_debug(SMB, \"Request is larger than maximum stream protocol length(%u): %llu\\n\",\n\t\t\t    MAX_STREAM_PROT_LEN, (u64)*off + *len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root))\n\t\t\tmemcpy(attr, a_root, asize);\n\t\telse {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}",
                        "code_after_change": "static int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root)) {\n\t\t\tmemcpy(attr, a_root, asize);\n\t\t} else {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}",
                        "cve_id": "CVE-2022-48502"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n\t\t\t\t  struct smb2_hdr *hdr)\n{\n\tint ret = 0;\n\n\t*off = 0;\n\t*len = 0;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_TREE_CONNECT:\n\t\t*off = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathOffset);\n\t\t*len = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t{\n\t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength) {\n\t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsLength);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\t\tbreak;\n\t}\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferLength);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);\n\t\tbreak;\n\tcase SMB2_LOCK:\n\t{\n\t\tint lock_count;\n\n\t\t/*\n\t\t * smb2_lock request size is 48 included single\n\t\t * smb2_lock_element structure size.\n\t\t */\n\t\tlock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount) - 1;\n\t\tif (lock_count > 0) {\n\t\t\t*off = __SMB2_HEADER_STRUCTURE_SIZE + 48;\n\t\t\t*len = sizeof(struct smb2_lock_element) * lock_count;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputCount);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\tif (*off > 4096) {\n\t\tksmbd_debug(SMB, \"offset %d too large\\n\", *off);\n\t\tret = -EINVAL;\n\t} else if ((u64)*off + *len > MAX_STREAM_PROT_LEN) {\n\t\tksmbd_debug(SMB, \"Request is larger than maximum stream protocol length(%u): %llu\\n\",\n\t\t\t    MAX_STREAM_PROT_LEN, (u64)*off + *len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root))\n\t\t\tmemcpy(attr, a_root, asize);\n\t\telse {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int indx_insert_into_root(struct ntfs_index *indx, struct ntfs_inode *ni,\n\t\t\t\t const struct NTFS_DE *new_de,\n\t\t\t\t struct NTFS_DE *root_de, const void *ctx,\n\t\t\t\t struct ntfs_fnd *fnd, bool undo)\n{\n\tint err = 0;\n\tstruct NTFS_DE *e, *e0, *re;\n\tstruct mft_inode *mi;\n\tstruct ATTRIB *attr;\n\tstruct INDEX_HDR *hdr;\n\tstruct indx_node *n;\n\tCLST new_vbn;\n\t__le64 *sub_vbn, t_vbn;\n\tu16 new_de_size;\n\tu32 hdr_used, hdr_total, asize, to_move;\n\tu32 root_size, new_root_size;\n\tstruct ntfs_sb_info *sbi;\n\tint ds_root;\n\tstruct INDEX_ROOT *root, *a_root;\n\n\t/* Get the record this root placed in. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Try easy case:\n\t * hdr_insert_de will succeed if there's\n\t * room the root for the new entry.\n\t */\n\thdr = &root->ihdr;\n\tsbi = ni->mi.sbi;\n\tnew_de_size = le16_to_cpu(new_de->size);\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\tasize = le32_to_cpu(attr->size);\n\troot_size = le32_to_cpu(attr->res.data_size);\n\n\tds_root = new_de_size + hdr_used - hdr_total;\n\n\t/* If 'undo' is set then reduce requirements. */\n\tif ((undo || asize + ds_root < sbi->max_bytes_per_attr) &&\n\t    mi_resize_attr(mi, attr, ds_root)) {\n\t\thdr->total = cpu_to_le32(hdr_total + ds_root);\n\t\te = hdr_insert_de(indx, hdr, new_de, root_de, ctx);\n\t\tWARN_ON(!e);\n\t\tfnd_clear(fnd);\n\t\tfnd->root_de = e;\n\n\t\treturn 0;\n\t}\n\n\t/* Make a copy of root attribute to restore if error. */\n\ta_root = kmemdup(attr, asize, GFP_NOFS);\n\tif (!a_root)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Copy all the non-end entries from\n\t * the index root to the new buffer.\n\t */\n\tto_move = 0;\n\te0 = hdr_first_de(hdr);\n\n\t/* Calculate the size to copy. */\n\tfor (e = e0;; e = hdr_next_de(hdr, e)) {\n\t\tif (!e) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_root;\n\t\t}\n\n\t\tif (de_is_last(e))\n\t\t\tbreak;\n\t\tto_move += le16_to_cpu(e->size);\n\t}\n\n\tif (!to_move) {\n\t\tre = NULL;\n\t} else {\n\t\tre = kmemdup(e0, to_move, GFP_NOFS);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_root;\n\t\t}\n\t}\n\n\tsub_vbn = NULL;\n\tif (de_has_vcn(e)) {\n\t\tt_vbn = de_get_vbn_le(e);\n\t\tsub_vbn = &t_vbn;\n\t}\n\n\tnew_root_size = sizeof(struct INDEX_ROOT) + sizeof(struct NTFS_DE) +\n\t\t\tsizeof(u64);\n\tds_root = new_root_size - root_size;\n\n\tif (ds_root > 0 && asize + ds_root > sbi->max_bytes_per_attr) {\n\t\t/* Make root external. */\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_free_re;\n\t}\n\n\tif (ds_root)\n\t\tmi_resize_attr(mi, attr, ds_root);\n\n\t/* Fill first entry (vcn will be set later). */\n\te = (struct NTFS_DE *)(root + 1);\n\tmemset(e, 0, sizeof(struct NTFS_DE));\n\te->size = cpu_to_le16(sizeof(struct NTFS_DE) + sizeof(u64));\n\te->flags = NTFS_IE_HAS_SUBNODES | NTFS_IE_LAST;\n\n\thdr->flags = 1;\n\thdr->used = hdr->total =\n\t\tcpu_to_le32(new_root_size - offsetof(struct INDEX_ROOT, ihdr));\n\n\tfnd->root_de = hdr_first_de(hdr);\n\tmi->dirty = true;\n\n\t/* Create alloc and bitmap attributes (if not). */\n\terr = run_is_empty(&indx->alloc_run)\n\t\t      ? indx_create_allocate(indx, ni, &new_vbn)\n\t\t      : indx_add_allocate(indx, ni, &new_vbn);\n\n\t/* Layout of record may be changed, so rescan root. */\n\troot = indx_get_root(indx, ni, &attr, &mi);\n\tif (!root) {\n\t\t/* Bug? */\n\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\terr = -EINVAL;\n\t\tgoto out_free_re;\n\t}\n\n\tif (err) {\n\t\t/* Restore root. */\n\t\tif (mi_resize_attr(mi, attr, -ds_root)) {\n\t\t\tmemcpy(attr, a_root, asize);\n\t\t} else {\n\t\t\t/* Bug? */\n\t\t\tntfs_set_state(sbi, NTFS_DIRTY_ERROR);\n\t\t}\n\t\tgoto out_free_re;\n\t}\n\n\te = (struct NTFS_DE *)(root + 1);\n\t*(__le64 *)(e + 1) = cpu_to_le64(new_vbn);\n\tmi->dirty = true;\n\n\t/* Now we can create/format the new buffer and copy the entries into. */\n\tn = indx_new(indx, ni, new_vbn, sub_vbn);\n\tif (IS_ERR(n)) {\n\t\terr = PTR_ERR(n);\n\t\tgoto out_free_re;\n\t}\n\n\thdr = &n->index->ihdr;\n\thdr_used = le32_to_cpu(hdr->used);\n\thdr_total = le32_to_cpu(hdr->total);\n\n\t/* Copy root entries into new buffer. */\n\thdr_insert_head(hdr, re, to_move);\n\n\t/* Update bitmap attribute. */\n\tindx_mark_used(indx, ni, new_vbn >> indx->idx2vbn_bits);\n\n\t/* Check if we can insert new entry new index buffer. */\n\tif (hdr_used + new_de_size > hdr_total) {\n\t\t/*\n\t\t * This occurs if MFT record is the same or bigger than index\n\t\t * buffer. Move all root new index and have no space to add\n\t\t * new entry classic case when MFT record is 1K and index\n\t\t * buffer 4K the problem should not occurs.\n\t\t */\n\t\tkfree(re);\n\t\tindx_write(indx, ni, n, 0);\n\n\t\tput_indx_node(n);\n\t\tfnd_clear(fnd);\n\t\terr = indx_insert_entry(indx, ni, new_de, ctx, fnd, undo);\n\t\tgoto out_free_root;\n\t}\n\n\t/*\n\t * Now root is a parent for new index buffer.\n\t * Insert NewEntry a new buffer.\n\t */\n\te = hdr_insert_de(indx, hdr, new_de, NULL, ctx);\n\tif (!e) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_n;\n\t}\n\tfnd_push(fnd, n, e);\n\n\t/* Just write updates index into disk. */\n\tindx_write(indx, ni, n, 0);\n\n\tn = NULL;\n\nout_put_n:\n\tput_indx_node(n);\nout_free_re:\n\tkfree(re);\nout_free_root:\n\tkfree(a_root);\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int smb2_write(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req;\n\tstruct smb2_write_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length;\n\tssize_t nbytes;\n\tchar *data_buf;\n\tbool writethrough = false;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe write request\\n\");\n\t\treturn smb2_write_pipe(work);\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1 ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset);\n\n\t\tif (req->Length != 0 || req->DataOffset != 0 ||\n\t\t    ch_offset < offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->WriteChannelInfoOffset,\n\t\t\t\t\t\t   req->WriteChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tksmbd_debug(SMB, \"User does not have write permission\\n\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to write : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\n\tif (length > work->conn->vals->max_write_size) {\n\t\tksmbd_debug(SMB, \"limiting write size to max size(%u)\\n\",\n\t\t\t    work->conn->vals->max_write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\twritethrough = true;\n\n\tif (req->Channel != SMB2_CHANNEL_RDMA_V1 &&\n\t    req->Channel != SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tif (le16_to_cpu(req->DataOffset) ==\n\t\t    offsetof(struct smb2_write_req, Buffer)) {\n\t\t\tdata_buf = (char *)&req->Buffer[0];\n\t\t} else {\n\t\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n\t\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n\t\t\t\t       le16_to_cpu(req->DataOffset),\n\t\t\t\t       get_rfc1002_len(work->request_buf));\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\t\tle16_to_cpu(req->DataOffset));\n\t\t}\n\n\t\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n\t\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\t\twritethrough = true;\n\n\t\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t\t    fp->filp->f_path.dentry, offset, length);\n\t\terr = ksmbd_vfs_write(work, fp, data_buf, length, &offset,\n\t\t\t\t      writethrough, &nbytes);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t/* read data from the client using rdma channel, and\n\t\t * write the data.\n\t\t */\n\t\tnbytes = smb2_write_rdma_channel(work, req, fp, offset,\n\t\t\t\t\t\t le32_to_cpu(req->RemainingBytes),\n\t\t\t\t\t\t writethrough);\n\t\tif (nbytes < 0) {\n\t\t\terr = (int)nbytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (err == -ENOSPC || err == -EFBIG)\n\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\telse if (err == -ENOENT)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (err == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (err == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (err == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}",
                        "code_after_change": "int smb2_write(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req;\n\tstruct smb2_write_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length;\n\tssize_t nbytes;\n\tchar *data_buf;\n\tbool writethrough = false, is_rdma_channel = false;\n\tint err = 0;\n\tunsigned int max_write_size = work->conn->vals->max_write_size;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe write request\\n\");\n\t\treturn smb2_write_pipe(work);\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1 ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tis_rdma_channel = true;\n\t\tmax_write_size = get_smbd_max_read_write_size();\n\t\tlength = le32_to_cpu(req->RemainingBytes);\n\t}\n\n\tif (is_rdma_channel == true) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset);\n\n\t\tif (req->Length != 0 || req->DataOffset != 0 ||\n\t\t    ch_offset < offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->WriteChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tksmbd_debug(SMB, \"User does not have write permission\\n\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to write : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (length > max_write_size) {\n\t\tksmbd_debug(SMB, \"limiting write size to max size(%u)\\n\",\n\t\t\t    max_write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\twritethrough = true;\n\n\tif (is_rdma_channel == false) {\n\t\tif (le16_to_cpu(req->DataOffset) <\n\t\t    offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\t    le16_to_cpu(req->DataOffset));\n\n\t\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t\t    fp->filp->f_path.dentry, offset, length);\n\t\terr = ksmbd_vfs_write(work, fp, data_buf, length, &offset,\n\t\t\t\t      writethrough, &nbytes);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t/* read data from the client using rdma channel, and\n\t\t * write the data.\n\t\t */\n\t\tnbytes = smb2_write_rdma_channel(work, req, fp, offset, length,\n\t\t\t\t\t\t writethrough);\n\t\tif (nbytes < 0) {\n\t\t\terr = (int)nbytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (err == -ENOSPC || err == -EFBIG)\n\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\telse if (err == -ENOENT)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (err == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (err == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (err == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}",
                        "cve_id": "CVE-2022-47940"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n\t\t\t\t  struct smb2_hdr *hdr)\n{\n\tint ret = 0;\n\n\t*off = 0;\n\t*len = 0;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_TREE_CONNECT:\n\t\t*off = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathOffset);\n\t\t*len = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t{\n\t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength) {\n\t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsLength);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\t\tbreak;\n\t}\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferLength);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);\n\t\tbreak;\n\tcase SMB2_LOCK:\n\t{\n\t\tint lock_count;\n\n\t\t/*\n\t\t * smb2_lock request size is 48 included single\n\t\t * smb2_lock_element structure size.\n\t\t */\n\t\tlock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount) - 1;\n\t\tif (lock_count > 0) {\n\t\t\t*off = __SMB2_HEADER_STRUCTURE_SIZE + 48;\n\t\t\t*len = sizeof(struct smb2_lock_element) * lock_count;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputCount);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\tif (*off > 4096) {\n\t\tksmbd_debug(SMB, \"offset %d too large\\n\", *off);\n\t\tret = -EINVAL;\n\t} else if ((u64)*off + *len > MAX_STREAM_PROT_LEN) {\n\t\tksmbd_debug(SMB, \"Request is larger than maximum stream protocol length(%u): %llu\\n\",\n\t\t\t    MAX_STREAM_PROT_LEN, (u64)*off + *len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n'''\nRelated vulnerability code snippet:\n'''\nint smb2_write(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req;\n\tstruct smb2_write_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length;\n\tssize_t nbytes;\n\tchar *data_buf;\n\tbool writethrough = false;\n\tint err = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe write request\\n\");\n\t\treturn smb2_write_pipe(work);\n\t}\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1 ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset);\n\n\t\tif (req->Length != 0 || req->DataOffset != 0 ||\n\t\t    ch_offset < offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->WriteChannelInfoOffset,\n\t\t\t\t\t\t   req->WriteChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tksmbd_debug(SMB, \"User does not have write permission\\n\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to write : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\n\tif (length > work->conn->vals->max_write_size) {\n\t\tksmbd_debug(SMB, \"limiting write size to max size(%u)\\n\",\n\t\t\t    work->conn->vals->max_write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\twritethrough = true;\n\n\tif (req->Channel != SMB2_CHANNEL_RDMA_V1 &&\n\t    req->Channel != SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tif (le16_to_cpu(req->DataOffset) ==\n\t\t    offsetof(struct smb2_write_req, Buffer)) {\n\t\t\tdata_buf = (char *)&req->Buffer[0];\n\t\t} else {\n\t\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n\t\t\t    get_rfc1002_len(work->request_buf)) {\n\t\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n\t\t\t\t       le16_to_cpu(req->DataOffset),\n\t\t\t\t       get_rfc1002_len(work->request_buf));\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\t\tle16_to_cpu(req->DataOffset));\n\t\t}\n\n\t\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n\t\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\t\twritethrough = true;\n\n\t\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t\t    fp->filp->f_path.dentry, offset, length);\n\t\terr = ksmbd_vfs_write(work, fp, data_buf, length, &offset,\n\t\t\t\t      writethrough, &nbytes);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t/* read data from the client using rdma channel, and\n\t\t * write the data.\n\t\t */\n\t\tnbytes = smb2_write_rdma_channel(work, req, fp, offset,\n\t\t\t\t\t\t le32_to_cpu(req->RemainingBytes),\n\t\t\t\t\t\t writethrough);\n\t\tif (nbytes < 0) {\n\t\t\terr = (int)nbytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (err == -ENOSPC || err == -EFBIG)\n\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\telse if (err == -ENOENT)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (err == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (err == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (err == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint smb2_write(struct ksmbd_work *work)\n{\n\tstruct smb2_write_req *req;\n\tstruct smb2_write_rsp *rsp;\n\tstruct ksmbd_file *fp = NULL;\n\tloff_t offset;\n\tsize_t length;\n\tssize_t nbytes;\n\tchar *data_buf;\n\tbool writethrough = false, is_rdma_channel = false;\n\tint err = 0;\n\tunsigned int max_write_size = work->conn->vals->max_write_size;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe write request\\n\");\n\t\treturn smb2_write_pipe(work);\n\t}\n\n\toffset = le64_to_cpu(req->Offset);\n\tlength = le32_to_cpu(req->Length);\n\n\tif (req->Channel == SMB2_CHANNEL_RDMA_V1 ||\n\t    req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) {\n\t\tis_rdma_channel = true;\n\t\tmax_write_size = get_smbd_max_read_write_size();\n\t\tlength = le32_to_cpu(req->RemainingBytes);\n\t}\n\n\tif (is_rdma_channel == true) {\n\t\tunsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset);\n\n\t\tif (req->Length != 0 || req->DataOffset != 0 ||\n\t\t    ch_offset < offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = smb2_set_remote_key_for_rdma(work,\n\t\t\t\t\t\t   (struct smb2_buffer_desc_v1 *)\n\t\t\t\t\t\t   ((char *)req + ch_offset),\n\t\t\t\t\t\t   req->Channel,\n\t\t\t\t\t\t   req->WriteChannelInfoLength);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tksmbd_debug(SMB, \"User does not have write permission\\n\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);\n\tif (!fp) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) {\n\t\tpr_err(\"Not permitted to write : 0x%x\\n\", fp->daccess);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (length > max_write_size) {\n\t\tksmbd_debug(SMB, \"limiting write size to max size(%u)\\n\",\n\t\t\t    max_write_size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n\tif (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH)\n\t\twritethrough = true;\n\n\tif (is_rdma_channel == false) {\n\t\tif (le16_to_cpu(req->DataOffset) <\n\t\t    offsetof(struct smb2_write_req, Buffer)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n\t\t\t\t    le16_to_cpu(req->DataOffset));\n\n\t\tksmbd_debug(SMB, \"filename %pd, offset %lld, len %zu\\n\",\n\t\t\t    fp->filp->f_path.dentry, offset, length);\n\t\terr = ksmbd_vfs_write(work, fp, data_buf, length, &offset,\n\t\t\t\t      writethrough, &nbytes);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t/* read data from the client using rdma channel, and\n\t\t * write the data.\n\t\t */\n\t\tnbytes = smb2_write_rdma_channel(work, req, fp, offset, length,\n\t\t\t\t\t\t writethrough);\n\t\tif (nbytes < 0) {\n\t\t\terr = (int)nbytes;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trsp->StructureSize = cpu_to_le16(17);\n\trsp->DataOffset = 0;\n\trsp->Reserved = 0;\n\trsp->DataLength = cpu_to_le32(nbytes);\n\trsp->DataRemaining = 0;\n\trsp->Reserved2 = 0;\n\tinc_rfc1001_len(work->response_buf, 16);\n\tksmbd_fd_put(work, fp);\n\treturn 0;\n\nout:\n\tif (err == -EAGAIN)\n\t\trsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT;\n\telse if (err == -ENOSPC || err == -EFBIG)\n\t\trsp->hdr.Status = STATUS_DISK_FULL;\n\telse if (err == -ENOENT)\n\t\trsp->hdr.Status = STATUS_FILE_CLOSED;\n\telse if (err == -EACCES)\n\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\telse if (err == -ESHARE)\n\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\telse if (err == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse\n\t\trsp->hdr.Status = STATUS_INVALID_HANDLE;\n\n\tsmb2_set_err_rsp(work);\n\tksmbd_fd_put(work, fp);\n\treturn err;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 3510,
            "cve_id": "CVE-2022-2905",
            "code_snippet": "static int\nrecord_func_key(struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta,\n\t\tint func_id, int insn_idx)\n{\n\tstruct bpf_insn_aux_data *aux = &env->insn_aux_data[insn_idx];\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg;\n\tstruct bpf_map *map = meta->map_ptr;\n\tu64 val, max;\n\tint err;\n\n\tif (func_id != BPF_FUNC_tail_call)\n\t\treturn 0;\n\tif (!map || map->map_type != BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tverbose(env, \"kernel subsystem misconfigured verifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = &regs[BPF_REG_3];\n\tval = reg->var_off.value;\n\tmax = map->max_entries;\n\n\tif (!(register_is_const(reg) && val < max)) {\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\t\treturn 0;\n\t}\n\n\terr = mark_chain_precision(env, BPF_REG_3);\n\tif (err)\n\t\treturn err;\n\tif (bpf_map_key_unseen(aux))\n\t\tbpf_map_key_store(aux, val);\n\telse if (!bpf_map_key_poisoned(aux) &&\n\t\t  bpf_map_key_immediate(aux) != val)\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2021-3444"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int\nrecord_func_key(struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta,\n\t\tint func_id, int insn_idx)\n{\n\tstruct bpf_insn_aux_data *aux = &env->insn_aux_data[insn_idx];\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg;\n\tstruct bpf_map *map = meta->map_ptr;\n\tu64 val, max;\n\tint err;\n\n\tif (func_id != BPF_FUNC_tail_call)\n\t\treturn 0;\n\tif (!map || map->map_type != BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tverbose(env, \"kernel subsystem misconfigured verifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = &regs[BPF_REG_3];\n\tval = reg->var_off.value;\n\tmax = map->max_entries;\n\n\tif (!(register_is_const(reg) && val < max)) {\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\t\treturn 0;\n\t}\n\n\terr = mark_chain_precision(env, BPF_REG_3);\n\tif (err)\n\t\treturn err;\n\tif (bpf_map_key_unseen(aux))\n\t\tbpf_map_key_store(aux, val);\n\telse if (!bpf_map_key_poisoned(aux) &&\n\t\t  bpf_map_key_immediate(aux) != val)\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1, 0),\n\t\t\t\t*insn,\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tbool expect_blinding = bpf_jit_blinding_enabled(prog);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, ret, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n\t\t\tstruct bpf_insn *patchlet;\n\t\t\tstruct bpf_insn chk_and_div[] = {\n\t\t\t\t/* [R,W]x div 0 -> 0 */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 2, 0),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn chk_and_mod[] = {\n\t\t\t\t/* [R,W]x mod 0 -> [R,W]x */\n\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) |\n\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n\t\t\t\t\t     0, 1 + (is64 ? 0 : 1), 0),\n\t\t\t\t*insn,\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\tBPF_MOV32_REG(insn->dst_reg, insn->dst_reg),\n\t\t\t};\n\n\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n\t\t\t\t      ARRAY_SIZE(chk_and_mod) - (is64 ? 2 : 0);\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state ||\n\t\t\t    aux->alu_state == BPF_ALU_NON_POINTER)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tif (!allow_tail_call_in_subprogs(env))\n\t\t\t\tprog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tprog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (env->bpf_capable && !expect_blinding &&\n\t\t\t    prog->jit_requested &&\n\t\t\t    !bpf_map_key_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_poisoned(aux) &&\n\t\t\t    !bpf_map_ptr_unpriv(aux)) {\n\t\t\t\tstruct bpf_jit_poke_descriptor desc = {\n\t\t\t\t\t.reason = BPF_POKE_REASON_TAIL_CALL,\n\t\t\t\t\t.tail_call.map = BPF_MAP_PTR(aux->map_ptr_state),\n\t\t\t\t\t.tail_call.key = bpf_map_key_immediate(aux),\n\t\t\t\t\t.insn_idx = i + delta,\n\t\t\t\t};\n\n\t\t\t\tret = bpf_jit_add_poke_descriptor(prog, &desc);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tverbose(env, \"adding tail call poke descriptor failed\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tinsn->imm = ret + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_ptr_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == -EOPNOTSUPP)\n\t\t\t\t\tgoto patch_map_ops_generic;\n\t\t\t\tif (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\npatch_map_ops_generic:\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    insn->imm == BPF_FUNC_jiffies64) {\n\t\t\tstruct bpf_insn ld_jiffies_addr[2] = {\n\t\t\t\tBPF_LD_IMM64(BPF_REG_0,\n\t\t\t\t\t     (unsigned long)&jiffies),\n\t\t\t};\n\n\t\t\tinsn_buf[0] = ld_jiffies_addr[0];\n\t\t\tinsn_buf[1] = ld_jiffies_addr[1];\n\t\t\tinsn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0,\n\t\t\t\t\t\t  BPF_REG_0, 0);\n\t\t\tcnt = 3;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\t/* Since poke tab is now finalized, publish aux to tracker. */\n\tfor (i = 0; i < prog->aux->size_poke_tab; i++) {\n\t\tmap_ptr = prog->aux->poke_tab[i].tail_call.map;\n\t\tif (!map_ptr->ops->map_poke_track ||\n\t\t    !map_ptr->ops->map_poke_untrack ||\n\t\t    !map_ptr->ops->map_poke_run) {\n\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = map_ptr->ops->map_poke_track(map_ptr, prog->aux);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"tracking tail call prog failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}",
                        "code_after_change": "static int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}",
                        "cve_id": "CVE-2020-0430"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int\nrecord_func_key(struct bpf_verifier_env *env, struct bpf_call_arg_meta *meta,\n\t\tint func_id, int insn_idx)\n{\n\tstruct bpf_insn_aux_data *aux = &env->insn_aux_data[insn_idx];\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg;\n\tstruct bpf_map *map = meta->map_ptr;\n\tu64 val, max;\n\tint err;\n\n\tif (func_id != BPF_FUNC_tail_call)\n\t\treturn 0;\n\tif (!map || map->map_type != BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tverbose(env, \"kernel subsystem misconfigured verifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = &regs[BPF_REG_3];\n\tval = reg->var_off.value;\n\tmax = map->max_entries;\n\n\tif (!(register_is_const(reg) && val < max)) {\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\t\treturn 0;\n\t}\n\n\terr = mark_chain_precision(env, BPF_REG_3);\n\tif (err)\n\t\treturn err;\n\tif (bpf_map_key_unseen(aux))\n\t\tbpf_map_key_store(aux, val);\n\telse if (!bpf_map_key_poisoned(aux) &&\n\t\t  bpf_map_key_immediate(aux) != val)\n\t\tbpf_map_key_store(aux, BPF_MAP_KEY_POISON);\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (!type_is_pkt_pointer(type) && type != PTR_TO_MAP_VALUE &&\n\t\t    type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = SCALAR_VALUE;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a SCALAR_VALUE type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (register_is_null(reg) &&\n\t\t    arg_type == ARG_PTR_TO_MEM_OR_NULL)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (!type_is_pkt_pointer(type) &&\n\t\t\t type != PTR_TO_MAP_VALUE &&\n\t\t\t type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(env, \"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* remember the mem_size which may be used later\n\t\t * to refine return values.\n\t\t */\n\t\tmeta->msize_smax_value = reg->smax_value;\n\t\tmeta->msize_umax_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "YES"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 1
        },
        {
            "id": 1349,
            "cve_id": "CVE-2017-16912",
            "code_snippet": "static int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\n\tif (epnum < 0 || epnum > 15)\n\t\tgoto err_ret;\n\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep)\n\t\tgoto err_ret;\n\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\nerr_ret:\n\t/* NOT REACHED */\n\tdev_err(&sdev->udev->dev, \"get pipe() invalid epnum %d\\n\", epnum);\n\treturn -1;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "code_after_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "cve_id": "CVE-2023-37453"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\n\tif (epnum < 0 || epnum > 15)\n\t\tgoto err_ret;\n\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep)\n\t\tgoto err_ret;\n\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\nerr_ret:\n\t/* NOT REACHED */\n\tdev_err(&sdev->udev->dev, \"get pipe() invalid epnum %d\\n\", epnum);\n\treturn -1;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}",
                        "code_after_change": "static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i, NULL);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}",
                        "cve_id": "CVE-2023-37453"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\n\tif (epnum < 0 || epnum > 15)\n\t\tgoto err_ret;\n\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep)\n\t\tgoto err_ret;\n\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\nerr_ret:\n\t/* NOT REACHED */\n\tdev_err(&sdev->udev->dev, \"get pipe() invalid epnum %d\\n\", epnum);\n\treturn -1;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tstatus = hub_port_init(hub, udev, port1, i, NULL);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tint r, alt;\n\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(&intf->altsetting[alt], eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t/*\n\t * ASMedia has a number of usb3 to sata bridge chips, at the time of\n\t * this writing the following versions exist:\n\t * ASM1051 - no uas support version\n\t * ASM1051 - with broken (*) uas support\n\t * ASM1053 - with working uas support, but problems with large xfers\n\t * ASM1153 - with working uas support\n\t *\n\t * Devices with these chips re-use a number of device-ids over the\n\t * entire line, so the device-id is useless to determine if we're\n\t * dealing with an ASM1051 (which we want to avoid).\n\t *\n\t * The ASM1153 can be identified by config.MaxPower == 0,\n\t * where as the ASM105x models have config.MaxPower == 36.\n\t *\n\t * Differentiating between the ASM1053 and ASM1051 is trickier, when\n\t * connected over USB-3 we can look at the number of streams supported,\n\t * ASM1051 supports 32 streams, where as early ASM1053 versions support\n\t * 16 streams, newer ASM1053-s also support 32 streams, but have a\n\t * different prod-id.\n\t *\n\t * (*) ASM1051 chips do work with UAS with some disks (with the\n\t *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks\n\t */\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t/* ASM1153, do nothing */\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t/* No streams info, assume ASM1051 */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t/* Possibly an ASM1051, disable uas */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t/* ASM1053, these have issues with large transfers */\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}",
                        "code_after_change": "static int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tstruct usb_host_interface *alt;\n\tint r;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (!alt)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(alt, eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t/*\n\t * ASMedia has a number of usb3 to sata bridge chips, at the time of\n\t * this writing the following versions exist:\n\t * ASM1051 - no uas support version\n\t * ASM1051 - with broken (*) uas support\n\t * ASM1053 - with working uas support, but problems with large xfers\n\t * ASM1153 - with working uas support\n\t *\n\t * Devices with these chips re-use a number of device-ids over the\n\t * entire line, so the device-id is useless to determine if we're\n\t * dealing with an ASM1051 (which we want to avoid).\n\t *\n\t * The ASM1153 can be identified by config.MaxPower == 0,\n\t * where as the ASM105x models have config.MaxPower == 36.\n\t *\n\t * Differentiating between the ASM1053 and ASM1051 is trickier, when\n\t * connected over USB-3 we can look at the number of streams supported,\n\t * ASM1051 supports 32 streams, where as early ASM1053 versions support\n\t * 16 streams, newer ASM1053-s also support 32 streams, but have a\n\t * different prod-id.\n\t *\n\t * (*) ASM1051 chips do work with UAS with some disks (with the\n\t *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks\n\t */\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t/* ASM1153, do nothing */\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t/* No streams info, assume ASM1051 */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t/* Possibly an ASM1051, disable uas */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t/* ASM1053, these have issues with large transfers */\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}",
                        "cve_id": "CVE-2017-16530"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\n\tif (epnum < 0 || epnum > 15)\n\t\tgoto err_ret;\n\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep)\n\t\tgoto err_ret;\n\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\nerr_ret:\n\t/* NOT REACHED */\n\tdev_err(&sdev->udev->dev, \"get pipe() invalid epnum %d\\n\", epnum);\n\treturn -1;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tint r, alt;\n\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(&intf->altsetting[alt], eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t/*\n\t * ASMedia has a number of usb3 to sata bridge chips, at the time of\n\t * this writing the following versions exist:\n\t * ASM1051 - no uas support version\n\t * ASM1051 - with broken (*) uas support\n\t * ASM1053 - with working uas support, but problems with large xfers\n\t * ASM1153 - with working uas support\n\t *\n\t * Devices with these chips re-use a number of device-ids over the\n\t * entire line, so the device-id is useless to determine if we're\n\t * dealing with an ASM1051 (which we want to avoid).\n\t *\n\t * The ASM1153 can be identified by config.MaxPower == 0,\n\t * where as the ASM105x models have config.MaxPower == 36.\n\t *\n\t * Differentiating between the ASM1053 and ASM1051 is trickier, when\n\t * connected over USB-3 we can look at the number of streams supported,\n\t * ASM1051 supports 32 streams, where as early ASM1053 versions support\n\t * 16 streams, newer ASM1053-s also support 32 streams, but have a\n\t * different prod-id.\n\t *\n\t * (*) ASM1051 chips do work with UAS with some disks (with the\n\t *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks\n\t */\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t/* ASM1153, do nothing */\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t/* No streams info, assume ASM1051 */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t/* Possibly an ASM1051, disable uas */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t/* ASM1053, these have issues with large transfers */\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tstruct usb_host_interface *alt;\n\tint r;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (!alt)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(alt, eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t/*\n\t * ASMedia has a number of usb3 to sata bridge chips, at the time of\n\t * this writing the following versions exist:\n\t * ASM1051 - no uas support version\n\t * ASM1051 - with broken (*) uas support\n\t * ASM1053 - with working uas support, but problems with large xfers\n\t * ASM1153 - with working uas support\n\t *\n\t * Devices with these chips re-use a number of device-ids over the\n\t * entire line, so the device-id is useless to determine if we're\n\t * dealing with an ASM1051 (which we want to avoid).\n\t *\n\t * The ASM1153 can be identified by config.MaxPower == 0,\n\t * where as the ASM105x models have config.MaxPower == 36.\n\t *\n\t * Differentiating between the ASM1053 and ASM1051 is trickier, when\n\t * connected over USB-3 we can look at the number of streams supported,\n\t * ASM1051 supports 32 streams, where as early ASM1053 versions support\n\t * 16 streams, newer ASM1053-s also support 32 streams, but have a\n\t * different prod-id.\n\t *\n\t * (*) ASM1051 chips do work with UAS with some disks (with the\n\t *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks\n\t */\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t/* ASM1153, do nothing */\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t/* No streams info, assume ASM1051 */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t/* Possibly an ASM1051, disable uas */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t/* ASM1053, these have issues with large transfers */\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 3334,
            "cve_id": "CVE-2022-20132",
            "code_snippet": "static int u2fzero_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct u2fzero_device *dev;\n\tunsigned int minor;\n\tint ret;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->hw_revision = id->driver_data;\n\n\tdev->buf_out = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_report), GFP_KERNEL);\n\tif (dev->buf_out == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->buf_in = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_msg), GFP_KERNEL);\n\tif (dev->buf_in == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->hdev = hdev;\n\thid_set_drvdata(hdev, dev);\n\tmutex_init(&dev->lock);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tu2fzero_fill_in_urb(dev);\n\n\tdev->present = true;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tret = u2fzero_init_led(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s LED initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\tret = u2fzero_init_hwrng(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s RNG initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct asus_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (drvdata == NULL) {\n\t\thid_err(hdev, \"Can't alloc Asus descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, drvdata);\n\n\tdrvdata->quirks = id->driver_data;\n\n\t/*\n\t * T90CHI's keyboard dock returns same ID values as T100CHI's dock.\n\t * Thus, identify T90CHI dock with product name string.\n\t */\n\tif (strstr(hdev->name, \"T90CHI\")) {\n\t\tdrvdata->quirks &= ~QUIRK_T100CHI;\n\t\tdrvdata->quirks |= QUIRK_T90CHI;\n\t}\n\n\tif (drvdata->quirks & QUIRK_IS_MULTITOUCH)\n\t\tdrvdata->tp = &asus_i2c_tp;\n\n\tif ((drvdata->quirks & QUIRK_T100_KEYBOARD) &&\n\t    hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\t\tif (intf->altsetting->desc.bInterfaceNumber == T100_TPAD_INTF) {\n\t\t\tdrvdata->quirks = QUIRK_SKIP_INPUT_MAPPING;\n\t\t\t/*\n\t\t\t * The T100HA uses the same USB-ids as the T100TAF and\n\t\t\t * the T200TA uses the same USB-ids as the T100TA, while\n\t\t\t * both have different max x/y values as the T100TA[F].\n\t\t\t */\n\t\t\tif (dmi_match(DMI_PRODUCT_NAME, \"T100HAN\"))\n\t\t\t\tdrvdata->tp = &asus_t100ha_tp;\n\t\t\telse if (dmi_match(DMI_PRODUCT_NAME, \"T200TA\"))\n\t\t\t\tdrvdata->tp = &asus_t200ta_tp;\n\t\t\telse\n\t\t\t\tdrvdata->tp = &asus_t100ta_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_T100CHI) {\n\t\t/*\n\t\t * All functionality is on a single HID interface and for\n\t\t * userspace the touchpad must be a separate input_dev.\n\t\t */\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\tdrvdata->tp = &asus_t100chi_tp;\n\t}\n\n\tif ((drvdata->quirks & QUIRK_MEDION_E1239T) &&\n\t    hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tstruct usb_host_interface *alt =\n\t\t\tto_usb_interface(hdev->dev.parent)->altsetting;\n\n\t\tif (alt->desc.bInterfaceNumber == MEDION_E1239T_TPAD_INTF) {\n\t\t\t/* For separate input-devs for tp and tp toggle key */\n\t\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\t\tdrvdata->quirks |= QUIRK_SKIP_INPUT_MAPPING;\n\t\t\tdrvdata->tp = &medion_e1239t_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_NO_INIT_REPORTS)\n\t\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\tdrvdata->hdev = hdev;\n\n\tif (drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) {\n\t\tret = asus_battery_probe(hdev);\n\t\tif (ret) {\n\t\t\thid_err(hdev,\n\t\t\t    \"Asus hid battery_probe failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hid parse failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hw start failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!drvdata->input) {\n\t\thid_err(hdev, \"Asus input not registered\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tif (drvdata->tp) {\n\t\tdrvdata->input->name = \"Asus TouchPad\";\n\t} else {\n\t\tdrvdata->input->name = \"Asus Keyboard\";\n\t}\n\n\tif (drvdata->tp) {\n\t\tret = asus_start_multitouch(hdev);\n\t\tif (ret)\n\t\t\tgoto err_stop_hw;\n\t}\n\n\treturn 0;\nerr_stop_hw:\n\thid_hw_stop(hdev);\n\treturn ret;\n}",
                        "code_after_change": "static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct asus_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (drvdata == NULL) {\n\t\thid_err(hdev, \"Can't alloc Asus descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, drvdata);\n\n\tdrvdata->quirks = id->driver_data;\n\n\t/*\n\t * T90CHI's keyboard dock returns same ID values as T100CHI's dock.\n\t * Thus, identify T90CHI dock with product name string.\n\t */\n\tif (strstr(hdev->name, \"T90CHI\")) {\n\t\tdrvdata->quirks &= ~QUIRK_T100CHI;\n\t\tdrvdata->quirks |= QUIRK_T90CHI;\n\t}\n\n\tif (drvdata->quirks & QUIRK_IS_MULTITOUCH)\n\t\tdrvdata->tp = &asus_i2c_tp;\n\n\tif ((drvdata->quirks & QUIRK_T100_KEYBOARD) && hid_is_usb(hdev)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\t\tif (intf->altsetting->desc.bInterfaceNumber == T100_TPAD_INTF) {\n\t\t\tdrvdata->quirks = QUIRK_SKIP_INPUT_MAPPING;\n\t\t\t/*\n\t\t\t * The T100HA uses the same USB-ids as the T100TAF and\n\t\t\t * the T200TA uses the same USB-ids as the T100TA, while\n\t\t\t * both have different max x/y values as the T100TA[F].\n\t\t\t */\n\t\t\tif (dmi_match(DMI_PRODUCT_NAME, \"T100HAN\"))\n\t\t\t\tdrvdata->tp = &asus_t100ha_tp;\n\t\t\telse if (dmi_match(DMI_PRODUCT_NAME, \"T200TA\"))\n\t\t\t\tdrvdata->tp = &asus_t200ta_tp;\n\t\t\telse\n\t\t\t\tdrvdata->tp = &asus_t100ta_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_T100CHI) {\n\t\t/*\n\t\t * All functionality is on a single HID interface and for\n\t\t * userspace the touchpad must be a separate input_dev.\n\t\t */\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\tdrvdata->tp = &asus_t100chi_tp;\n\t}\n\n\tif ((drvdata->quirks & QUIRK_MEDION_E1239T) && hid_is_usb(hdev)) {\n\t\tstruct usb_host_interface *alt =\n\t\t\tto_usb_interface(hdev->dev.parent)->altsetting;\n\n\t\tif (alt->desc.bInterfaceNumber == MEDION_E1239T_TPAD_INTF) {\n\t\t\t/* For separate input-devs for tp and tp toggle key */\n\t\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\t\tdrvdata->quirks |= QUIRK_SKIP_INPUT_MAPPING;\n\t\t\tdrvdata->tp = &medion_e1239t_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_NO_INIT_REPORTS)\n\t\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\tdrvdata->hdev = hdev;\n\n\tif (drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) {\n\t\tret = asus_battery_probe(hdev);\n\t\tif (ret) {\n\t\t\thid_err(hdev,\n\t\t\t    \"Asus hid battery_probe failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hid parse failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hw start failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!drvdata->input) {\n\t\thid_err(hdev, \"Asus input not registered\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tif (drvdata->tp) {\n\t\tdrvdata->input->name = \"Asus TouchPad\";\n\t} else {\n\t\tdrvdata->input->name = \"Asus Keyboard\";\n\t}\n\n\tif (drvdata->tp) {\n\t\tret = asus_start_multitouch(hdev);\n\t\tif (ret)\n\t\t\tgoto err_stop_hw;\n\t}\n\n\treturn 0;\nerr_stop_hw:\n\thid_hw_stop(hdev);\n\treturn ret;\n}",
                        "cve_id": "CVE-2022-20132"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int u2fzero_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct u2fzero_device *dev;\n\tunsigned int minor;\n\tint ret;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->hw_revision = id->driver_data;\n\n\tdev->buf_out = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_report), GFP_KERNEL);\n\tif (dev->buf_out == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->buf_in = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_msg), GFP_KERNEL);\n\tif (dev->buf_in == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->hdev = hdev;\n\thid_set_drvdata(hdev, dev);\n\tmutex_init(&dev->lock);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tu2fzero_fill_in_urb(dev);\n\n\tdev->present = true;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tret = u2fzero_init_led(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s LED initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\tret = u2fzero_init_hwrng(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s RNG initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct asus_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (drvdata == NULL) {\n\t\thid_err(hdev, \"Can't alloc Asus descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, drvdata);\n\n\tdrvdata->quirks = id->driver_data;\n\n\t/*\n\t * T90CHI's keyboard dock returns same ID values as T100CHI's dock.\n\t * Thus, identify T90CHI dock with product name string.\n\t */\n\tif (strstr(hdev->name, \"T90CHI\")) {\n\t\tdrvdata->quirks &= ~QUIRK_T100CHI;\n\t\tdrvdata->quirks |= QUIRK_T90CHI;\n\t}\n\n\tif (drvdata->quirks & QUIRK_IS_MULTITOUCH)\n\t\tdrvdata->tp = &asus_i2c_tp;\n\n\tif ((drvdata->quirks & QUIRK_T100_KEYBOARD) &&\n\t    hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\t\tif (intf->altsetting->desc.bInterfaceNumber == T100_TPAD_INTF) {\n\t\t\tdrvdata->quirks = QUIRK_SKIP_INPUT_MAPPING;\n\t\t\t/*\n\t\t\t * The T100HA uses the same USB-ids as the T100TAF and\n\t\t\t * the T200TA uses the same USB-ids as the T100TA, while\n\t\t\t * both have different max x/y values as the T100TA[F].\n\t\t\t */\n\t\t\tif (dmi_match(DMI_PRODUCT_NAME, \"T100HAN\"))\n\t\t\t\tdrvdata->tp = &asus_t100ha_tp;\n\t\t\telse if (dmi_match(DMI_PRODUCT_NAME, \"T200TA\"))\n\t\t\t\tdrvdata->tp = &asus_t200ta_tp;\n\t\t\telse\n\t\t\t\tdrvdata->tp = &asus_t100ta_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_T100CHI) {\n\t\t/*\n\t\t * All functionality is on a single HID interface and for\n\t\t * userspace the touchpad must be a separate input_dev.\n\t\t */\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\tdrvdata->tp = &asus_t100chi_tp;\n\t}\n\n\tif ((drvdata->quirks & QUIRK_MEDION_E1239T) &&\n\t    hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tstruct usb_host_interface *alt =\n\t\t\tto_usb_interface(hdev->dev.parent)->altsetting;\n\n\t\tif (alt->desc.bInterfaceNumber == MEDION_E1239T_TPAD_INTF) {\n\t\t\t/* For separate input-devs for tp and tp toggle key */\n\t\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\t\tdrvdata->quirks |= QUIRK_SKIP_INPUT_MAPPING;\n\t\t\tdrvdata->tp = &medion_e1239t_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_NO_INIT_REPORTS)\n\t\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\tdrvdata->hdev = hdev;\n\n\tif (drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) {\n\t\tret = asus_battery_probe(hdev);\n\t\tif (ret) {\n\t\t\thid_err(hdev,\n\t\t\t    \"Asus hid battery_probe failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hid parse failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hw start failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!drvdata->input) {\n\t\thid_err(hdev, \"Asus input not registered\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tif (drvdata->tp) {\n\t\tdrvdata->input->name = \"Asus TouchPad\";\n\t} else {\n\t\tdrvdata->input->name = \"Asus Keyboard\";\n\t}\n\n\tif (drvdata->tp) {\n\t\tret = asus_start_multitouch(hdev);\n\t\tif (ret)\n\t\t\tgoto err_stop_hw;\n\t}\n\n\treturn 0;\nerr_stop_hw:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct asus_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (drvdata == NULL) {\n\t\thid_err(hdev, \"Can't alloc Asus descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, drvdata);\n\n\tdrvdata->quirks = id->driver_data;\n\n\t/*\n\t * T90CHI's keyboard dock returns same ID values as T100CHI's dock.\n\t * Thus, identify T90CHI dock with product name string.\n\t */\n\tif (strstr(hdev->name, \"T90CHI\")) {\n\t\tdrvdata->quirks &= ~QUIRK_T100CHI;\n\t\tdrvdata->quirks |= QUIRK_T90CHI;\n\t}\n\n\tif (drvdata->quirks & QUIRK_IS_MULTITOUCH)\n\t\tdrvdata->tp = &asus_i2c_tp;\n\n\tif ((drvdata->quirks & QUIRK_T100_KEYBOARD) && hid_is_usb(hdev)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\t\tif (intf->altsetting->desc.bInterfaceNumber == T100_TPAD_INTF) {\n\t\t\tdrvdata->quirks = QUIRK_SKIP_INPUT_MAPPING;\n\t\t\t/*\n\t\t\t * The T100HA uses the same USB-ids as the T100TAF and\n\t\t\t * the T200TA uses the same USB-ids as the T100TA, while\n\t\t\t * both have different max x/y values as the T100TA[F].\n\t\t\t */\n\t\t\tif (dmi_match(DMI_PRODUCT_NAME, \"T100HAN\"))\n\t\t\t\tdrvdata->tp = &asus_t100ha_tp;\n\t\t\telse if (dmi_match(DMI_PRODUCT_NAME, \"T200TA\"))\n\t\t\t\tdrvdata->tp = &asus_t200ta_tp;\n\t\t\telse\n\t\t\t\tdrvdata->tp = &asus_t100ta_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_T100CHI) {\n\t\t/*\n\t\t * All functionality is on a single HID interface and for\n\t\t * userspace the touchpad must be a separate input_dev.\n\t\t */\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\tdrvdata->tp = &asus_t100chi_tp;\n\t}\n\n\tif ((drvdata->quirks & QUIRK_MEDION_E1239T) && hid_is_usb(hdev)) {\n\t\tstruct usb_host_interface *alt =\n\t\t\tto_usb_interface(hdev->dev.parent)->altsetting;\n\n\t\tif (alt->desc.bInterfaceNumber == MEDION_E1239T_TPAD_INTF) {\n\t\t\t/* For separate input-devs for tp and tp toggle key */\n\t\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\t\tdrvdata->quirks |= QUIRK_SKIP_INPUT_MAPPING;\n\t\t\tdrvdata->tp = &medion_e1239t_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_NO_INIT_REPORTS)\n\t\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\tdrvdata->hdev = hdev;\n\n\tif (drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) {\n\t\tret = asus_battery_probe(hdev);\n\t\tif (ret) {\n\t\t\thid_err(hdev,\n\t\t\t    \"Asus hid battery_probe failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hid parse failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hw start failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!drvdata->input) {\n\t\thid_err(hdev, \"Asus input not registered\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tif (drvdata->tp) {\n\t\tdrvdata->input->name = \"Asus TouchPad\";\n\t} else {\n\t\tdrvdata->input->name = \"Asus Keyboard\";\n\t}\n\n\tif (drvdata->tp) {\n\t\tret = asus_start_multitouch(hdev);\n\t\tif (ret)\n\t\t\tgoto err_stop_hw;\n\t}\n\n\treturn 0;\nerr_stop_hw:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static void wacom_update_name(struct wacom *wacom, const char *suffix)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tchar name[WACOM_NAME_MAX - 20]; /* Leave some room for suffixes */\n\n\t/* Generic devices name unspecified */\n\tif ((features->type == HID_GENERIC) && !strcmp(\"Wacom HID\", features->name)) {\n\t\tchar *product_name = wacom->hdev->name;\n\n\t\tif (hid_is_using_ll_driver(wacom->hdev, &usb_hid_driver)) {\n\t\t\tstruct usb_interface *intf = to_usb_interface(wacom->hdev->dev.parent);\n\t\t\tstruct usb_device *dev = interface_to_usbdev(intf);\n\t\t\tproduct_name = dev->product;\n\t\t}\n\n\t\tif (wacom->hdev->bus == BUS_I2C) {\n\t\t\tsnprintf(name, sizeof(name), \"%s %X\",\n\t\t\t\t features->name, wacom->hdev->product);\n\t\t} else if (strstr(product_name, \"Wacom\") ||\n\t\t\t   strstr(product_name, \"wacom\") ||\n\t\t\t   strstr(product_name, \"WACOM\")) {\n\t\t\tstrlcpy(name, product_name, sizeof(name));\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"Wacom %s\", product_name);\n\t\t}\n\n\t\t/* strip out excess whitespaces */\n\t\twhile (1) {\n\t\t\tchar *gap = strstr(name, \"  \");\n\t\t\tif (gap == NULL)\n\t\t\t\tbreak;\n\t\t\t/* shift everything including the terminator */\n\t\t\tmemmove(gap, gap+1, strlen(gap));\n\t\t}\n\n\t\t/* get rid of trailing whitespace */\n\t\tif (name[strlen(name)-1] == ' ')\n\t\t\tname[strlen(name)-1] = '\\0';\n\t} else {\n\t\tstrlcpy(name, features->name, sizeof(name));\n\t}\n\n\tsnprintf(wacom_wac->name, sizeof(wacom_wac->name), \"%s%s\",\n\t\t name, suffix);\n\n\t/* Append the device type to the name */\n\tsnprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),\n\t\t\"%s%s Pen\", name, suffix);\n\tsnprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),\n\t\t\"%s%s Finger\", name, suffix);\n\tsnprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),\n\t\t\"%s%s Pad\", name, suffix);\n}",
                        "code_after_change": "static void wacom_update_name(struct wacom *wacom, const char *suffix)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tchar name[WACOM_NAME_MAX - 20]; /* Leave some room for suffixes */\n\n\t/* Generic devices name unspecified */\n\tif ((features->type == HID_GENERIC) && !strcmp(\"Wacom HID\", features->name)) {\n\t\tchar *product_name = wacom->hdev->name;\n\n\t\tif (hid_is_usb(wacom->hdev)) {\n\t\t\tstruct usb_interface *intf = to_usb_interface(wacom->hdev->dev.parent);\n\t\t\tstruct usb_device *dev = interface_to_usbdev(intf);\n\t\t\tproduct_name = dev->product;\n\t\t}\n\n\t\tif (wacom->hdev->bus == BUS_I2C) {\n\t\t\tsnprintf(name, sizeof(name), \"%s %X\",\n\t\t\t\t features->name, wacom->hdev->product);\n\t\t} else if (strstr(product_name, \"Wacom\") ||\n\t\t\t   strstr(product_name, \"wacom\") ||\n\t\t\t   strstr(product_name, \"WACOM\")) {\n\t\t\tstrlcpy(name, product_name, sizeof(name));\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"Wacom %s\", product_name);\n\t\t}\n\n\t\t/* strip out excess whitespaces */\n\t\twhile (1) {\n\t\t\tchar *gap = strstr(name, \"  \");\n\t\t\tif (gap == NULL)\n\t\t\t\tbreak;\n\t\t\t/* shift everything including the terminator */\n\t\t\tmemmove(gap, gap+1, strlen(gap));\n\t\t}\n\n\t\t/* get rid of trailing whitespace */\n\t\tif (name[strlen(name)-1] == ' ')\n\t\t\tname[strlen(name)-1] = '\\0';\n\t} else {\n\t\tstrlcpy(name, features->name, sizeof(name));\n\t}\n\n\tsnprintf(wacom_wac->name, sizeof(wacom_wac->name), \"%s%s\",\n\t\t name, suffix);\n\n\t/* Append the device type to the name */\n\tsnprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),\n\t\t\"%s%s Pen\", name, suffix);\n\tsnprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),\n\t\t\"%s%s Finger\", name, suffix);\n\tsnprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),\n\t\t\"%s%s Pad\", name, suffix);\n}",
                        "cve_id": "CVE-2022-20132"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int u2fzero_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct u2fzero_device *dev;\n\tunsigned int minor;\n\tint ret;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->hw_revision = id->driver_data;\n\n\tdev->buf_out = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_report), GFP_KERNEL);\n\tif (dev->buf_out == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->buf_in = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_msg), GFP_KERNEL);\n\tif (dev->buf_in == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->hdev = hdev;\n\thid_set_drvdata(hdev, dev);\n\tmutex_init(&dev->lock);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tu2fzero_fill_in_urb(dev);\n\n\tdev->present = true;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tret = u2fzero_init_led(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s LED initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\tret = u2fzero_init_hwrng(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s RNG initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic void wacom_update_name(struct wacom *wacom, const char *suffix)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tchar name[WACOM_NAME_MAX - 20]; /* Leave some room for suffixes */\n\n\t/* Generic devices name unspecified */\n\tif ((features->type == HID_GENERIC) && !strcmp(\"Wacom HID\", features->name)) {\n\t\tchar *product_name = wacom->hdev->name;\n\n\t\tif (hid_is_using_ll_driver(wacom->hdev, &usb_hid_driver)) {\n\t\t\tstruct usb_interface *intf = to_usb_interface(wacom->hdev->dev.parent);\n\t\t\tstruct usb_device *dev = interface_to_usbdev(intf);\n\t\t\tproduct_name = dev->product;\n\t\t}\n\n\t\tif (wacom->hdev->bus == BUS_I2C) {\n\t\t\tsnprintf(name, sizeof(name), \"%s %X\",\n\t\t\t\t features->name, wacom->hdev->product);\n\t\t} else if (strstr(product_name, \"Wacom\") ||\n\t\t\t   strstr(product_name, \"wacom\") ||\n\t\t\t   strstr(product_name, \"WACOM\")) {\n\t\t\tstrlcpy(name, product_name, sizeof(name));\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"Wacom %s\", product_name);\n\t\t}\n\n\t\t/* strip out excess whitespaces */\n\t\twhile (1) {\n\t\t\tchar *gap = strstr(name, \"  \");\n\t\t\tif (gap == NULL)\n\t\t\t\tbreak;\n\t\t\t/* shift everything including the terminator */\n\t\t\tmemmove(gap, gap+1, strlen(gap));\n\t\t}\n\n\t\t/* get rid of trailing whitespace */\n\t\tif (name[strlen(name)-1] == ' ')\n\t\t\tname[strlen(name)-1] = '\\0';\n\t} else {\n\t\tstrlcpy(name, features->name, sizeof(name));\n\t}\n\n\tsnprintf(wacom_wac->name, sizeof(wacom_wac->name), \"%s%s\",\n\t\t name, suffix);\n\n\t/* Append the device type to the name */\n\tsnprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),\n\t\t\"%s%s Pen\", name, suffix);\n\tsnprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),\n\t\t\"%s%s Finger\", name, suffix);\n\tsnprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),\n\t\t\"%s%s Pad\", name, suffix);\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic void wacom_update_name(struct wacom *wacom, const char *suffix)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tchar name[WACOM_NAME_MAX - 20]; /* Leave some room for suffixes */\n\n\t/* Generic devices name unspecified */\n\tif ((features->type == HID_GENERIC) && !strcmp(\"Wacom HID\", features->name)) {\n\t\tchar *product_name = wacom->hdev->name;\n\n\t\tif (hid_is_usb(wacom->hdev)) {\n\t\t\tstruct usb_interface *intf = to_usb_interface(wacom->hdev->dev.parent);\n\t\t\tstruct usb_device *dev = interface_to_usbdev(intf);\n\t\t\tproduct_name = dev->product;\n\t\t}\n\n\t\tif (wacom->hdev->bus == BUS_I2C) {\n\t\t\tsnprintf(name, sizeof(name), \"%s %X\",\n\t\t\t\t features->name, wacom->hdev->product);\n\t\t} else if (strstr(product_name, \"Wacom\") ||\n\t\t\t   strstr(product_name, \"wacom\") ||\n\t\t\t   strstr(product_name, \"WACOM\")) {\n\t\t\tstrlcpy(name, product_name, sizeof(name));\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"Wacom %s\", product_name);\n\t\t}\n\n\t\t/* strip out excess whitespaces */\n\t\twhile (1) {\n\t\t\tchar *gap = strstr(name, \"  \");\n\t\t\tif (gap == NULL)\n\t\t\t\tbreak;\n\t\t\t/* shift everything including the terminator */\n\t\t\tmemmove(gap, gap+1, strlen(gap));\n\t\t}\n\n\t\t/* get rid of trailing whitespace */\n\t\tif (name[strlen(name)-1] == ' ')\n\t\t\tname[strlen(name)-1] = '\\0';\n\t} else {\n\t\tstrlcpy(name, features->name, sizeof(name));\n\t}\n\n\tsnprintf(wacom_wac->name, sizeof(wacom_wac->name), \"%s%s\",\n\t\t name, suffix);\n\n\t/* Append the device type to the name */\n\tsnprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),\n\t\t\"%s%s Pen\", name, suffix);\n\tsnprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),\n\t\t\"%s%s Finger\", name, suffix);\n\tsnprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),\n\t\t\"%s%s Pad\", name, suffix);\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct dj_receiver_dev *djrcv_dev;\n\tstruct usb_interface *intf;\n\tunsigned int no_dj_interfaces = 0;\n\tbool has_hidpp = false;\n\tunsigned long flags;\n\tint retval;\n\n\t/*\n\t * Call to usbhid to fetch the HID descriptors of the current\n\t * interface subsequently call to the hid/hid-core to parse the\n\t * fetched descriptors.\n\t */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: parse failed\\n\", __func__);\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Some KVMs add an extra interface for e.g. mouse emulation. If we\n\t * treat these as logitech-dj interfaces then this causes input events\n\t * reported through this extra interface to not be reported correctly.\n\t * To avoid this, we treat these as generic-hid devices.\n\t */\n\tswitch (id->driver_data) {\n\tcase recvr_type_dj:\t\tno_dj_interfaces = 3; break;\n\tcase recvr_type_hidpp:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_gaming_hidpp:\tno_dj_interfaces = 3; break;\n\tcase recvr_type_mouse_only:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_27mhz:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_bluetooth:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_dinovo:\t\tno_dj_interfaces = 2; break;\n\t}\n\tif (hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tintf = to_usb_interface(hdev->dev.parent);\n\t\tif (intf && intf->altsetting->desc.bInterfaceNumber >=\n\t\t\t\t\t\t\tno_dj_interfaces) {\n\t\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\t\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t}\n\n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\n\t/* no input reports, bail out */\n\tif (list_empty(&rep_enum->report_list))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check for the HID++ application.\n\t * Note: we should theoretically check for HID++ and DJ\n\t * collections, but this will do.\n\t */\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xff000001)\n\t\t\thas_hidpp = true;\n\t}\n\n\t/*\n\t * Ignore interfaces without DJ/HID++ collection, they will not carry\n\t * any data, dont create any hid_device for them.\n\t */\n\tif (!has_hidpp && id->driver_data == recvr_type_dj)\n\t\treturn -ENODEV;\n\n\t/* get the current application attached to the node */\n\trep = list_first_entry(&rep_enum->report_list, struct hid_report, list);\n\tdjrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,\n\t\t\t\t\trep->application, has_hidpp);\n\tif (!djrcv_dev) {\n\t\thid_err(hdev, \"%s: dj_get_receiver_dev failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!rep_enum->numbered)\n\t\tdjrcv_dev->unnumbered_application = rep->application;\n\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tif (has_hidpp) {\n\t\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto switch_to_dj_mode_fail;\n\t\t}\n\t}\n\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\thid_err(hdev, \"%s: hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\n\tif (has_hidpp) {\n\t\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\t\tdjrcv_dev->ready = true;\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_query_paired_devices error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\t/*\n\t\t\t * This can happen with a KVM, let the probe succeed,\n\t\t\t * logi_dj_recv_queue_unknown_work will retry later.\n\t\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\n\tdj_put_receiver_dev(hdev);\n\treturn retval;\n}",
                        "code_after_change": "static int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct dj_receiver_dev *djrcv_dev;\n\tstruct usb_interface *intf;\n\tunsigned int no_dj_interfaces = 0;\n\tbool has_hidpp = false;\n\tunsigned long flags;\n\tint retval;\n\n\t/*\n\t * Call to usbhid to fetch the HID descriptors of the current\n\t * interface subsequently call to the hid/hid-core to parse the\n\t * fetched descriptors.\n\t */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: parse failed\\n\", __func__);\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Some KVMs add an extra interface for e.g. mouse emulation. If we\n\t * treat these as logitech-dj interfaces then this causes input events\n\t * reported through this extra interface to not be reported correctly.\n\t * To avoid this, we treat these as generic-hid devices.\n\t */\n\tswitch (id->driver_data) {\n\tcase recvr_type_dj:\t\tno_dj_interfaces = 3; break;\n\tcase recvr_type_hidpp:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_gaming_hidpp:\tno_dj_interfaces = 3; break;\n\tcase recvr_type_mouse_only:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_27mhz:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_bluetooth:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_dinovo:\t\tno_dj_interfaces = 2; break;\n\t}\n\tif (hid_is_usb(hdev)) {\n\t\tintf = to_usb_interface(hdev->dev.parent);\n\t\tif (intf && intf->altsetting->desc.bInterfaceNumber >=\n\t\t\t\t\t\t\tno_dj_interfaces) {\n\t\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\t\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t}\n\n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\n\t/* no input reports, bail out */\n\tif (list_empty(&rep_enum->report_list))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check for the HID++ application.\n\t * Note: we should theoretically check for HID++ and DJ\n\t * collections, but this will do.\n\t */\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xff000001)\n\t\t\thas_hidpp = true;\n\t}\n\n\t/*\n\t * Ignore interfaces without DJ/HID++ collection, they will not carry\n\t * any data, dont create any hid_device for them.\n\t */\n\tif (!has_hidpp && id->driver_data == recvr_type_dj)\n\t\treturn -ENODEV;\n\n\t/* get the current application attached to the node */\n\trep = list_first_entry(&rep_enum->report_list, struct hid_report, list);\n\tdjrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,\n\t\t\t\t\trep->application, has_hidpp);\n\tif (!djrcv_dev) {\n\t\thid_err(hdev, \"%s: dj_get_receiver_dev failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!rep_enum->numbered)\n\t\tdjrcv_dev->unnumbered_application = rep->application;\n\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tif (has_hidpp) {\n\t\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto switch_to_dj_mode_fail;\n\t\t}\n\t}\n\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\thid_err(hdev, \"%s: hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\n\tif (has_hidpp) {\n\t\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\t\tdjrcv_dev->ready = true;\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_query_paired_devices error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\t/*\n\t\t\t * This can happen with a KVM, let the probe succeed,\n\t\t\t * logi_dj_recv_queue_unknown_work will retry later.\n\t\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\n\tdj_put_receiver_dev(hdev);\n\treturn retval;\n}",
                        "cve_id": "CVE-2022-20132"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int u2fzero_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct u2fzero_device *dev;\n\tunsigned int minor;\n\tint ret;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->hw_revision = id->driver_data;\n\n\tdev->buf_out = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_report), GFP_KERNEL);\n\tif (dev->buf_out == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->buf_in = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_msg), GFP_KERNEL);\n\tif (dev->buf_in == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->hdev = hdev;\n\thid_set_drvdata(hdev, dev);\n\tmutex_init(&dev->lock);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tu2fzero_fill_in_urb(dev);\n\n\tdev->present = true;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tret = u2fzero_init_led(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s LED initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\tret = u2fzero_init_hwrng(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s RNG initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct dj_receiver_dev *djrcv_dev;\n\tstruct usb_interface *intf;\n\tunsigned int no_dj_interfaces = 0;\n\tbool has_hidpp = false;\n\tunsigned long flags;\n\tint retval;\n\n\t/*\n\t * Call to usbhid to fetch the HID descriptors of the current\n\t * interface subsequently call to the hid/hid-core to parse the\n\t * fetched descriptors.\n\t */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: parse failed\\n\", __func__);\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Some KVMs add an extra interface for e.g. mouse emulation. If we\n\t * treat these as logitech-dj interfaces then this causes input events\n\t * reported through this extra interface to not be reported correctly.\n\t * To avoid this, we treat these as generic-hid devices.\n\t */\n\tswitch (id->driver_data) {\n\tcase recvr_type_dj:\t\tno_dj_interfaces = 3; break;\n\tcase recvr_type_hidpp:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_gaming_hidpp:\tno_dj_interfaces = 3; break;\n\tcase recvr_type_mouse_only:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_27mhz:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_bluetooth:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_dinovo:\t\tno_dj_interfaces = 2; break;\n\t}\n\tif (hid_is_using_ll_driver(hdev, &usb_hid_driver)) {\n\t\tintf = to_usb_interface(hdev->dev.parent);\n\t\tif (intf && intf->altsetting->desc.bInterfaceNumber >=\n\t\t\t\t\t\t\tno_dj_interfaces) {\n\t\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\t\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t}\n\n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\n\t/* no input reports, bail out */\n\tif (list_empty(&rep_enum->report_list))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check for the HID++ application.\n\t * Note: we should theoretically check for HID++ and DJ\n\t * collections, but this will do.\n\t */\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xff000001)\n\t\t\thas_hidpp = true;\n\t}\n\n\t/*\n\t * Ignore interfaces without DJ/HID++ collection, they will not carry\n\t * any data, dont create any hid_device for them.\n\t */\n\tif (!has_hidpp && id->driver_data == recvr_type_dj)\n\t\treturn -ENODEV;\n\n\t/* get the current application attached to the node */\n\trep = list_first_entry(&rep_enum->report_list, struct hid_report, list);\n\tdjrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,\n\t\t\t\t\trep->application, has_hidpp);\n\tif (!djrcv_dev) {\n\t\thid_err(hdev, \"%s: dj_get_receiver_dev failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!rep_enum->numbered)\n\t\tdjrcv_dev->unnumbered_application = rep->application;\n\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tif (has_hidpp) {\n\t\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto switch_to_dj_mode_fail;\n\t\t}\n\t}\n\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\thid_err(hdev, \"%s: hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\n\tif (has_hidpp) {\n\t\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\t\tdjrcv_dev->ready = true;\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_query_paired_devices error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\t/*\n\t\t\t * This can happen with a KVM, let the probe succeed,\n\t\t\t * logi_dj_recv_queue_unknown_work will retry later.\n\t\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\n\tdj_put_receiver_dev(hdev);\n\treturn retval;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct dj_receiver_dev *djrcv_dev;\n\tstruct usb_interface *intf;\n\tunsigned int no_dj_interfaces = 0;\n\tbool has_hidpp = false;\n\tunsigned long flags;\n\tint retval;\n\n\t/*\n\t * Call to usbhid to fetch the HID descriptors of the current\n\t * interface subsequently call to the hid/hid-core to parse the\n\t * fetched descriptors.\n\t */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: parse failed\\n\", __func__);\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Some KVMs add an extra interface for e.g. mouse emulation. If we\n\t * treat these as logitech-dj interfaces then this causes input events\n\t * reported through this extra interface to not be reported correctly.\n\t * To avoid this, we treat these as generic-hid devices.\n\t */\n\tswitch (id->driver_data) {\n\tcase recvr_type_dj:\t\tno_dj_interfaces = 3; break;\n\tcase recvr_type_hidpp:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_gaming_hidpp:\tno_dj_interfaces = 3; break;\n\tcase recvr_type_mouse_only:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_27mhz:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_bluetooth:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_dinovo:\t\tno_dj_interfaces = 2; break;\n\t}\n\tif (hid_is_usb(hdev)) {\n\t\tintf = to_usb_interface(hdev->dev.parent);\n\t\tif (intf && intf->altsetting->desc.bInterfaceNumber >=\n\t\t\t\t\t\t\tno_dj_interfaces) {\n\t\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\t\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t}\n\n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\n\t/* no input reports, bail out */\n\tif (list_empty(&rep_enum->report_list))\n\t\treturn -ENODEV;\n\n\t/*\n\t * Check for the HID++ application.\n\t * Note: we should theoretically check for HID++ and DJ\n\t * collections, but this will do.\n\t */\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xff000001)\n\t\t\thas_hidpp = true;\n\t}\n\n\t/*\n\t * Ignore interfaces without DJ/HID++ collection, they will not carry\n\t * any data, dont create any hid_device for them.\n\t */\n\tif (!has_hidpp && id->driver_data == recvr_type_dj)\n\t\treturn -ENODEV;\n\n\t/* get the current application attached to the node */\n\trep = list_first_entry(&rep_enum->report_list, struct hid_report, list);\n\tdjrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,\n\t\t\t\t\trep->application, has_hidpp);\n\tif (!djrcv_dev) {\n\t\thid_err(hdev, \"%s: dj_get_receiver_dev failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!rep_enum->numbered)\n\t\tdjrcv_dev->unnumbered_application = rep->application;\n\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tif (has_hidpp) {\n\t\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto switch_to_dj_mode_fail;\n\t\t}\n\t}\n\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\thid_err(hdev, \"%s: hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\n\tif (has_hidpp) {\n\t\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\t\tdjrcv_dev->ready = true;\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_query_paired_devices error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\t/*\n\t\t\t * This can happen with a KVM, let the probe succeed,\n\t\t\t * logi_dj_recv_queue_unknown_work will retry later.\n\t\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\n\tdj_put_receiver_dev(hdev);\n\treturn retval;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 2660,
            "cve_id": "CVE-2020-28915",
            "code_snippet": "static int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tif (font->charcount * (vc->vc_font.height * sizeof(u32)) > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "code_after_change": "static int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}",
                        "cve_id": "CVE-2023-37453"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tif (font->charcount * (vc->vc_font.height * sizeof(u32)) > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}",
                        "code_after_change": "static ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tif (use_unicode(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}",
                        "cve_id": "CVE-2019-19252"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tif (font->charcount * (vc->vc_font.height * sizeof(u32)) > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tif (use_unicode(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "code_after_change": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}",
                        "cve_id": "CVE-2016-10208"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tif (font->charcount * (vc->vc_font.height * sizeof(u32)) > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tif (ext4_has_feature_meta_bg(sb)) {\n\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"first meta block group too large: %u \"\n\t\t\t\t \"(group descriptor block count %u)\",\n\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        },
        {
            "id": 1276,
            "cve_id": "CVE-2017-13305",
            "code_snippet": "static int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "ssize_t f2fs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr;\n\tint error = 0;\n\tsize_t rest = buffer_size;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = read_all_xattrs(inode, NULL, &base_addr);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tconst struct xattr_handler *handler =\n\t\t\tf2fs_xattr_handler(entry->e_name_index);\n\t\tconst char *prefix;\n\t\tsize_t prefix_len;\n\t\tsize_t size;\n\n\t\tif (!handler || (handler->list && !handler->list(dentry)))\n\t\t\tcontinue;\n\n\t\tprefix = xattr_prefix(handler);\n\t\tprefix_len = strlen(prefix);\n\t\tsize = prefix_len + entry->e_name_len + 1;\n\t\tif (buffer) {\n\t\t\tif (size > rest) {\n\t\t\t\terror = -ERANGE;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tmemcpy(buffer, prefix, prefix_len);\n\t\t\tbuffer += prefix_len;\n\t\t\tmemcpy(buffer, entry->e_name, entry->e_name_len);\n\t\t\tbuffer += entry->e_name_len;\n\t\t\t*buffer++ = 0;\n\t\t}\n\t\trest -= size;\n\t}\n\terror = buffer_size - rest;\ncleanup:\n\tkvfree(base_addr);\n\treturn error;\n}",
                        "code_after_change": "ssize_t f2fs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr, *last_base_addr;\n\tint error = 0;\n\tsize_t rest = buffer_size;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = read_all_xattrs(inode, NULL, &base_addr);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tlast_base_addr = (void *)base_addr + XATTR_SIZE(xnid, inode);\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tconst struct xattr_handler *handler =\n\t\t\tf2fs_xattr_handler(entry->e_name_index);\n\t\tconst char *prefix;\n\t\tsize_t prefix_len;\n\t\tsize_t size;\n\n\t\tif ((void *)(entry) + sizeof(__u32) > last_base_addr ||\n\t\t\t(void *)XATTR_NEXT_ENTRY(entry) > last_base_addr) {\n\t\t\tf2fs_err(F2FS_I_SB(inode), \"inode (%lu) has corrupted xattr\",\n\t\t\t\t\t\tinode->i_ino);\n\t\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!handler || (handler->list && !handler->list(dentry)))\n\t\t\tcontinue;\n\n\t\tprefix = xattr_prefix(handler);\n\t\tprefix_len = strlen(prefix);\n\t\tsize = prefix_len + entry->e_name_len + 1;\n\t\tif (buffer) {\n\t\t\tif (size > rest) {\n\t\t\t\terror = -ERANGE;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tmemcpy(buffer, prefix, prefix_len);\n\t\t\tbuffer += prefix_len;\n\t\t\tmemcpy(buffer, entry->e_name, entry->e_name_len);\n\t\t\tbuffer += entry->e_name_len;\n\t\t\t*buffer++ = 0;\n\t\t}\n\t\trest -= size;\n\t}\n\terror = buffer_size - rest;\ncleanup:\n\tkvfree(base_addr);\n\treturn error;\n}",
                        "cve_id": "CVE-2020-0067"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nssize_t f2fs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr;\n\tint error = 0;\n\tsize_t rest = buffer_size;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = read_all_xattrs(inode, NULL, &base_addr);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tconst struct xattr_handler *handler =\n\t\t\tf2fs_xattr_handler(entry->e_name_index);\n\t\tconst char *prefix;\n\t\tsize_t prefix_len;\n\t\tsize_t size;\n\n\t\tif (!handler || (handler->list && !handler->list(dentry)))\n\t\t\tcontinue;\n\n\t\tprefix = xattr_prefix(handler);\n\t\tprefix_len = strlen(prefix);\n\t\tsize = prefix_len + entry->e_name_len + 1;\n\t\tif (buffer) {\n\t\t\tif (size > rest) {\n\t\t\t\terror = -ERANGE;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tmemcpy(buffer, prefix, prefix_len);\n\t\t\tbuffer += prefix_len;\n\t\t\tmemcpy(buffer, entry->e_name, entry->e_name_len);\n\t\t\tbuffer += entry->e_name_len;\n\t\t\t*buffer++ = 0;\n\t\t}\n\t\trest -= size;\n\t}\n\terror = buffer_size - rest;\ncleanup:\n\tkvfree(base_addr);\n\treturn error;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nssize_t f2fs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tstruct f2fs_xattr_entry *entry;\n\tvoid *base_addr, *last_base_addr;\n\tint error = 0;\n\tsize_t rest = buffer_size;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = read_all_xattrs(inode, NULL, &base_addr);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tlast_base_addr = (void *)base_addr + XATTR_SIZE(xnid, inode);\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tconst struct xattr_handler *handler =\n\t\t\tf2fs_xattr_handler(entry->e_name_index);\n\t\tconst char *prefix;\n\t\tsize_t prefix_len;\n\t\tsize_t size;\n\n\t\tif ((void *)(entry) + sizeof(__u32) > last_base_addr ||\n\t\t\t(void *)XATTR_NEXT_ENTRY(entry) > last_base_addr) {\n\t\t\tf2fs_err(F2FS_I_SB(inode), \"inode (%lu) has corrupted xattr\",\n\t\t\t\t\t\tinode->i_ino);\n\t\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!handler || (handler->list && !handler->list(dentry)))\n\t\t\tcontinue;\n\n\t\tprefix = xattr_prefix(handler);\n\t\tprefix_len = strlen(prefix);\n\t\tsize = prefix_len + entry->e_name_len + 1;\n\t\tif (buffer) {\n\t\t\tif (size > rest) {\n\t\t\t\terror = -ERANGE;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tmemcpy(buffer, prefix, prefix_len);\n\t\t\tbuffer += prefix_len;\n\t\t\tmemcpy(buffer, entry->e_name, entry->e_name_len);\n\t\t\tbuffer += entry->e_name_len;\n\t\t\t*buffer++ = 0;\n\t\t}\n\t\trest -= size;\n\t}\n\terror = buffer_size - rest;\ncleanup:\n\tkvfree(base_addr);\n\treturn error;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "struct lease_ctx_info *parse_lease_state(void *open_req)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next = 0;\n\tchar *name;\n\tbool found = false;\n\tstruct smb2_create_req *req = (struct smb2_create_req *)open_req;\n\tstruct lease_ctx_info *lreq = kzalloc(sizeof(struct lease_ctx_info),\n\t\tGFP_KERNEL);\n\tif (!lreq)\n\t\treturn NULL;\n\n\tdata_offset = (char *)req + le32_to_cpu(req->CreateContextsOffset);\n\tcc = (struct create_context *)data_offset;\n\tdo {\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) != 4 ||\n\t\t    strncmp(name, SMB2_CREATE_REQUEST_LEASE, 4)) {\n\t\t\tnext = le32_to_cpu(cc->Next);\n\t\t\tcontinue;\n\t\t}\n\t\tfound = true;\n\t\tbreak;\n\t} while (next != 0);\n\n\tif (found) {\n\t\tif (sizeof(struct lease_context_v2) == le32_to_cpu(cc->DataLength)) {\n\t\t\tstruct create_lease_v2 *lc = (struct create_lease_v2 *)cc;\n\n\t\t\tmemcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);\n\t\t\tlreq->req_state = lc->lcontext.LeaseState;\n\t\t\tlreq->flags = lc->lcontext.LeaseFlags;\n\t\t\tlreq->duration = lc->lcontext.LeaseDuration;\n\t\t\tmemcpy(lreq->parent_lease_key, lc->lcontext.ParentLeaseKey,\n\t\t\t       SMB2_LEASE_KEY_SIZE);\n\t\t\tlreq->version = 2;\n\t\t} else {\n\t\t\tstruct create_lease *lc = (struct create_lease *)cc;\n\n\t\t\tmemcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);\n\t\t\tlreq->req_state = lc->lcontext.LeaseState;\n\t\t\tlreq->flags = lc->lcontext.LeaseFlags;\n\t\t\tlreq->duration = lc->lcontext.LeaseDuration;\n\t\t\tlreq->version = 1;\n\t\t}\n\t\treturn lreq;\n\t}\n\n\tkfree(lreq);\n\treturn NULL;\n}",
                        "code_after_change": "static int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr, *last_base_addr;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (size > MAX_VALUE_LEN(inode))\n\t\treturn -E2BIG;\n\n\terror = read_all_xattrs(inode, ipage, &base_addr);\n\tif (error)\n\t\treturn error;\n\n\tlast_base_addr = (void *)base_addr + XATTR_SIZE(inode);\n\n\t/* find entry with wanted name. */\n\there = __find_xattr(base_addr, last_base_addr, index, len, name);\n\tif (!here) {\n\t\tf2fs_err(F2FS_I_SB(inode), \"inode (%lu) has corrupted xattr\",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto exit;\n\t}\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif (found) {\n\t\tif ((flags & XATTR_CREATE)) {\n\t\t\terror = -EEXIST;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (value && f2fs_xattr_value_same(here, value, size))\n\t\t\tgoto same;\n\t} else if ((flags & XATTR_REPLACE)) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last)) {\n\t\tif ((void *)(last) + sizeof(__u32) > last_base_addr ||\n\t\t\t(void *)XATTR_NEXT_ENTRY(last) > last_base_addr) {\n\t\t\tf2fs_err(F2FS_I_SB(inode), \"inode (%lu) has invalid last xattr entry, entry_size: %zu\",\n\t\t\t\t\tinode->i_ino, ENTRY_SIZE(last));\n\t\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto exit;\n\t\t}\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\t}\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t/* 1. Check space */\n\tif (value) {\n\t\tint free;\n\t\t/*\n\t\t * If value is NULL, it is remove operation.\n\t\t * In case of update operation, we calculate free.\n\t\t */\n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -E2BIG;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* 2. Remove old entry */\n\tif (found) {\n\t\t/*\n\t\t * If entry is found, remove old entry.\n\t\t * If not found, remove operation is not needed.\n\t\t */\n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t/* 3. Write new entry */\n\tif (value) {\n\t\tchar *pval;\n\t\t/*\n\t\t * Before we come here, old entry is removed.\n\t\t * We just write new entry.\n\t\t */\n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (index == F2FS_XATTR_INDEX_ENCRYPTION &&\n\t\t\t!strcmp(name, F2FS_XATTR_NAME_ENCRYPTION_CONTEXT))\n\t\tf2fs_set_encrypted_inode(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (!error && S_ISDIR(inode->i_mode))\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_CP);\n\nsame:\n\tif (is_inode_flag_set(inode, FI_ACL_MODE)) {\n\t\tinode->i_mode = F2FS_I(inode)->i_acl_mode;\n\t\tinode->i_ctime = current_time(inode);\n\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t}\n\nexit:\n\tkfree(base_addr);\n\treturn error;\n}",
                        "cve_id": "CVE-2023-1194"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstruct lease_ctx_info *parse_lease_state(void *open_req)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next = 0;\n\tchar *name;\n\tbool found = false;\n\tstruct smb2_create_req *req = (struct smb2_create_req *)open_req;\n\tstruct lease_ctx_info *lreq = kzalloc(sizeof(struct lease_ctx_info),\n\t\tGFP_KERNEL);\n\tif (!lreq)\n\t\treturn NULL;\n\n\tdata_offset = (char *)req + le32_to_cpu(req->CreateContextsOffset);\n\tcc = (struct create_context *)data_offset;\n\tdo {\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) != 4 ||\n\t\t    strncmp(name, SMB2_CREATE_REQUEST_LEASE, 4)) {\n\t\t\tnext = le32_to_cpu(cc->Next);\n\t\t\tcontinue;\n\t\t}\n\t\tfound = true;\n\t\tbreak;\n\t} while (next != 0);\n\n\tif (found) {\n\t\tif (sizeof(struct lease_context_v2) == le32_to_cpu(cc->DataLength)) {\n\t\t\tstruct create_lease_v2 *lc = (struct create_lease_v2 *)cc;\n\n\t\t\tmemcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);\n\t\t\tlreq->req_state = lc->lcontext.LeaseState;\n\t\t\tlreq->flags = lc->lcontext.LeaseFlags;\n\t\t\tlreq->duration = lc->lcontext.LeaseDuration;\n\t\t\tmemcpy(lreq->parent_lease_key, lc->lcontext.ParentLeaseKey,\n\t\t\t       SMB2_LEASE_KEY_SIZE);\n\t\t\tlreq->version = 2;\n\t\t} else {\n\t\t\tstruct create_lease *lc = (struct create_lease *)cc;\n\n\t\t\tmemcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);\n\t\t\tlreq->req_state = lc->lcontext.LeaseState;\n\t\t\tlreq->flags = lc->lcontext.LeaseFlags;\n\t\t\tlreq->duration = lc->lcontext.LeaseDuration;\n\t\t\tlreq->version = 1;\n\t\t}\n\t\treturn lreq;\n\t}\n\n\tkfree(lreq);\n\treturn NULL;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nstatic int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr, *last_base_addr;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (size > MAX_VALUE_LEN(inode))\n\t\treturn -E2BIG;\n\n\terror = read_all_xattrs(inode, ipage, &base_addr);\n\tif (error)\n\t\treturn error;\n\n\tlast_base_addr = (void *)base_addr + XATTR_SIZE(inode);\n\n\t/* find entry with wanted name. */\n\there = __find_xattr(base_addr, last_base_addr, index, len, name);\n\tif (!here) {\n\t\tf2fs_err(F2FS_I_SB(inode), \"inode (%lu) has corrupted xattr\",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto exit;\n\t}\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif (found) {\n\t\tif ((flags & XATTR_CREATE)) {\n\t\t\terror = -EEXIST;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (value && f2fs_xattr_value_same(here, value, size))\n\t\t\tgoto same;\n\t} else if ((flags & XATTR_REPLACE)) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last)) {\n\t\tif ((void *)(last) + sizeof(__u32) > last_base_addr ||\n\t\t\t(void *)XATTR_NEXT_ENTRY(last) > last_base_addr) {\n\t\t\tf2fs_err(F2FS_I_SB(inode), \"inode (%lu) has invalid last xattr entry, entry_size: %zu\",\n\t\t\t\t\tinode->i_ino, ENTRY_SIZE(last));\n\t\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto exit;\n\t\t}\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\t}\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t/* 1. Check space */\n\tif (value) {\n\t\tint free;\n\t\t/*\n\t\t * If value is NULL, it is remove operation.\n\t\t * In case of update operation, we calculate free.\n\t\t */\n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -E2BIG;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* 2. Remove old entry */\n\tif (found) {\n\t\t/*\n\t\t * If entry is found, remove old entry.\n\t\t * If not found, remove operation is not needed.\n\t\t */\n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t/* 3. Write new entry */\n\tif (value) {\n\t\tchar *pval;\n\t\t/*\n\t\t * Before we come here, old entry is removed.\n\t\t * We just write new entry.\n\t\t */\n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (index == F2FS_XATTR_INDEX_ENCRYPTION &&\n\t\t\t!strcmp(name, F2FS_XATTR_NAME_ENCRYPTION_CONTEXT))\n\t\tf2fs_set_encrypted_inode(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (!error && S_ISDIR(inode->i_mode))\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_CP);\n\nsame:\n\tif (is_inode_flag_set(inode, FI_ACL_MODE)) {\n\t\tinode->i_mode = F2FS_I(inode)->i_acl_mode;\n\t\tinode->i_ctime = current_time(inode);\n\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t}\n\nexit:\n\tkfree(base_addr);\n\treturn error;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr, *last_base_addr;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (size > MAX_VALUE_LEN(inode))\n\t\treturn -E2BIG;\n\n\terror = read_all_xattrs(inode, ipage, &base_addr);\n\tif (error)\n\t\treturn error;\n\n\tlast_base_addr = (void *)base_addr + XATTR_SIZE(inode);\n\n\t/* find entry with wanted name. */\n\there = __find_xattr(base_addr, last_base_addr, index, len, name);\n\tif (!here) {\n\t\tf2fs_err(F2FS_I_SB(inode), \"inode (%lu) has corrupted xattr\",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto exit;\n\t}\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif (found) {\n\t\tif ((flags & XATTR_CREATE)) {\n\t\t\terror = -EEXIST;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (value && f2fs_xattr_value_same(here, value, size))\n\t\t\tgoto same;\n\t} else if ((flags & XATTR_REPLACE)) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last))\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t/* 1. Check space */\n\tif (value) {\n\t\tint free;\n\t\t/*\n\t\t * If value is NULL, it is remove operation.\n\t\t * In case of update operation, we calculate free.\n\t\t */\n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -E2BIG;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* 2. Remove old entry */\n\tif (found) {\n\t\t/*\n\t\t * If entry is found, remove old entry.\n\t\t * If not found, remove operation is not needed.\n\t\t */\n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t/* 3. Write new entry */\n\tif (value) {\n\t\tchar *pval;\n\t\t/*\n\t\t * Before we come here, old entry is removed.\n\t\t * We just write new entry.\n\t\t */\n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (index == F2FS_XATTR_INDEX_ENCRYPTION &&\n\t\t\t!strcmp(name, F2FS_XATTR_NAME_ENCRYPTION_CONTEXT))\n\t\tf2fs_set_encrypted_inode(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (!error && S_ISDIR(inode->i_mode))\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_CP);\n\nsame:\n\tif (is_inode_flag_set(inode, FI_ACL_MODE)) {\n\t\tinode->i_mode = F2FS_I(inode)->i_acl_mode;\n\t\tinode->i_ctime = current_time(inode);\n\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t}\n\nexit:\n\tkfree(base_addr);\n\treturn error;\n}",
                        "code_after_change": "int f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry = NULL;\n\tint error = 0;\n\tunsigned int size, len;\n\tvoid *base_addr = NULL;\n\tint base_size;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = lookup_all_xattrs(inode, ipage, index, len, name,\n\t\t\t\t&entry, &base_addr, &base_size);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\n\t\tif (base_size - (pval - (char *)base_addr) < size) {\n\t\t\terror = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\nout:\n\tkzfree(base_addr);\n\treturn error;\n}",
                        "cve_id": "CVE-2021-45469"
                    },
                    "vul_detect_prompt": "I want you to act as a vulnerability detection expert, given the following code snippet and related vulnerability knowledge, please detect whether there is a vulnerability in the code snippet.\nCode Snippet:\n'''\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n'''\nRelated vulnerability code snippet:\n'''\nstatic int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr, *last_base_addr;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (size > MAX_VALUE_LEN(inode))\n\t\treturn -E2BIG;\n\n\terror = read_all_xattrs(inode, ipage, &base_addr);\n\tif (error)\n\t\treturn error;\n\n\tlast_base_addr = (void *)base_addr + XATTR_SIZE(inode);\n\n\t/* find entry with wanted name. */\n\there = __find_xattr(base_addr, last_base_addr, index, len, name);\n\tif (!here) {\n\t\tf2fs_err(F2FS_I_SB(inode), \"inode (%lu) has corrupted xattr\",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto exit;\n\t}\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif (found) {\n\t\tif ((flags & XATTR_CREATE)) {\n\t\t\terror = -EEXIST;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (value && f2fs_xattr_value_same(here, value, size))\n\t\t\tgoto same;\n\t} else if ((flags & XATTR_REPLACE)) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last))\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t/* 1. Check space */\n\tif (value) {\n\t\tint free;\n\t\t/*\n\t\t * If value is NULL, it is remove operation.\n\t\t * In case of update operation, we calculate free.\n\t\t */\n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -E2BIG;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* 2. Remove old entry */\n\tif (found) {\n\t\t/*\n\t\t * If entry is found, remove old entry.\n\t\t * If not found, remove operation is not needed.\n\t\t */\n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t/* 3. Write new entry */\n\tif (value) {\n\t\tchar *pval;\n\t\t/*\n\t\t * Before we come here, old entry is removed.\n\t\t * We just write new entry.\n\t\t */\n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (index == F2FS_XATTR_INDEX_ENCRYPTION &&\n\t\t\t!strcmp(name, F2FS_XATTR_NAME_ENCRYPTION_CONTEXT))\n\t\tf2fs_set_encrypted_inode(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (!error && S_ISDIR(inode->i_mode))\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_CP);\n\nsame:\n\tif (is_inode_flag_set(inode, FI_ACL_MODE)) {\n\t\tinode->i_mode = F2FS_I(inode)->i_acl_mode;\n\t\tinode->i_ctime = current_time(inode);\n\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t}\n\nexit:\n\tkfree(base_addr);\n\treturn error;\n}\n'''\nRelated non-vulnerability code snippet:\n'''\nint f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry = NULL;\n\tint error = 0;\n\tunsigned int size, len;\n\tvoid *base_addr = NULL;\n\tint base_size;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = lookup_all_xattrs(inode, ipage, index, len, name,\n\t\t\t\t&entry, &base_addr, &base_size);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\n\t\tif (base_size - (pval - (char *)base_addr) < size) {\n\t\t\terror = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\nout:\n\tkzfree(base_addr);\n\treturn error;\n}\n'''\nPlease use your own knowledge of vulnerabilities in combination with the above related code snippets to detect whether there is a vulnerability in the code snippet. Please answer YES or NO without explanation.\n",
                    "vul_output": "NO"
                }
            ],
            "detection_model": "claude-3-5-sonnet-20241022",
            "model_settings": {
                "temperature": 0.01
            },
            "final_result": 0
        }
    ]
}
{
    "vul_data": [
        {
            "id": 5,
            "cve_id": "CVE-2007-6761",
            "code_snippet": "static void\nvideobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}",
                        "code_after_change": "static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}",
                        "cve_id": "CVE-2007-6761"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 29,
            "cve_id": "CVE-2010-5332",
            "code_snippet": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
                        "code_after_change": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
                        "cve_id": "CVE-2010-5332"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 31,
            "cve_id": "CVE-2011-4098",
            "code_snippet": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tu64 start = offset >> PAGE_CACHE_SHIFT;\n\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;\n\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\tpgoff_t curr;\n\tstruct page *page;\n\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;\n\tunsigned int from, to;\n\n\tif (!end_offset)\n\t\tend_offset = PAGE_CACHE_SIZE;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\tcurr = start;\n\toffset = start << PAGE_CACHE_SHIFT;\n\tfrom = start_offset;\n\tto = PAGE_CACHE_SIZE;\n\twhile (curr <= end) {\n\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,\n\t\t\t\t\t\t   AOP_FLAG_NOFS);\n\t\tif (unlikely(!page)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (curr == end)\n\t\t\tto = end_offset;\n\t\terror = write_empty_blocks(page, from, to, mode);\n\t\tif (!error && offset + to > inode->i_size &&\n\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\t\ti_size_write(inode, offset + to);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tcurr++;\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tfrom = 0;\n\t}\n\n\tmark_inode_dirty(inode);\n\n\tbrelse(dibh);\n\nout:\n\treturn error;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static long gfs2_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t   loff_t len)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\n\tloff_t bytes, max_bytes;\n\tstruct gfs2_alloc *al;\n\tint error;\n\tloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\n\tloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\n\n\t/* We only support the FALLOC_FL_KEEP_SIZE mode */\n\tif (mode & ~FALLOC_FL_KEEP_SIZE)\n\t\treturn -EOPNOTSUPP;\n\n\toffset &= bsize_mask;\n\n\tlen = next - offset;\n\tbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;\n\tif (!bytes)\n\t\tbytes = UINT_MAX;\n\tbytes &= bsize_mask;\n\tif (bytes == 0)\n\t\tbytes = sdp->sd_sb.sb_bsize;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);\n\terror = gfs2_glock_nq(&ip->i_gh);\n\tif (unlikely(error))\n\t\tgoto out_uninit;\n\n\tif (!gfs2_write_alloc_required(ip, offset, len))\n\t\tgoto out_unlock;\n\n\twhile (len > 0) {\n\t\tif (len < bytes)\n\t\t\tbytes = len;\n\t\tal = gfs2_alloc_get(ip);\n\t\tif (!al) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\tgoto out_alloc_put;\n\nretry:\n\t\tgfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);\n\n\t\tal->al_requested = data_blocks + ind_blocks;\n\t\terror = gfs2_inplace_reserve(ip);\n\t\tif (error) {\n\t\t\tif (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {\n\t\t\t\tbytes >>= 1;\n\t\t\t\tbytes &= bsize_mask;\n\t\t\t\tif (bytes == 0)\n\t\t\t\t\tbytes = sdp->sd_sb.sb_bsize;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto out_qunlock;\n\t\t}\n\t\tmax_bytes = bytes;\n\t\tcalc_max_reserv(ip, len, &max_bytes, &data_blocks, &ind_blocks);\n\t\tal->al_requested = data_blocks + ind_blocks;\n\n\t\trblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +\n\t\t\t  RES_RG_HDR + gfs2_rg_blocks(ip);\n\t\tif (gfs2_is_jdata(ip))\n\t\t\trblocks += data_blocks ? data_blocks : 1;\n\n\t\terror = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t\t PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\terror = fallocate_chunk(inode, offset, max_bytes, mode);\n\t\tgfs2_trans_end(sdp);\n\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\tlen -= max_bytes;\n\t\toffset += max_bytes;\n\t\tgfs2_inplace_release(ip);\n\t\tgfs2_quota_unlock(ip);\n\t\tgfs2_alloc_put(ip);\n\t}\n\tgoto out_unlock;\n\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_qunlock:\n\tgfs2_quota_unlock(ip);\nout_alloc_put:\n\tgfs2_alloc_put(ip);\nout_unlock:\n\tgfs2_glock_dq(&ip->i_gh);\nout_uninit:\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn error;\n}",
                        "code_after_change": "static long gfs2_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t   loff_t len)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\n\tloff_t bytes, max_bytes;\n\tstruct gfs2_alloc *al;\n\tint error;\n\tloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\n\tloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\n\tloff_t max_chunk_size = UINT_MAX & bsize_mask;\n\tnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\n\n\t/* We only support the FALLOC_FL_KEEP_SIZE mode */\n\tif (mode & ~FALLOC_FL_KEEP_SIZE)\n\t\treturn -EOPNOTSUPP;\n\n\toffset &= bsize_mask;\n\n\tlen = next - offset;\n\tbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;\n\tif (!bytes)\n\t\tbytes = UINT_MAX;\n\tbytes &= bsize_mask;\n\tif (bytes == 0)\n\t\tbytes = sdp->sd_sb.sb_bsize;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);\n\terror = gfs2_glock_nq(&ip->i_gh);\n\tif (unlikely(error))\n\t\tgoto out_uninit;\n\n\tif (!gfs2_write_alloc_required(ip, offset, len))\n\t\tgoto out_unlock;\n\n\twhile (len > 0) {\n\t\tif (len < bytes)\n\t\t\tbytes = len;\n\t\tal = gfs2_alloc_get(ip);\n\t\tif (!al) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\tgoto out_alloc_put;\n\nretry:\n\t\tgfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);\n\n\t\tal->al_requested = data_blocks + ind_blocks;\n\t\terror = gfs2_inplace_reserve(ip);\n\t\tif (error) {\n\t\t\tif (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {\n\t\t\t\tbytes >>= 1;\n\t\t\t\tbytes &= bsize_mask;\n\t\t\t\tif (bytes == 0)\n\t\t\t\t\tbytes = sdp->sd_sb.sb_bsize;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto out_qunlock;\n\t\t}\n\t\tmax_bytes = bytes;\n\t\tcalc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,\n\t\t\t\t&max_bytes, &data_blocks, &ind_blocks);\n\t\tal->al_requested = data_blocks + ind_blocks;\n\n\t\trblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +\n\t\t\t  RES_RG_HDR + gfs2_rg_blocks(ip);\n\t\tif (gfs2_is_jdata(ip))\n\t\t\trblocks += data_blocks ? data_blocks : 1;\n\n\t\terror = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t\t PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\terror = fallocate_chunk(inode, offset, max_bytes, mode);\n\t\tgfs2_trans_end(sdp);\n\n\t\tif (error)\n\t\t\tgoto out_trans_fail;\n\n\t\tlen -= max_bytes;\n\t\toffset += max_bytes;\n\t\tgfs2_inplace_release(ip);\n\t\tgfs2_quota_unlock(ip);\n\t\tgfs2_alloc_put(ip);\n\t}\n\tgoto out_unlock;\n\nout_trans_fail:\n\tgfs2_inplace_release(ip);\nout_qunlock:\n\tgfs2_quota_unlock(ip);\nout_alloc_put:\n\tgfs2_alloc_put(ip);\nout_unlock:\n\tgfs2_glock_dq(&ip->i_gh);\nout_uninit:\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn error;\n}",
                        "cve_id": "CVE-2011-4098"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 55,
            "cve_id": "CVE-2012-3364",
            "code_snippet": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\n\treturn data;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = *data++;\n\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\n\treturn data;\n}",
                        "code_after_change": "static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n\tdata += 2;\n\n\tnfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);\n\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\n\tnfca_poll->sel_res_len = *data++;\n\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\n\treturn data;\n}",
                        "cve_id": "CVE-2012-3364"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 148,
            "cve_id": "CVE-2012-6712",
            "code_snippet": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tiwl_sta_ucode_activate(priv, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\n\t/*\n\t * XXX: The MAC address in the command buffer is often changed from\n\t * the original sent to the device. That is, the MAC address\n\t * written to the command buffer often is not the same MAC address\n\t * read from the command buffer when the command returns. This\n\t * issue has not yet been resolved and this debugging is left to\n\t * observe the problem.\n\t */\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn ret;\n}",
                        "code_after_change": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tret = iwl_sta_ucode_activate(priv, sta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\n\t/*\n\t * XXX: The MAC address in the command buffer is often changed from\n\t * the original sent to the device. That is, the MAC address\n\t * written to the command buffer often is not the same MAC address\n\t * read from the command buffer when the command returns. This\n\t * issue has not yet been resolved and this debugging is left to\n\t * observe the problem.\n\t */\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn ret;\n}",
                        "cve_id": "CVE-2012-6712"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 156,
            "cve_id": "CVE-2013-0231",
            "code_snippet": "int xen_pcibk_enable_msix(struct xen_pcibk_device *pdev,\n\t\t\t  struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint i, result;\n\tstruct msix_entry *entries;\n\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable MSI-X\\n\",\n\t\t       pci_name(dev));\n\tif (op->value > SH_INFO_MAX_VEC)\n\t\treturn -EINVAL;\n\n\tentries = kmalloc(op->value * sizeof(*entries), GFP_KERNEL);\n\tif (entries == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < op->value; i++) {\n\t\tentries[i].entry = op->msix_entries[i].entry;\n\t\tentries[i].vector = op->msix_entries[i].vector;\n\t}\n\n\tresult = pci_enable_msix(dev, entries, op->value);\n\n\tif (result == 0) {\n\t\tfor (i = 0; i < op->value; i++) {\n\t\t\top->msix_entries[i].entry = entries[i].entry;\n\t\t\tif (entries[i].vector)\n\t\t\t\top->msix_entries[i].vector =\n\t\t\t\t\txen_pirq_from_irq(entries[i].vector);\n\t\t\t\tif (unlikely(verbose_request))\n\t\t\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: \" \\\n\t\t\t\t\t\t\"MSI-X[%d]: %d\\n\",\n\t\t\t\t\t\tpci_name(dev), i,\n\t\t\t\t\t\top->msix_entries[i].vector);\n\t\t}\n\t} else {\n\t\tprintk(KERN_WARNING DRV_NAME \": %s: failed to enable MSI-X: err %d!\\n\",\n\t\t\tpci_name(dev), result);\n\t}\n\tkfree(entries);\n\n\top->value = result;\n\tdev_data = pci_get_drvdata(dev);\n\tif (dev_data)\n\t\tdev_data->ack_intr = 0;\n\n\treturn result > 0 ? 0 : result;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int xen_pcibk_enable_msi(struct xen_pcibk_device *pdev,\n\t\t\t struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint otherend = pdev->xdev->otherend_id;\n\tint status;\n\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable MSI\\n\", pci_name(dev));\n\n\tstatus = pci_enable_msi(dev);\n\n\tif (status) {\n\t\tprintk(KERN_ERR \"error enable msi for guest %x status %x\\n\",\n\t\t\totherend, status);\n\t\top->value = 0;\n\t\treturn XEN_PCI_ERR_op_failed;\n\t}\n\n\t/* The value the guest needs is actually the IDT vector, not the\n\t * the local domain's IRQ number. */\n\n\top->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: MSI: %d\\n\", pci_name(dev),\n\t\t\top->value);\n\n\tdev_data = pci_get_drvdata(dev);\n\tif (dev_data)\n\t\tdev_data->ack_intr = 0;\n\n\treturn 0;\n}",
                        "code_after_change": "int xen_pcibk_enable_msi(struct xen_pcibk_device *pdev,\n\t\t\t struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint status;\n\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable MSI\\n\", pci_name(dev));\n\n\tstatus = pci_enable_msi(dev);\n\n\tif (status) {\n\t\tpr_warn_ratelimited(DRV_NAME \": %s: error enabling MSI for guest %u: err %d\\n\",\n\t\t\t\t    pci_name(dev), pdev->xdev->otherend_id,\n\t\t\t\t    status);\n\t\top->value = 0;\n\t\treturn XEN_PCI_ERR_op_failed;\n\t}\n\n\t/* The value the guest needs is actually the IDT vector, not the\n\t * the local domain's IRQ number. */\n\n\top->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: MSI: %d\\n\", pci_name(dev),\n\t\t\top->value);\n\n\tdev_data = pci_get_drvdata(dev);\n\tif (dev_data)\n\t\tdev_data->ack_intr = 0;\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2013-0231"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 160,
            "cve_id": "CVE-2013-0309",
            "code_snippet": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}",
                        "code_after_change": "static inline int pmd_present(pmd_t pmd)\n{\n\t/*\n\t * Checking for _PAGE_PSE is needed too because\n\t * split_huge_page will temporarily clear the present bit (but\n\t * the _PAGE_PSE flag will remain set at all times while the\n\t * _PAGE_PRESENT bit is clear).\n\t */\n\treturn pmd_flags(pmd) & (_PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE);\n}",
                        "cve_id": "CVE-2013-0309"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 175,
            "cve_id": "CVE-2013-1772",
            "code_snippet": "void console_unlock(void)\n{\n\tunsigned long flags;\n\tunsigned _con_start, _log_end;\n\tunsigned wake_klogd = 0, retry = 0;\n\n\tif (console_suspended) {\n\t\tup(&console_sem);\n\t\treturn;\n\t}\n\n\tconsole_may_schedule = 0;\n\nagain:\n\tfor ( ; ; ) {\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\twake_klogd |= log_start - log_end;\n\t\tif (con_start == log_end)\n\t\t\tbreak;\t\t\t/* Nothing to print */\n\t\t_con_start = con_start;\n\t\t_log_end = log_end;\n\t\tcon_start = log_end;\t\t/* Flush */\n\t\traw_spin_unlock(&logbuf_lock);\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(_con_start, _log_end);\n\t\tstart_critical_timings();\n\t\tlocal_irq_restore(flags);\n\t}\n\tconsole_locked = 0;\n\n\t/* Release the exclusive_console once it is used */\n\tif (unlikely(exclusive_console))\n\t\texclusive_console = NULL;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup(&console_sem);\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tif (con_start != log_end)\n\t\tretry = 1;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n\n\tif (wake_klogd)\n\t\twake_up_klogd();\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void register_console(struct console *newcon)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct console *bcon = NULL;\n\n\t/*\n\t * before we register a new CON_BOOT console, make sure we don't\n\t * already have a valid console\n\t */\n\tif (console_drivers && newcon->flags & CON_BOOT) {\n\t\t/* find the last or real console */\n\t\tfor_each_console(bcon) {\n\t\t\tif (!(bcon->flags & CON_BOOT)) {\n\t\t\t\tprintk(KERN_INFO \"Too late to register bootconsole %s%d\\n\",\n\t\t\t\t\tnewcon->name, newcon->index);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (console_drivers && console_drivers->flags & CON_BOOT)\n\t\tbcon = console_drivers;\n\n\tif (preferred_console < 0 || bcon || !console_drivers)\n\t\tpreferred_console = selected_console;\n\n\tif (newcon->early_setup)\n\t\tnewcon->early_setup();\n\n\t/*\n\t *\tSee if we want to use this console driver. If we\n\t *\tdidn't select a console we take the first one\n\t *\tthat registers here.\n\t */\n\tif (preferred_console < 0) {\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = 0;\n\t\tif (newcon->setup == NULL ||\n\t\t    newcon->setup(newcon, NULL) == 0) {\n\t\t\tnewcon->flags |= CON_ENABLED;\n\t\t\tif (newcon->device) {\n\t\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\t\tpreferred_console = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tSee if this console matches one we selected on\n\t *\tthe command line.\n\t */\n\tfor (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0];\n\t\t\ti++) {\n\t\tif (strcmp(console_cmdline[i].name, newcon->name) != 0)\n\t\t\tcontinue;\n\t\tif (newcon->index >= 0 &&\n\t\t    newcon->index != console_cmdline[i].index)\n\t\t\tcontinue;\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = console_cmdline[i].index;\n#ifdef CONFIG_A11Y_BRAILLE_CONSOLE\n\t\tif (console_cmdline[i].brl_options) {\n\t\t\tnewcon->flags |= CON_BRL;\n\t\t\tbraille_register_console(newcon,\n\t\t\t\t\tconsole_cmdline[i].index,\n\t\t\t\t\tconsole_cmdline[i].options,\n\t\t\t\t\tconsole_cmdline[i].brl_options);\n\t\t\treturn;\n\t\t}\n#endif\n\t\tif (newcon->setup &&\n\t\t    newcon->setup(newcon, console_cmdline[i].options) != 0)\n\t\t\tbreak;\n\t\tnewcon->flags |= CON_ENABLED;\n\t\tnewcon->index = console_cmdline[i].index;\n\t\tif (i == selected_console) {\n\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\tpreferred_console = selected_console;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(newcon->flags & CON_ENABLED))\n\t\treturn;\n\n\t/*\n\t * If we have a bootconsole, and are switching to a real console,\n\t * don't print everything out again, since when the boot console, and\n\t * the real console are the same physical device, it's annoying to\n\t * see the beginning boot messages twice\n\t */\n\tif (bcon && ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))\n\t\tnewcon->flags &= ~CON_PRINTBUFFER;\n\n\t/*\n\t *\tPut this console in the list - keep the\n\t *\tpreferred driver at the head of the list.\n\t */\n\tconsole_lock();\n\tif ((newcon->flags & CON_CONSDEV) || console_drivers == NULL) {\n\t\tnewcon->next = console_drivers;\n\t\tconsole_drivers = newcon;\n\t\tif (newcon->next)\n\t\t\tnewcon->next->flags &= ~CON_CONSDEV;\n\t} else {\n\t\tnewcon->next = console_drivers->next;\n\t\tconsole_drivers->next = newcon;\n\t}\n\tif (newcon->flags & CON_PRINTBUFFER) {\n\t\t/*\n\t\t * console_unlock(); will print out the buffered messages\n\t\t * for us.\n\t\t */\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tcon_start = log_start;\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\t\t/*\n\t\t * We're about to replay the log buffer.  Only do this to the\n\t\t * just-registered console to avoid excessive message spam to\n\t\t * the already-registered consoles.\n\t\t */\n\t\texclusive_console = newcon;\n\t}\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\t/*\n\t * By unregistering the bootconsoles after we enable the real console\n\t * we get the \"console xxx enabled\" message on all the consoles -\n\t * boot consoles, real consoles, etc - this is to ensure that end\n\t * users know there might be something in the kernel's log buffer that\n\t * went to the bootconsole (that they do not see on the real console)\n\t */\n\tif (bcon &&\n\t    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &&\n\t    !keep_bootcon) {\n\t\t/* we need to iterate through twice, to make sure we print\n\t\t * everything out, before we unregister the console(s)\n\t\t */\n\t\tprintk(KERN_INFO \"console [%s%d] enabled, bootconsole disabled\\n\",\n\t\t\tnewcon->name, newcon->index);\n\t\tfor_each_console(bcon)\n\t\t\tif (bcon->flags & CON_BOOT)\n\t\t\t\tunregister_console(bcon);\n\t} else {\n\t\tprintk(KERN_INFO \"%sconsole [%s%d] enabled\\n\",\n\t\t\t(newcon->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\t\tnewcon->name, newcon->index);\n\t}\n}",
                        "code_after_change": "void register_console(struct console *newcon)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct console *bcon = NULL;\n\n\t/*\n\t * before we register a new CON_BOOT console, make sure we don't\n\t * already have a valid console\n\t */\n\tif (console_drivers && newcon->flags & CON_BOOT) {\n\t\t/* find the last or real console */\n\t\tfor_each_console(bcon) {\n\t\t\tif (!(bcon->flags & CON_BOOT)) {\n\t\t\t\tprintk(KERN_INFO \"Too late to register bootconsole %s%d\\n\",\n\t\t\t\t\tnewcon->name, newcon->index);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (console_drivers && console_drivers->flags & CON_BOOT)\n\t\tbcon = console_drivers;\n\n\tif (preferred_console < 0 || bcon || !console_drivers)\n\t\tpreferred_console = selected_console;\n\n\tif (newcon->early_setup)\n\t\tnewcon->early_setup();\n\n\t/*\n\t *\tSee if we want to use this console driver. If we\n\t *\tdidn't select a console we take the first one\n\t *\tthat registers here.\n\t */\n\tif (preferred_console < 0) {\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = 0;\n\t\tif (newcon->setup == NULL ||\n\t\t    newcon->setup(newcon, NULL) == 0) {\n\t\t\tnewcon->flags |= CON_ENABLED;\n\t\t\tif (newcon->device) {\n\t\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\t\tpreferred_console = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tSee if this console matches one we selected on\n\t *\tthe command line.\n\t */\n\tfor (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0];\n\t\t\ti++) {\n\t\tif (strcmp(console_cmdline[i].name, newcon->name) != 0)\n\t\t\tcontinue;\n\t\tif (newcon->index >= 0 &&\n\t\t    newcon->index != console_cmdline[i].index)\n\t\t\tcontinue;\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = console_cmdline[i].index;\n#ifdef CONFIG_A11Y_BRAILLE_CONSOLE\n\t\tif (console_cmdline[i].brl_options) {\n\t\t\tnewcon->flags |= CON_BRL;\n\t\t\tbraille_register_console(newcon,\n\t\t\t\t\tconsole_cmdline[i].index,\n\t\t\t\t\tconsole_cmdline[i].options,\n\t\t\t\t\tconsole_cmdline[i].brl_options);\n\t\t\treturn;\n\t\t}\n#endif\n\t\tif (newcon->setup &&\n\t\t    newcon->setup(newcon, console_cmdline[i].options) != 0)\n\t\t\tbreak;\n\t\tnewcon->flags |= CON_ENABLED;\n\t\tnewcon->index = console_cmdline[i].index;\n\t\tif (i == selected_console) {\n\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\tpreferred_console = selected_console;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(newcon->flags & CON_ENABLED))\n\t\treturn;\n\n\t/*\n\t * If we have a bootconsole, and are switching to a real console,\n\t * don't print everything out again, since when the boot console, and\n\t * the real console are the same physical device, it's annoying to\n\t * see the beginning boot messages twice\n\t */\n\tif (bcon && ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))\n\t\tnewcon->flags &= ~CON_PRINTBUFFER;\n\n\t/*\n\t *\tPut this console in the list - keep the\n\t *\tpreferred driver at the head of the list.\n\t */\n\tconsole_lock();\n\tif ((newcon->flags & CON_CONSDEV) || console_drivers == NULL) {\n\t\tnewcon->next = console_drivers;\n\t\tconsole_drivers = newcon;\n\t\tif (newcon->next)\n\t\t\tnewcon->next->flags &= ~CON_CONSDEV;\n\t} else {\n\t\tnewcon->next = console_drivers->next;\n\t\tconsole_drivers->next = newcon;\n\t}\n\tif (newcon->flags & CON_PRINTBUFFER) {\n\t\t/*\n\t\t * console_unlock(); will print out the buffered messages\n\t\t * for us.\n\t\t */\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tconsole_seq = syslog_seq;\n\t\tconsole_idx = syslog_idx;\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\t\t/*\n\t\t * We're about to replay the log buffer.  Only do this to the\n\t\t * just-registered console to avoid excessive message spam to\n\t\t * the already-registered consoles.\n\t\t */\n\t\texclusive_console = newcon;\n\t}\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\t/*\n\t * By unregistering the bootconsoles after we enable the real console\n\t * we get the \"console xxx enabled\" message on all the consoles -\n\t * boot consoles, real consoles, etc - this is to ensure that end\n\t * users know there might be something in the kernel's log buffer that\n\t * went to the bootconsole (that they do not see on the real console)\n\t */\n\tif (bcon &&\n\t    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &&\n\t    !keep_bootcon) {\n\t\t/* we need to iterate through twice, to make sure we print\n\t\t * everything out, before we unregister the console(s)\n\t\t */\n\t\tprintk(KERN_INFO \"console [%s%d] enabled, bootconsole disabled\\n\",\n\t\t\tnewcon->name, newcon->index);\n\t\tfor_each_console(bcon)\n\t\t\tif (bcon->flags & CON_BOOT)\n\t\t\t\tunregister_console(bcon);\n\t} else {\n\t\tprintk(KERN_INFO \"%sconsole [%s%d] enabled\\n\",\n\t\t\t(newcon->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\t\tnewcon->name, newcon->index);\n\t}\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 176,
            "cve_id": "CVE-2013-1772",
            "code_snippet": "void __init setup_log_buf(int early)\n{\n\tunsigned long flags;\n\tunsigned start, dest_idx, offset;\n\tchar *new_log_buf;\n\tint free;\n\n\tif (!new_log_buf_len)\n\t\treturn;\n\n\tif (early) {\n\t\tunsigned long mem;\n\n\t\tmem = memblock_alloc(new_log_buf_len, PAGE_SIZE);\n\t\tif (!mem)\n\t\t\treturn;\n\t\tnew_log_buf = __va(mem);\n\t} else {\n\t\tnew_log_buf = alloc_bootmem_nopanic(new_log_buf_len);\n\t}\n\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"log_buf_len: %ld bytes not available\\n\",\n\t\t\tnew_log_buf_len);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\tfree = __LOG_BUF_LEN - log_end;\n\n\toffset = start = min(con_start, log_start);\n\tdest_idx = 0;\n\twhile (start != log_end) {\n\t\tunsigned log_idx_mask = start & (__LOG_BUF_LEN - 1);\n\n\t\tlog_buf[dest_idx] = __log_buf[log_idx_mask];\n\t\tstart++;\n\t\tdest_idx++;\n\t}\n\tlog_start -= offset;\n\tcon_start -= offset;\n\tlog_end -= offset;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tpr_info(\"log_buf_len: %d\\n\", log_buf_len);\n\tpr_info(\"early log buf free: %d(%d%%)\\n\",\n\t\tfree, (free * 100) / __LOG_BUF_LEN);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tunsigned long end;\n\tunsigned chars;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tend = log_end & LOG_BUF_MASK;\n\tchars = logged_chars;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (chars > end) {\n\t\ts1 = log_buf + log_buf_len - chars + end;\n\t\tl1 = chars - end;\n\n\t\ts2 = log_buf;\n\t\tl2 = end;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + end - chars;\n\t\tl2 = chars;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "code_after_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tu64 idx;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tif (syslog_seq < log_first_seq)\n\t\tidx = syslog_idx;\n\telse\n\t\tidx = log_first_idx;\n\n\tif (idx > log_next_idx) {\n\t\ts1 = log_buf;\n\t\tl1 = log_next_idx;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_buf_len - idx;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_next_idx - idx;\n\t}\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 177,
            "cve_id": "CVE-2013-1772",
            "code_snippet": "void kdb_syslog_data(char *syslog_data[4])\n{\n\tsyslog_data[0] = log_buf;\n\tsyslog_data[1] = log_buf + log_buf_len;\n\tsyslog_data[2] = log_buf + log_end -\n\t\t(logged_chars < log_buf_len ? logged_chars : log_buf_len);\n\tsyslog_data[3] = log_buf + log_end;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tunsigned long end;\n\tunsigned chars;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tend = log_end & LOG_BUF_MASK;\n\tchars = logged_chars;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (chars > end) {\n\t\ts1 = log_buf + log_buf_len - chars + end;\n\t\tl1 = chars - end;\n\n\t\ts2 = log_buf;\n\t\tl2 = end;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + end - chars;\n\t\tl2 = chars;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "code_after_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tu64 idx;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tif (syslog_seq < log_first_seq)\n\t\tidx = syslog_idx;\n\telse\n\t\tidx = log_first_idx;\n\n\tif (idx > log_next_idx) {\n\t\ts1 = log_buf;\n\t\tl1 = log_next_idx;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_buf_len - idx;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_next_idx - idx;\n\t}\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 178,
            "cve_id": "CVE-2013-1772",
            "code_snippet": "void log_buf_kexec_setup(void)\n{\n\tVMCOREINFO_SYMBOL(log_buf);\n\tVMCOREINFO_SYMBOL(log_end);\n\tVMCOREINFO_SYMBOL(log_buf_len);\n\tVMCOREINFO_SYMBOL(logged_chars);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tunsigned long end;\n\tunsigned chars;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tend = log_end & LOG_BUF_MASK;\n\tchars = logged_chars;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (chars > end) {\n\t\ts1 = log_buf + log_buf_len - chars + end;\n\t\tl1 = chars - end;\n\n\t\ts2 = log_buf;\n\t\tl2 = end;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + end - chars;\n\t\tl2 = chars;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "code_after_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tu64 idx;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tif (syslog_seq < log_first_seq)\n\t\tidx = syslog_idx;\n\telse\n\t\tidx = log_first_idx;\n\n\tif (idx > log_next_idx) {\n\t\ts1 = log_buf;\n\t\tl1 = log_next_idx;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_buf_len - idx;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_next_idx - idx;\n\t}\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int do_syslog(int type, char __user *buf, int len, bool from_file)\n{\n\tunsigned i, j, limit, count;\n\tint do_clear = 0;\n\tchar c;\n\tint error;\n\n\terror = check_syslog_permissions(type, from_file);\n\tif (error)\n\t\tgoto out;\n\n\terror = security_syslog(type);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase SYSLOG_ACTION_CLOSE:\t/* Close log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_OPEN:\t/* Open log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_READ:\t/* Read from log */\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terror = wait_event_interruptible(log_wait,\n\t\t\t\t\t\t\t(log_start - log_end));\n\t\tif (error)\n\t\t\tgoto out;\n\t\ti = 0;\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\twhile (!error && (log_start != log_end) && i < len) {\n\t\t\tc = LOG_BUF(log_start);\n\t\t\tlog_start++;\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\terror = __put_user(c,buf);\n\t\t\tbuf++;\n\t\t\ti++;\n\t\t\tcond_resched();\n\t\t\traw_spin_lock_irq(&logbuf_lock);\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tif (!error)\n\t\t\terror = i;\n\t\tbreak;\n\t/* Read/clear last kernel messages */\n\tcase SYSLOG_ACTION_READ_CLEAR:\n\t\tdo_clear = 1;\n\t\t/* FALL THRU */\n\t/* Read last kernel messages */\n\tcase SYSLOG_ACTION_READ_ALL:\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tcount = len;\n\t\tif (count > log_buf_len)\n\t\t\tcount = log_buf_len;\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\tif (count > logged_chars)\n\t\t\tcount = logged_chars;\n\t\tif (do_clear)\n\t\t\tlogged_chars = 0;\n\t\tlimit = log_end;\n\t\t/*\n\t\t * __put_user() could sleep, and while we sleep\n\t\t * printk() could overwrite the messages\n\t\t * we try to copy to user space. Therefore\n\t\t * the messages are copied in reverse. <manfreds>\n\t\t */\n\t\tfor (i = 0; i < count && !error; i++) {\n\t\t\tj = limit-1-i;\n\t\t\tif (j + log_buf_len < log_end)\n\t\t\t\tbreak;\n\t\t\tc = LOG_BUF(j);\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\terror = __put_user(c,&buf[count-1-i]);\n\t\t\tcond_resched();\n\t\t\traw_spin_lock_irq(&logbuf_lock);\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = i;\n\t\tif (i != count) {\n\t\t\tint offset = count-error;\n\t\t\t/* buffer overflow during copy, correct user buffer. */\n\t\t\tfor (i = 0; i < error; i++) {\n\t\t\t\tif (__get_user(c,&buf[i+offset]) ||\n\t\t\t\t    __put_user(c,&buf[i])) {\n\t\t\t\t\terror = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t/* Clear ring buffer */\n\tcase SYSLOG_ACTION_CLEAR:\n\t\tlogged_chars = 0;\n\t\tbreak;\n\t/* Disable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_OFF:\n\t\tif (saved_console_loglevel == -1)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t/* Enable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_ON:\n\t\tif (saved_console_loglevel != -1) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = -1;\n\t\t}\n\t\tbreak;\n\t/* Set level of messages printed to console */\n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\terror = -EINVAL;\n\t\tif (len < 1 || len > 8)\n\t\t\tgoto out;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t/* Implicitly re-enable logging to console */\n\t\tsaved_console_loglevel = -1;\n\t\terror = 0;\n\t\tbreak;\n\t/* Number of chars in the log buffer */\n\tcase SYSLOG_ACTION_SIZE_UNREAD:\n\t\terror = log_end - log_start;\n\t\tbreak;\n\t/* Size of the log buffer */\n\tcase SYSLOG_ACTION_SIZE_BUFFER:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\treturn error;\n}",
                        "code_after_change": "int do_syslog(int type, char __user *buf, int len, bool from_file)\n{\n\tbool clear = false;\n\tstatic int saved_console_loglevel = -1;\n\tint error;\n\n\terror = check_syslog_permissions(type, from_file);\n\tif (error)\n\t\tgoto out;\n\n\terror = security_syslog(type);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase SYSLOG_ACTION_CLOSE:\t/* Close log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_OPEN:\t/* Open log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_READ:\t/* Read from log */\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terror = wait_event_interruptible(log_wait,\n\t\t\t\t\t\t syslog_seq != log_next_seq);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = syslog_print(buf, len);\n\t\tbreak;\n\t/* Read/clear last kernel messages */\n\tcase SYSLOG_ACTION_READ_CLEAR:\n\t\tclear = true;\n\t\t/* FALL THRU */\n\t/* Read last kernel messages */\n\tcase SYSLOG_ACTION_READ_ALL:\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terror = syslog_print_all(buf, len, clear);\n\t\tbreak;\n\t/* Clear ring buffer */\n\tcase SYSLOG_ACTION_CLEAR:\n\t\tsyslog_print_all(NULL, 0, true);\n\t/* Disable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_OFF:\n\t\tif (saved_console_loglevel == -1)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t/* Enable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_ON:\n\t\tif (saved_console_loglevel != -1) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = -1;\n\t\t}\n\t\tbreak;\n\t/* Set level of messages printed to console */\n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\terror = -EINVAL;\n\t\tif (len < 1 || len > 8)\n\t\t\tgoto out;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t/* Implicitly re-enable logging to console */\n\t\tsaved_console_loglevel = -1;\n\t\terror = 0;\n\t\tbreak;\n\t/* Number of chars in the log buffer */\n\tcase SYSLOG_ACTION_SIZE_UNREAD:\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t}\n\t\tif (from_file) {\n\t\t\t/*\n\t\t\t * Short-cut for poll(/\"proc/kmsg\") which simply checks\n\t\t\t * for pending data, not the size; return the count of\n\t\t\t * records, not the length.\n\t\t\t */\n\t\t\terror = log_next_idx - syslog_idx;\n\t\t} else {\n\t\t\tu64 seq;\n\t\t\tu32 idx;\n\n\t\t\terror = 0;\n\t\t\tseq = syslog_seq;\n\t\t\tidx = syslog_idx;\n\t\t\twhile (seq < log_next_seq) {\n\t\t\t\terror += syslog_print_line(idx, NULL, 0);\n\t\t\t\tidx = log_next(idx);\n\t\t\t\tseq++;\n\t\t\t}\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tbreak;\n\t/* Size of the log buffer */\n\tcase SYSLOG_ACTION_SIZE_BUFFER:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\treturn error;\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
                        "code_after_change": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *preply = &reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
                        "cve_id": "CVE-2014-6416"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tif (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\tsize_t size;\n\t\t\tint max = vfio_pci_get_irq_count(vdev, hdr.index);\n\n\t\t\tif (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)\n\t\t\t\tsize = sizeof(uint8_t);\n\t\t\telse if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)\n\t\t\t\tsize = sizeof(int32_t);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (hdr.argsz - minsz < hdr.count * size ||\n\t\t\t    hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
                        "code_after_change": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\tvoid *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t      indx, 0, buf, size, 500);\n\tif (ret > 0 && ret <= size)\n\t\tmemcpy(data, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}",
                        "cve_id": "CVE-2016-9083"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int uac_mixer_unit_get_channels(struct mixer_build *state,\n\t\t\t\t       struct uac_mixer_unit_descriptor *desc)\n{\n\tint mu_channels;\n\tvoid *c;\n\n\tif (desc->bLength < sizeof(*desc))\n\t\treturn -EINVAL;\n\tif (!desc->bNrInPins)\n\t\treturn -EINVAL;\n\n\tswitch (state->mixer->protocol) {\n\tcase UAC_VERSION_1:\n\tcase UAC_VERSION_2:\n\tdefault:\n\t\tif (desc->bLength < sizeof(*desc) + desc->bNrInPins + 1)\n\t\t\treturn 0; /* no bmControls -> skip */\n\t\tmu_channels = uac_mixer_unit_bNrChannels(desc);\n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tmu_channels = get_cluster_channels_v3(state,\n\t\t\t\tuac3_mixer_unit_wClusterDescrID(desc));\n\t\tbreak;\n\t}\n\n\tif (!mu_channels)\n\t\treturn 0;\n\n\tc = uac_mixer_unit_bmControls(desc, state->mixer->protocol);\n\tif (c - (void *)desc + (mu_channels - 1) / 8 >= desc->bLength)\n\t\treturn 0; /* no bmControls -> skip */\n\n\treturn mu_channels;\n}",
                        "code_after_change": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n\t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
                        "cve_id": "CVE-2019-15117"
                    },
                    "vul_output": "NO"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 0
        },
        {
            "id": 179,
            "cve_id": "CVE-2013-1772",
            "code_snippet": "asmlinkage int vprintk(const char *fmt, va_list args)\n{\n\tint printed_len = 0;\n\tint current_log_level = default_message_loglevel;\n\tunsigned long flags;\n\tint this_cpu;\n\tchar *p;\n\tsize_t plen;\n\tchar special;\n\n\tboot_delay_msec();\n\tprintk_delay();\n\n\t/* This stops the holder of console_sem just where we want him */\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\n\t/*\n\t * Ouch, printk recursed into itself!\n\t */\n\tif (unlikely(printk_cpu == this_cpu)) {\n\t\t/*\n\t\t * If a crash is occurring during printk() on this CPU,\n\t\t * then try to get the crash message out but make sure\n\t\t * we can't deadlock. Otherwise just return to avoid the\n\t\t * recursion and return - but flag the recursion so that\n\t\t * it can be printed at the next appropriate moment:\n\t\t */\n\t\tif (!oops_in_progress && !lockdep_recursing(current)) {\n\t\t\trecursion_bug = 1;\n\t\t\tgoto out_restore_irqs;\n\t\t}\n\t\tzap_locks();\n\t}\n\n\tlockdep_off();\n\traw_spin_lock(&logbuf_lock);\n\tprintk_cpu = this_cpu;\n\n\tif (recursion_bug) {\n\t\trecursion_bug = 0;\n\t\tstrcpy(printk_buf, recursion_bug_msg);\n\t\tprinted_len = strlen(recursion_bug_msg);\n\t}\n\t/* Emit the output into the temporary buffer */\n\tprinted_len += vscnprintf(printk_buf + printed_len,\n\t\t\t\t  sizeof(printk_buf) - printed_len, fmt, args);\n\n\tp = printk_buf;\n\n\t/* Read log level and handle special printk prefix */\n\tplen = log_prefix(p, &current_log_level, &special);\n\tif (plen) {\n\t\tp += plen;\n\n\t\tswitch (special) {\n\t\tcase 'c': /* Strip <c> KERN_CONT, continue line */\n\t\t\tplen = 0;\n\t\t\tbreak;\n\t\tcase 'd': /* Strip <d> KERN_DEFAULT, start new line */\n\t\t\tplen = 0;\n\t\tdefault:\n\t\t\tif (!new_text_line) {\n\t\t\t\temit_log_char('\\n');\n\t\t\t\tnew_text_line = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Copy the output into log_buf. If the caller didn't provide\n\t * the appropriate log prefix, we insert them here\n\t */\n\tfor (; *p; p++) {\n\t\tif (new_text_line) {\n\t\t\tnew_text_line = 0;\n\n\t\t\tif (plen) {\n\t\t\t\t/* Copy original log prefix */\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < plen; i++)\n\t\t\t\t\temit_log_char(printk_buf[i]);\n\t\t\t\tprinted_len += plen;\n\t\t\t} else {\n\t\t\t\t/* Add log prefix */\n\t\t\t\temit_log_char('<');\n\t\t\t\temit_log_char(current_log_level + '0');\n\t\t\t\temit_log_char('>');\n\t\t\t\tprinted_len += 3;\n\t\t\t}\n\n\t\t\tif (printk_time) {\n\t\t\t\t/* Add the current time stamp */\n\t\t\t\tchar tbuf[50], *tp;\n\t\t\t\tunsigned tlen;\n\t\t\t\tunsigned long long t;\n\t\t\t\tunsigned long nanosec_rem;\n\n\t\t\t\tt = cpu_clock(printk_cpu);\n\t\t\t\tnanosec_rem = do_div(t, 1000000000);\n\t\t\t\ttlen = sprintf(tbuf, \"[%5lu.%06lu] \",\n\t\t\t\t\t\t(unsigned long) t,\n\t\t\t\t\t\tnanosec_rem / 1000);\n\n\t\t\t\tfor (tp = tbuf; tp < tbuf + tlen; tp++)\n\t\t\t\t\temit_log_char(*tp);\n\t\t\t\tprinted_len += tlen;\n\t\t\t}\n\n\t\t\tif (!*p)\n\t\t\t\tbreak;\n\t\t}\n\n\t\temit_log_char(*p);\n\t\tif (*p == '\\n')\n\t\t\tnew_text_line = 1;\n\t}\n\n\t/*\n\t * Try to acquire and then immediately release the\n\t * console semaphore. The release will do all the\n\t * actual magic (print out buffers, wake up klogd,\n\t * etc).\n\t *\n\t * The console_trylock_for_printk() function\n\t * will release 'logbuf_lock' regardless of whether it\n\t * actually gets the semaphore or not.\n\t */\n\tif (console_trylock_for_printk(this_cpu))\n\t\tconsole_unlock();\n\n\tlockdep_on();\nout_restore_irqs:\n\tlocal_irq_restore(flags);\n\n\treturn printed_len;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void register_console(struct console *newcon)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct console *bcon = NULL;\n\n\t/*\n\t * before we register a new CON_BOOT console, make sure we don't\n\t * already have a valid console\n\t */\n\tif (console_drivers && newcon->flags & CON_BOOT) {\n\t\t/* find the last or real console */\n\t\tfor_each_console(bcon) {\n\t\t\tif (!(bcon->flags & CON_BOOT)) {\n\t\t\t\tprintk(KERN_INFO \"Too late to register bootconsole %s%d\\n\",\n\t\t\t\t\tnewcon->name, newcon->index);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (console_drivers && console_drivers->flags & CON_BOOT)\n\t\tbcon = console_drivers;\n\n\tif (preferred_console < 0 || bcon || !console_drivers)\n\t\tpreferred_console = selected_console;\n\n\tif (newcon->early_setup)\n\t\tnewcon->early_setup();\n\n\t/*\n\t *\tSee if we want to use this console driver. If we\n\t *\tdidn't select a console we take the first one\n\t *\tthat registers here.\n\t */\n\tif (preferred_console < 0) {\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = 0;\n\t\tif (newcon->setup == NULL ||\n\t\t    newcon->setup(newcon, NULL) == 0) {\n\t\t\tnewcon->flags |= CON_ENABLED;\n\t\t\tif (newcon->device) {\n\t\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\t\tpreferred_console = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tSee if this console matches one we selected on\n\t *\tthe command line.\n\t */\n\tfor (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0];\n\t\t\ti++) {\n\t\tif (strcmp(console_cmdline[i].name, newcon->name) != 0)\n\t\t\tcontinue;\n\t\tif (newcon->index >= 0 &&\n\t\t    newcon->index != console_cmdline[i].index)\n\t\t\tcontinue;\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = console_cmdline[i].index;\n#ifdef CONFIG_A11Y_BRAILLE_CONSOLE\n\t\tif (console_cmdline[i].brl_options) {\n\t\t\tnewcon->flags |= CON_BRL;\n\t\t\tbraille_register_console(newcon,\n\t\t\t\t\tconsole_cmdline[i].index,\n\t\t\t\t\tconsole_cmdline[i].options,\n\t\t\t\t\tconsole_cmdline[i].brl_options);\n\t\t\treturn;\n\t\t}\n#endif\n\t\tif (newcon->setup &&\n\t\t    newcon->setup(newcon, console_cmdline[i].options) != 0)\n\t\t\tbreak;\n\t\tnewcon->flags |= CON_ENABLED;\n\t\tnewcon->index = console_cmdline[i].index;\n\t\tif (i == selected_console) {\n\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\tpreferred_console = selected_console;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(newcon->flags & CON_ENABLED))\n\t\treturn;\n\n\t/*\n\t * If we have a bootconsole, and are switching to a real console,\n\t * don't print everything out again, since when the boot console, and\n\t * the real console are the same physical device, it's annoying to\n\t * see the beginning boot messages twice\n\t */\n\tif (bcon && ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))\n\t\tnewcon->flags &= ~CON_PRINTBUFFER;\n\n\t/*\n\t *\tPut this console in the list - keep the\n\t *\tpreferred driver at the head of the list.\n\t */\n\tconsole_lock();\n\tif ((newcon->flags & CON_CONSDEV) || console_drivers == NULL) {\n\t\tnewcon->next = console_drivers;\n\t\tconsole_drivers = newcon;\n\t\tif (newcon->next)\n\t\t\tnewcon->next->flags &= ~CON_CONSDEV;\n\t} else {\n\t\tnewcon->next = console_drivers->next;\n\t\tconsole_drivers->next = newcon;\n\t}\n\tif (newcon->flags & CON_PRINTBUFFER) {\n\t\t/*\n\t\t * console_unlock(); will print out the buffered messages\n\t\t * for us.\n\t\t */\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tcon_start = log_start;\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\t\t/*\n\t\t * We're about to replay the log buffer.  Only do this to the\n\t\t * just-registered console to avoid excessive message spam to\n\t\t * the already-registered consoles.\n\t\t */\n\t\texclusive_console = newcon;\n\t}\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\t/*\n\t * By unregistering the bootconsoles after we enable the real console\n\t * we get the \"console xxx enabled\" message on all the consoles -\n\t * boot consoles, real consoles, etc - this is to ensure that end\n\t * users know there might be something in the kernel's log buffer that\n\t * went to the bootconsole (that they do not see on the real console)\n\t */\n\tif (bcon &&\n\t    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &&\n\t    !keep_bootcon) {\n\t\t/* we need to iterate through twice, to make sure we print\n\t\t * everything out, before we unregister the console(s)\n\t\t */\n\t\tprintk(KERN_INFO \"console [%s%d] enabled, bootconsole disabled\\n\",\n\t\t\tnewcon->name, newcon->index);\n\t\tfor_each_console(bcon)\n\t\t\tif (bcon->flags & CON_BOOT)\n\t\t\t\tunregister_console(bcon);\n\t} else {\n\t\tprintk(KERN_INFO \"%sconsole [%s%d] enabled\\n\",\n\t\t\t(newcon->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\t\tnewcon->name, newcon->index);\n\t}\n}",
                        "code_after_change": "void register_console(struct console *newcon)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct console *bcon = NULL;\n\n\t/*\n\t * before we register a new CON_BOOT console, make sure we don't\n\t * already have a valid console\n\t */\n\tif (console_drivers && newcon->flags & CON_BOOT) {\n\t\t/* find the last or real console */\n\t\tfor_each_console(bcon) {\n\t\t\tif (!(bcon->flags & CON_BOOT)) {\n\t\t\t\tprintk(KERN_INFO \"Too late to register bootconsole %s%d\\n\",\n\t\t\t\t\tnewcon->name, newcon->index);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (console_drivers && console_drivers->flags & CON_BOOT)\n\t\tbcon = console_drivers;\n\n\tif (preferred_console < 0 || bcon || !console_drivers)\n\t\tpreferred_console = selected_console;\n\n\tif (newcon->early_setup)\n\t\tnewcon->early_setup();\n\n\t/*\n\t *\tSee if we want to use this console driver. If we\n\t *\tdidn't select a console we take the first one\n\t *\tthat registers here.\n\t */\n\tif (preferred_console < 0) {\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = 0;\n\t\tif (newcon->setup == NULL ||\n\t\t    newcon->setup(newcon, NULL) == 0) {\n\t\t\tnewcon->flags |= CON_ENABLED;\n\t\t\tif (newcon->device) {\n\t\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\t\tpreferred_console = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tSee if this console matches one we selected on\n\t *\tthe command line.\n\t */\n\tfor (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0];\n\t\t\ti++) {\n\t\tif (strcmp(console_cmdline[i].name, newcon->name) != 0)\n\t\t\tcontinue;\n\t\tif (newcon->index >= 0 &&\n\t\t    newcon->index != console_cmdline[i].index)\n\t\t\tcontinue;\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = console_cmdline[i].index;\n#ifdef CONFIG_A11Y_BRAILLE_CONSOLE\n\t\tif (console_cmdline[i].brl_options) {\n\t\t\tnewcon->flags |= CON_BRL;\n\t\t\tbraille_register_console(newcon,\n\t\t\t\t\tconsole_cmdline[i].index,\n\t\t\t\t\tconsole_cmdline[i].options,\n\t\t\t\t\tconsole_cmdline[i].brl_options);\n\t\t\treturn;\n\t\t}\n#endif\n\t\tif (newcon->setup &&\n\t\t    newcon->setup(newcon, console_cmdline[i].options) != 0)\n\t\t\tbreak;\n\t\tnewcon->flags |= CON_ENABLED;\n\t\tnewcon->index = console_cmdline[i].index;\n\t\tif (i == selected_console) {\n\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\tpreferred_console = selected_console;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(newcon->flags & CON_ENABLED))\n\t\treturn;\n\n\t/*\n\t * If we have a bootconsole, and are switching to a real console,\n\t * don't print everything out again, since when the boot console, and\n\t * the real console are the same physical device, it's annoying to\n\t * see the beginning boot messages twice\n\t */\n\tif (bcon && ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))\n\t\tnewcon->flags &= ~CON_PRINTBUFFER;\n\n\t/*\n\t *\tPut this console in the list - keep the\n\t *\tpreferred driver at the head of the list.\n\t */\n\tconsole_lock();\n\tif ((newcon->flags & CON_CONSDEV) || console_drivers == NULL) {\n\t\tnewcon->next = console_drivers;\n\t\tconsole_drivers = newcon;\n\t\tif (newcon->next)\n\t\t\tnewcon->next->flags &= ~CON_CONSDEV;\n\t} else {\n\t\tnewcon->next = console_drivers->next;\n\t\tconsole_drivers->next = newcon;\n\t}\n\tif (newcon->flags & CON_PRINTBUFFER) {\n\t\t/*\n\t\t * console_unlock(); will print out the buffered messages\n\t\t * for us.\n\t\t */\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tconsole_seq = syslog_seq;\n\t\tconsole_idx = syslog_idx;\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\t\t/*\n\t\t * We're about to replay the log buffer.  Only do this to the\n\t\t * just-registered console to avoid excessive message spam to\n\t\t * the already-registered consoles.\n\t\t */\n\t\texclusive_console = newcon;\n\t}\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\t/*\n\t * By unregistering the bootconsoles after we enable the real console\n\t * we get the \"console xxx enabled\" message on all the consoles -\n\t * boot consoles, real consoles, etc - this is to ensure that end\n\t * users know there might be something in the kernel's log buffer that\n\t * went to the bootconsole (that they do not see on the real console)\n\t */\n\tif (bcon &&\n\t    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &&\n\t    !keep_bootcon) {\n\t\t/* we need to iterate through twice, to make sure we print\n\t\t * everything out, before we unregister the console(s)\n\t\t */\n\t\tprintk(KERN_INFO \"console [%s%d] enabled, bootconsole disabled\\n\",\n\t\t\tnewcon->name, newcon->index);\n\t\tfor_each_console(bcon)\n\t\t\tif (bcon->flags & CON_BOOT)\n\t\t\t\tunregister_console(bcon);\n\t} else {\n\t\tprintk(KERN_INFO \"%sconsole [%s%d] enabled\\n\",\n\t\t\t(newcon->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\t\tnewcon->name, newcon->index);\n\t}\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t kmsg_writev(struct kiocb *iocb, const struct iovec *iv,\n\t\t\t   unsigned long count, loff_t pos)\n{\n\tchar *line, *p;\n\tint i;\n\tssize_t ret = -EFAULT;\n\tsize_t len = iov_length(iv, count);\n\n\tline = kmalloc(len + 1, GFP_KERNEL);\n\tif (line == NULL)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * copy all vectors into a single string, to ensure we do\n\t * not interleave our log line with other printk calls\n\t */\n\tp = line;\n\tfor (i = 0; i < count; i++) {\n\t\tif (copy_from_user(p, iv[i].iov_base, iv[i].iov_len))\n\t\t\tgoto out;\n\t\tp += iv[i].iov_len;\n\t}\n\tp[0] = '\\0';\n\n\tret = printk(\"%s\", line);\n\t/* printk can add a prefix */\n\tif (ret > len)\n\t\tret = len;\nout:\n\tkfree(line);\n\treturn ret;\n}",
                        "code_after_change": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\tloc->elf_ex.e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, 0);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
                        "code_after_change": "int\nnfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\t/* now decode the pathname, which might be larger than the first page.\n\t * As we have to check for nul's anyway, we copy it into a new page\n\t * This page appears in the rq_res.pages list, but as pages_len is always\n\t * 0, it won't get in the way\n\t */\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\t/* first copy and check from the first page */\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tif ((void *)old > vec->iov_base + vec->iov_len)\n\t\treturn 0;\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t/* now copy next page if there is one */\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\n\treturn 1;\n}",
                        "cve_id": "CVE-2017-1000253"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int do_syslog(int type, char __user *buf, int len, bool from_file)\n{\n\tunsigned i, j, limit, count;\n\tint do_clear = 0;\n\tchar c;\n\tint error;\n\n\terror = check_syslog_permissions(type, from_file);\n\tif (error)\n\t\tgoto out;\n\n\terror = security_syslog(type);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase SYSLOG_ACTION_CLOSE:\t/* Close log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_OPEN:\t/* Open log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_READ:\t/* Read from log */\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terror = wait_event_interruptible(log_wait,\n\t\t\t\t\t\t\t(log_start - log_end));\n\t\tif (error)\n\t\t\tgoto out;\n\t\ti = 0;\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\twhile (!error && (log_start != log_end) && i < len) {\n\t\t\tc = LOG_BUF(log_start);\n\t\t\tlog_start++;\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\terror = __put_user(c,buf);\n\t\t\tbuf++;\n\t\t\ti++;\n\t\t\tcond_resched();\n\t\t\traw_spin_lock_irq(&logbuf_lock);\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tif (!error)\n\t\t\terror = i;\n\t\tbreak;\n\t/* Read/clear last kernel messages */\n\tcase SYSLOG_ACTION_READ_CLEAR:\n\t\tdo_clear = 1;\n\t\t/* FALL THRU */\n\t/* Read last kernel messages */\n\tcase SYSLOG_ACTION_READ_ALL:\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tcount = len;\n\t\tif (count > log_buf_len)\n\t\t\tcount = log_buf_len;\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\tif (count > logged_chars)\n\t\t\tcount = logged_chars;\n\t\tif (do_clear)\n\t\t\tlogged_chars = 0;\n\t\tlimit = log_end;\n\t\t/*\n\t\t * __put_user() could sleep, and while we sleep\n\t\t * printk() could overwrite the messages\n\t\t * we try to copy to user space. Therefore\n\t\t * the messages are copied in reverse. <manfreds>\n\t\t */\n\t\tfor (i = 0; i < count && !error; i++) {\n\t\t\tj = limit-1-i;\n\t\t\tif (j + log_buf_len < log_end)\n\t\t\t\tbreak;\n\t\t\tc = LOG_BUF(j);\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\terror = __put_user(c,&buf[count-1-i]);\n\t\t\tcond_resched();\n\t\t\traw_spin_lock_irq(&logbuf_lock);\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = i;\n\t\tif (i != count) {\n\t\t\tint offset = count-error;\n\t\t\t/* buffer overflow during copy, correct user buffer. */\n\t\t\tfor (i = 0; i < error; i++) {\n\t\t\t\tif (__get_user(c,&buf[i+offset]) ||\n\t\t\t\t    __put_user(c,&buf[i])) {\n\t\t\t\t\terror = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t/* Clear ring buffer */\n\tcase SYSLOG_ACTION_CLEAR:\n\t\tlogged_chars = 0;\n\t\tbreak;\n\t/* Disable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_OFF:\n\t\tif (saved_console_loglevel == -1)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t/* Enable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_ON:\n\t\tif (saved_console_loglevel != -1) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = -1;\n\t\t}\n\t\tbreak;\n\t/* Set level of messages printed to console */\n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\terror = -EINVAL;\n\t\tif (len < 1 || len > 8)\n\t\t\tgoto out;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t/* Implicitly re-enable logging to console */\n\t\tsaved_console_loglevel = -1;\n\t\terror = 0;\n\t\tbreak;\n\t/* Number of chars in the log buffer */\n\tcase SYSLOG_ACTION_SIZE_UNREAD:\n\t\terror = log_end - log_start;\n\t\tbreak;\n\t/* Size of the log buffer */\n\tcase SYSLOG_ACTION_SIZE_BUFFER:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\treturn error;\n}",
                        "code_after_change": "static ssize_t kmsg_writev(struct kiocb *iocb, const struct iovec *iv,\n\t\t\t   unsigned long count, loff_t pos)\n{\n\tchar *buf, *line;\n\tint i;\n\tint level = default_message_loglevel;\n\tint facility = 1;\t/* LOG_USER */\n\tsize_t len = iov_length(iv, count);\n\tssize_t ret = len;\n\n\tif (len > 1024)\n\t\treturn -EINVAL;\n\tbuf = kmalloc(len+1, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tline = buf;\n\tfor (i = 0; i < count; i++) {\n\t\tif (copy_from_user(line, iv[i].iov_base, iv[i].iov_len))\n\t\t\tgoto out;\n\t\tline += iv[i].iov_len;\n\t}\n\n\t/*\n\t * Extract and skip the syslog prefix <[0-9]*>. Coming from userspace\n\t * the decimal value represents 32bit, the lower 3 bit are the log\n\t * level, the rest are the log facility.\n\t *\n\t * If no prefix or no userspace facility is specified, we\n\t * enforce LOG_USER, to be able to reliably distinguish\n\t * kernel-generated messages from userspace-injected ones.\n\t */\n\tline = buf;\n\tif (line[0] == '<') {\n\t\tchar *endp = NULL;\n\n\t\ti = simple_strtoul(line+1, &endp, 10);\n\t\tif (endp && endp[0] == '>') {\n\t\t\tlevel = i & 7;\n\t\t\tif (i >> 3)\n\t\t\t\tfacility = i >> 3;\n\t\t\tendp++;\n\t\t\tlen -= endp - line;\n\t\t\tline = endp;\n\t\t}\n\t}\n\tline[len] = '\\0';\n\n\tprintk_emit(facility, level, NULL, 0, \"%s\", line);\nout:\n\tkfree(buf);\n\treturn ret;\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 186,
            "cve_id": "CVE-2013-1773",
            "code_snippet": "static int\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char nc;\n\tunsigned char *op;\n\tunsigned int ec;\n\tint i, k, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, (wchar_t *)outname);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tif (nls) {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     *outlen += 1)\n\t\t\t{\n\t\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\t\tif (i > len - 5)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tec = 0;\n\t\t\t\t\tfor (k = 1; k < 5; k++) {\n\t\t\t\t\t\tnc = ip[k];\n\t\t\t\t\t\tec <<= 4;\n\t\t\t\t\t\tif (nc >= '0' && nc <= '9') {\n\t\t\t\t\t\t\tec |= nc - '0';\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'a' && nc <= 'f') {\n\t\t\t\t\t\t\tec |= nc - ('a' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'A' && nc <= 'F') {\n\t\t\t\t\t\t\tec |= nc - ('A' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t\t*op++ = ec & 0xFF;\n\t\t\t\t\t*op++ = ec >> 8;\n\t\t\t\t\tip += 5;\n\t\t\t\t\ti += 5;\n\t\t\t\t} else {\n\t\t\t\t\tif ((charlen = nls->char2uni(ip, len - i, (wchar_t *)op)) < 0)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tip += charlen;\n\t\t\t\t\ti += charlen;\n\t\t\t\t\top += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t} else {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     i++, *outlen += 1)\n\t\t\t{\n\t\t\t\t*op++ = *ip++;\n\t\t\t\t*op++ = 0;\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t}\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const unsigned int maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, ptrs_per_blk - mp->mp_list[end_of_metadata]);\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_block(ip, &bn, &n);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[i-1], 1);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[end_of_metadata], 1);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}",
                        "code_after_change": "static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const unsigned int maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint ret;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, ptrs_per_blk - mp->mp_list[end_of_metadata]);\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_block(ip, &bn, &n);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[i-1], 1);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[end_of_metadata], 1);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tif (buffer_zeronew(bh_map)) {\n\t\t\t\tret = sb_issue_zeroout(sb, dblock, dblks,\n\t\t\t\t\t\t       GFP_NOFS);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfs_err(sdp,\n\t\t\t\t\t       \"Failed to zero data buffers\\n\");\n\t\t\t\t\tclear_buffer_zeronew(bh_map);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}",
                        "cve_id": "CVE-2011-4098"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 206,
            "cve_id": "CVE-2013-1860",
            "code_snippet": "static int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock); /*concurrent reads */\n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = ACCESS_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\ti++;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = cntr ? cntr : -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t/* may have happened while we slept */\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) { /* read completed, error happened */\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * recheck whether we've lost the race\n\t\t * against the completion handler\n\t\t */\n\t\tif (!test_bit(WDM_READ, &desc->flags)) { /* lost race */\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!desc->reslength) { /* zero length read */\n\t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n\t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t/* in case we had outstanding data */\n\tif (!desc->length)\n\t\tclear_bit(WDM_READ, &desc->flags);\n\n\tspin_unlock_irq(&desc->iuspin);\n\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}",
                        "code_after_change": "static ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock); /*concurrent reads */\n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = ACCESS_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\t\t\trv = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\ti++;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = cntr ? cntr : -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t/* may have happened while we slept */\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) { /* read completed, error happened */\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * recheck whether we've lost the race\n\t\t * against the completion handler\n\t\t */\n\t\tif (!test_bit(WDM_READ, &desc->flags)) { /* lost race */\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (!desc->reslength) { /* zero length read */\n\t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n\t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t/* in case we had outstanding data */\n\tif (!desc->length)\n\t\tclear_bit(WDM_READ, &desc->flags);\n\n\tspin_unlock_irq(&desc->iuspin);\n\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}",
                        "cve_id": "CVE-2013-1860"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}",
                        "code_after_change": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tint length = urb->actual_length;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tif (length + desc->length > desc->wMaxCommand) {\n\t\t/* The buffer would overflow */\n\t\tset_bit(WDM_OVERFLOW, &desc->flags);\n\t} else {\n\t\t/* we may already be in overflow */\n\t\tif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tmemmove(desc->ubuf + desc->length, desc->inbuf, length);\n\t\t\tdesc->length += length;\n\t\t\tdesc->reslength = length;\n\t\t}\n\t}\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}",
                        "cve_id": "CVE-2013-1860"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 229,
            "cve_id": "CVE-2013-2234",
            "code_snippet": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}",
                        "code_after_change": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2013-2234"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 249,
            "cve_id": "CVE-2013-2850",
            "code_snippet": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tchar *tmpptr = key + strlen(key);\n\t\t\t\t*tmpptr = '=';\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstart += strlen(key) + strlen(value) + 2;\n\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\n\tkfree(tmpbuf);\n\treturn 0;\n}",
                        "code_after_change": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstart += strlen(key) + strlen(value) + 2;\n\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\n\tkfree(tmpbuf);\n\treturn 0;\n}",
                        "cve_id": "CVE-2013-2850"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 260,
            "cve_id": "CVE-2013-2893",
            "code_snippet": "static int hid_lg3ff_play(struct input_dev *dev, void *data,\n\t\t\t struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\n\tint x, y;\n\n/*\n * Maxusage should always be 63 (maximum fields)\n * likely a better way to ensure this data is clean\n */\n\tmemset(report->field[0]->value, 0, sizeof(__s32)*report->field[0]->maxusage);\n\n\tswitch (effect->type) {\n\tcase FF_CONSTANT:\n/*\n * Already clamped in ff_memless\n * 0 is center (different then other logitech)\n */\n\t\tx = effect->u.ramp.start_level;\n\t\ty = effect->u.ramp.end_level;\n\n\t\t/* send command byte */\n\t\treport->field[0]->value[0] = 0x51;\n\n/*\n * Sign backwards from other Force3d pro\n * which get recast here in two's complement 8 bits\n */\n\t\treport->field[0]->value[1] = (unsigned char)(-x);\n\t\treport->field[0]->value[31] = (unsigned char)(-y);\n\n\t\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output report found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treport = list_entry(report_list->next, struct hid_report, list);\n\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"output report is empty\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force feedback for Logitech RumblePad/Rumblepad 2 by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\n\treturn 0;\n}",
                        "code_after_change": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\n\t/* Check that the report looks ok */\n\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);\n\tif (!report)\n\t\treturn -ENODEV;\n\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force feedback for Logitech RumblePad/Rumblepad 2 by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2013-2893"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 264,
            "cve_id": "CVE-2013-2895",
            "code_snippet": "static int logi_dj_recv_send_report(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t    struct dj_report *dj_report)\n{\n\tstruct hid_device *hdev = djrcv_dev->hdev;\n\tstruct hid_report *report;\n\tstruct hid_report_enum *output_report_enum;\n\tu8 *data = (u8 *)(&dj_report->device_index);\n\tint i;\n\n\toutput_report_enum = &hdev->report_enum[HID_OUTPUT_REPORT];\n\treport = output_report_enum->report_id_hash[REPORT_ID_DJ_SHORT];\n\n\tif (!report) {\n\t\tdev_err(&hdev->dev, \"%s: unable to find dj report\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < report->field[0]->report_count; i++)\n\t\treport->field[0]->value[i] = data[i];\n\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output report found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treport = list_entry(report_list->next, struct hid_report, list);\n\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"output report is empty\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force feedback for Logitech RumblePad/Rumblepad 2 by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\n\treturn 0;\n}",
                        "code_after_change": "static int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct dj_receiver_dev *djrcv_dev;\n\tint retval;\n\n\tif (is_dj_device((struct dj_device *)hdev->driver_data))\n\t\treturn -ENODEV;\n\n\tdbg_hid(\"%s called for ifnum %d\\n\", __func__,\n\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\t/* Ignore interfaces 0 and 1, they will not carry any data, dont create\n\t * any hid_device for them */\n\tif (intf->cur_altsetting->desc.bInterfaceNumber !=\n\t    LOGITECH_DJ_INTERFACE_NUMBER) {\n\t\tdbg_hid(\"%s: ignoring ifnum %d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Treat interface 2 */\n\n\tdjrcv_dev = kzalloc(sizeof(struct dj_receiver_dev), GFP_KERNEL);\n\tif (!djrcv_dev) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:failed allocating dj_receiver_dev\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdjrcv_dev->hdev = hdev;\n\tINIT_WORK(&djrcv_dev->work, delayedwork_callback);\n\tspin_lock_init(&djrcv_dev->lock);\n\tif (kfifo_alloc(&djrcv_dev->notif_fifo,\n\t\t\tDJ_MAX_NUMBER_NOTIFICATIONS * sizeof(struct dj_report),\n\t\t\tGFP_KERNEL)) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:failed allocating notif_fifo\\n\", __func__);\n\t\tkfree(djrcv_dev);\n\t\treturn -ENOMEM;\n\t}\n\thid_set_drvdata(hdev, djrcv_dev);\n\n\t/* Call  to usbhid to fetch the HID descriptors of interface 2 and\n\t * subsequently call to the hid/hid-core to parse the fetched\n\t * descriptors, this will in turn create the hidraw and hiddev nodes\n\t * for interface 2 of the receiver */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:parse of interface 2 failed\\n\", __func__);\n\t\tgoto hid_parse_fail;\n\t}\n\n\tif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, REPORT_ID_DJ_SHORT,\n\t\t\t\t 0, DJREPORT_SHORT_LENGTH - 1)) {\n\t\tretval = -ENODEV;\n\t\tgoto hid_parse_fail;\n\t}\n\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (retval) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto switch_to_dj_mode_fail;\n\t}\n\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev, \"%s:hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\n\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev, \"%s:logi_dj_recv_query_paired_devices \"\n\t\t\t\"error:%d\\n\", __func__, retval);\n\t\tgoto logi_dj_recv_query_paired_devices_failed;\n\t}\n\n\treturn retval;\n\nlogi_dj_recv_query_paired_devices_failed:\n\thid_hw_close(hdev);\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\nhid_parse_fail:\n\tkfifo_free(&djrcv_dev->notif_fifo);\n\tkfree(djrcv_dev);\n\thid_set_drvdata(hdev, NULL);\n\treturn retval;\n\n}",
                        "cve_id": "CVE-2013-2893"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 306,
            "cve_id": "CVE-2013-4312",
            "code_snippet": "void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tspin_lock(&unix_gc_lock);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t\tspin_unlock(&unix_gc_lock);\n\t}\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tspin_lock(&unix_gc_lock);\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t\tspin_unlock(&unix_gc_lock);\n\t}\n}",
                        "code_after_change": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tfp->f_cred->user->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}",
                        "cve_id": "CVE-2013-4312"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 335,
            "cve_id": "CVE-2013-4514",
            "code_snippet": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\nisdn_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(file_inode(file));\n\tisdn_ctrl c;\n\tint drvidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\tcase IIOCGETDVR:\n\t\t\treturn (TTY_DV +\n\t\t\t\t(NET_DV << 8) +\n\t\t\t\t(INF_DV << 16));\n\t\tcase IIOCGETCPS:\n\t\t\tif (arg) {\n\t\t\t\tulong __user *p = argp;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCNETGPN:\n\t\t\t/* Get peer phone number of a connected\n\t\t\t * isdn network interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefore, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\tcase IIOCNETDWRSET:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\treturn (-EINVAL);\n\t\tcase IIOCNETLCR:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\treturn -ENODEV;\n\t\tcase IIOCNETAIF:\n\t\t\t/* Add a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\ts = name;\n\t\t\t} else {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETASL:\n\t\t\t/* Add a slave to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETDIF:\n\t\t\t/* Delete a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETSCF:\n\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGCF:\n\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETANM:\n\t\t\t/* Add a phone-number to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGNM:\n\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDNM:\n\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDIL:\n\t\t\t/* Force dialing of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase IIOCNETALN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_dial_slave(name);\n\t\tcase IIOCNETDLN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\tcase IIOCNETHUP:\n\t\t\t/* Force hangup of a network-interface */\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_net_force_hangup(name);\n\t\t\tbreak;\n\t\tcase IIOCSETVER:\n\t\t\tdev->net_verbose = arg;\n\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\treturn 0;\n\t\tcase IIOCSETGST:\n\t\t\tif (arg)\n\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\telse\n\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\treturn 0;\n\t\tcase IIOCSETBRJ:\n\t\t\tdrvidx = -1;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drvidx == -1)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (iocts.arg)\n\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\telse\n\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\treturn 0;\n\t\tcase IIOCSIGPRF:\n\t\t\tdev->profd = current;\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase IIOCGETPRF:\n\t\t\t/* Get all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t\t ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t}\n\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETPRF:\n\t\t\t/* Set all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t\t   ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETMAP:\n\t\tcase IIOCGETMAP:\n\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\tif (arg) {\n\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\tsnprintf(bname, sizeof(bname), \"%s%s\",\n\t\t\t\t\t\t\t strlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t dev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t (i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCDBGVAR:\n\t\t\tif (arg) {\n\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tc.driver = drvidx;\n\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\tc.arg = cmd;\n\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\tret = isdn_command(&c);\n\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}",
                        "code_after_change": "static int\nisdn_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(file_inode(file));\n\tisdn_ctrl c;\n\tint drvidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\tcase IIOCGETDVR:\n\t\t\treturn (TTY_DV +\n\t\t\t\t(NET_DV << 8) +\n\t\t\t\t(INF_DV << 16));\n\t\tcase IIOCGETCPS:\n\t\t\tif (arg) {\n\t\t\t\tulong __user *p = argp;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCNETGPN:\n\t\t\t/* Get peer phone number of a connected\n\t\t\t * isdn network interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefore, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\tcase IIOCNETDWRSET:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\treturn (-EINVAL);\n\t\tcase IIOCNETLCR:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\treturn -ENODEV;\n\t\tcase IIOCNETAIF:\n\t\t\t/* Add a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\ts = name;\n\t\t\t} else {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETASL:\n\t\t\t/* Add a slave to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbname[sizeof(bname)-1] = 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETDIF:\n\t\t\t/* Delete a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETSCF:\n\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGCF:\n\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETANM:\n\t\t\t/* Add a phone-number to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGNM:\n\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDNM:\n\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDIL:\n\t\t\t/* Force dialing of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase IIOCNETALN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_dial_slave(name);\n\t\tcase IIOCNETDLN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\tcase IIOCNETHUP:\n\t\t\t/* Force hangup of a network-interface */\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_net_force_hangup(name);\n\t\t\tbreak;\n\t\tcase IIOCSETVER:\n\t\t\tdev->net_verbose = arg;\n\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\treturn 0;\n\t\tcase IIOCSETGST:\n\t\t\tif (arg)\n\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\telse\n\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\treturn 0;\n\t\tcase IIOCSETBRJ:\n\t\t\tdrvidx = -1;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drvidx == -1)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (iocts.arg)\n\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\telse\n\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\treturn 0;\n\t\tcase IIOCSIGPRF:\n\t\t\tdev->profd = current;\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase IIOCGETPRF:\n\t\t\t/* Get all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t\t ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t}\n\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETPRF:\n\t\t\t/* Set all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t\t   ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETMAP:\n\t\tcase IIOCGETMAP:\n\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\tif (arg) {\n\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\tsnprintf(bname, sizeof(bname), \"%s%s\",\n\t\t\t\t\t\t\t strlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t dev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t (i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCDBGVAR:\n\t\t\tif (arg) {\n\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tc.driver = drvidx;\n\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\tc.arg = cmd;\n\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\tret = isdn_command(&c);\n\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}",
                        "cve_id": "CVE-2017-12762"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 344,
            "cve_id": "CVE-2013-4588",
            "code_snippet": "static int\ndo_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, get_arglen[GET_CMDID(cmd)]) != 0)\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}",
                        "code_after_change": "static int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n\t\treturn -EINVAL;\n\tif (len < 0 || len >  MAX_ARG_LEN)\n\t\treturn -EINVAL;\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}",
                        "cve_id": "CVE-2013-4588"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 360,
            "cve_id": "CVE-2013-6382",
            "code_snippet": "STATIC int\nxfs_compat_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tattrlist_cursor_kern_t\t*cursor;\n\tcompat_xfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -XFS_ERROR(EPERM);\n\tif (copy_from_user(&al_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -XFS_ERROR(EFAULT);\n\tif (al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -XFS_ERROR(EINVAL);\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -XFS_ERROR(EINVAL);\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -ENOMEM;\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(compat_ptr(al_hreq.buffer), kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "STATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -XFS_ERROR(EPERM);\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -XFS_ERROR(EFAULT);\n\tif (al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -XFS_ERROR(EINVAL);\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -XFS_ERROR(EINVAL);\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
                        "code_after_change": "STATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -XFS_ERROR(EPERM);\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -XFS_ERROR(EFAULT);\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -XFS_ERROR(EINVAL);\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -XFS_ERROR(EINVAL);\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
                        "cve_id": "CVE-2013-6382"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 530,
            "cve_id": "CVE-2014-0205",
            "code_snippet": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t/* Prepare to wait on uaddr. */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out_put_key;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n\t\tgoto retry;\n\t}\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out_put_key;\n\n\trestart = &current_thread_info()->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n\n\tret = -ERESTART_RESTARTBLOCK;\n\nout_put_key:\n\tput_futex_key(fshared, &q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n\t\treturn -ENOMEM;\n\n\t/* stop the CPU */\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t/* restart the CPU */\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(hx);\n\n\treturn ret;\n}",
                        "code_after_change": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 *buf;\n\tint ret, pos = 0;\n\tu16 cpu_cs_register = cypress[type].cpu_cs_register;\n\n\tbuf = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\thx = (struct hexline *)buf;\n\n\t/* stop the CPU */\n\tbuf[0] = 1;\n\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t/* restart the CPU */\n\t\tbuf[0] = 0;\n\t\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(buf);\n\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-8061"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static void *__io_uaddr_map(struct page ***pages, unsigned short *npages,\n\t\t\t    unsigned long uaddr, size_t size)\n{\n\tstruct page **page_array;\n\tunsigned int nr_pages;\n\tint ret, i;\n\n\t*npages = 0;\n\n\tif (uaddr & (PAGE_SIZE - 1) || !size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (nr_pages > USHRT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tpage_array = kvmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!page_array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = pin_user_pages_fast(uaddr, nr_pages, FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t\t\tpage_array);\n\tif (ret != nr_pages) {\nerr:\n\t\tio_pages_free(&page_array, ret > 0 ? ret : 0);\n\t\treturn ret < 0 ? ERR_PTR(ret) : ERR_PTR(-EFAULT);\n\t}\n\t/*\n\t * Should be a single page. If the ring is small enough that we can\n\t * use a normal page, that is fine. If we need multiple pages, then\n\t * userspace should use a huge page. That's the only way to guarantee\n\t * that we get contigious memory, outside of just being lucky or\n\t * (currently) having low memory fragmentation.\n\t */\n\tif (page_array[0] != page_array[ret - 1])\n\t\tgoto err;\n\n\t/*\n\t * Can't support mapping user allocated ring memory on 32-bit archs\n\t * where it could potentially reside in highmem. Just fail those with\n\t * -EINVAL, just like we did on kernels that didn't support this\n\t * feature.\n\t */\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (PageHighMem(page_array[i])) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t*pages = page_array;\n\t*npages = nr_pages;\n\treturn page_to_virt(page_array[0]);\n}",
                        "code_after_change": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
                        "cve_id": "CVE-2023-6560"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
                        "code_after_change": "static void *__io_uaddr_map(struct page ***pages, unsigned short *npages,\n\t\t\t    unsigned long uaddr, size_t size)\n{\n\tstruct page **page_array;\n\tunsigned int nr_pages;\n\tvoid *page_addr;\n\tint ret, i;\n\n\t*npages = 0;\n\n\tif (uaddr & (PAGE_SIZE - 1) || !size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (nr_pages > USHRT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tpage_array = kvmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!page_array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = pin_user_pages_fast(uaddr, nr_pages, FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t\t\tpage_array);\n\tif (ret != nr_pages) {\nerr:\n\t\tio_pages_free(&page_array, ret > 0 ? ret : 0);\n\t\treturn ret < 0 ? ERR_PTR(ret) : ERR_PTR(-EFAULT);\n\t}\n\n\tpage_addr = page_address(page_array[0]);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tret = -EINVAL;\n\n\t\t/*\n\t\t * Can't support mapping user allocated ring memory on 32-bit\n\t\t * archs where it could potentially reside in highmem. Just\n\t\t * fail those with -EINVAL, just like we did on kernels that\n\t\t * didn't support this feature.\n\t\t */\n\t\tif (PageHighMem(page_array[i]))\n\t\t\tgoto err;\n\n\t\t/*\n\t\t * No support for discontig pages for now, should either be a\n\t\t * single normal page, or a huge page. Later on we can add\n\t\t * support for remapping discontig pages, for now we will\n\t\t * just fail them with EINVAL.\n\t\t */\n\t\tif (page_address(page_array[i]) != page_addr)\n\t\t\tgoto err;\n\t\tpage_addr += PAGE_SIZE;\n\t}\n\n\t*pages = page_array;\n\t*npages = nr_pages;\n\treturn page_to_virt(page_array[0]);\n}",
                        "cve_id": "CVE-2016-9793"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, 0);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
                        "code_after_change": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\tloc->elf_ex.e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
                        "cve_id": "CVE-2017-1000253"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}",
                        "code_after_change": "static int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n\t\treturn -EINVAL;\n\tif (len < 0 || len >  MAX_ARG_LEN)\n\t\treturn -EINVAL;\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}",
                        "cve_id": "CVE-2013-4588"
                    },
                    "vul_output": "NO"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 0
        },
        {
            "id": 531,
            "cve_id": "CVE-2014-0205",
            "code_snippet": "static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t int clockrt, u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = NULL;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2;\n\tstruct futex_q q;\n\tint res, ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trt_waiter.task = NULL;\n\n\tkey2 = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr2, fshared, &key2);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/* Prepare to wait on uaddr. */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquition by the requeue code.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current,\n\t\t\t\t\t\t   fshared);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!&q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, fshared, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t/*\n\t * If fixup_pi_state_owner() faulted and was unable to handle the\n\t * fault, unlock the rt_mutex and return the fault to userspace.\n\t */\n\tif (ret == -EFAULT) {\n\t\tif (rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(fshared, &q.key);\nout_key2:\n\tput_futex_key(fshared, &key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void *__io_uaddr_map(struct page ***pages, unsigned short *npages,\n\t\t\t    unsigned long uaddr, size_t size)\n{\n\tstruct page **page_array;\n\tunsigned int nr_pages;\n\tint ret, i;\n\n\t*npages = 0;\n\n\tif (uaddr & (PAGE_SIZE - 1) || !size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (nr_pages > USHRT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tpage_array = kvmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!page_array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = pin_user_pages_fast(uaddr, nr_pages, FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t\t\tpage_array);\n\tif (ret != nr_pages) {\nerr:\n\t\tio_pages_free(&page_array, ret > 0 ? ret : 0);\n\t\treturn ret < 0 ? ERR_PTR(ret) : ERR_PTR(-EFAULT);\n\t}\n\t/*\n\t * Should be a single page. If the ring is small enough that we can\n\t * use a normal page, that is fine. If we need multiple pages, then\n\t * userspace should use a huge page. That's the only way to guarantee\n\t * that we get contigious memory, outside of just being lucky or\n\t * (currently) having low memory fragmentation.\n\t */\n\tif (page_array[0] != page_array[ret - 1])\n\t\tgoto err;\n\n\t/*\n\t * Can't support mapping user allocated ring memory on 32-bit archs\n\t * where it could potentially reside in highmem. Just fail those with\n\t * -EINVAL, just like we did on kernels that didn't support this\n\t * feature.\n\t */\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (PageHighMem(page_array[i])) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t*pages = page_array;\n\t*npages = nr_pages;\n\treturn page_to_virt(page_array[0]);\n}",
                        "code_after_change": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\tloc->elf_ex.e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
                        "cve_id": "CVE-2023-6560"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, 0);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
                        "code_after_change": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-1000253"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
                        "code_after_change": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock);\n\treturn hb;\n}",
                        "cve_id": "CVE-2016-9793"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock);\n\treturn hb;\n}",
                        "code_after_change": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n\t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
                        "cve_id": "CVE-2014-0205"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 578,
            "cve_id": "CVE-2014-3182",
            "code_snippet": "static int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\tbool report_processed = false;\n\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n\n\t/* Here we receive all data coming from iface 2, there are 4 cases:\n\t *\n\t * 1) Data should continue its normal processing i.e. data does not\n\t * come from the DJ collection, in which case we do nothing and\n\t * return 0, so hid-core can continue normal processing (will forward\n\t * to associated hidraw device)\n\t *\n\t * 2) Data is from DJ collection, and is intended for this driver i. e.\n\t * data contains arrival, departure, etc notifications, in which case\n\t * we queue them for delayed processing by the work queue. We return 1\n\t * to hid-core as no further processing is required from it.\n\t *\n\t * 3) Data is from DJ collection, and informs a connection change,\n\t * if the change means rf link loss, then we must send a null report\n\t * to the upper layer to discard potentially pressed keys that may be\n\t * repeated forever by the input layer. Return 1 to hid-core as no\n\t * further processing is required.\n\t *\n\t * 4) Data is from DJ collection and is an actual input event from\n\t * a paired DJ device in which case we forward it to the correct hid\n\t * device (via hid_input_report() ) and return 1 so hid-core does not do\n\t * anything else with it.\n\t */\n\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n\t\tswitch (dj_report->report_type) {\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\t\tbreak;\n\t\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t\t    STATUS_LINKLOSS) {\n\t\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogi_dj_recv_forward_report(djrcv_dev, dj_report);\n\t\t}\n\t\treport_processed = true;\n\t}\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\treturn report_processed;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tdjrcv_dev->querying_devices = false;\n\t\treturn;\n\t}\n\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t__func__, dj_report->device_index);\n\t\treturn;\n\t}\n\n\tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n\t\t/* The device is already known. No need to reallocate it. */\n\t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: hid_allocate_device failed\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\n\tdj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\n\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\"Logitech Unifying Device. Wireless PID:%02x%02x\",\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", dj_report->device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed allocating dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = get_unaligned_le32(\n\t\tdj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = dj_report->device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed adding dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}",
                        "code_after_change": "static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tdjrcv_dev->querying_devices = false;\n\t\treturn;\n\t}\n\n\tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n\t\t/* The device is already known. No need to reallocate it. */\n\t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: hid_allocate_device failed\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\n\tdj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\n\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\"Logitech Unifying Device. Wireless PID:%02x%02x\",\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", dj_report->device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed allocating dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = get_unaligned_le32(\n\t\tdj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = dj_report->device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed adding dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}",
                        "cve_id": "CVE-2014-3182"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 581,
            "cve_id": "CVE-2014-3184",
            "code_snippet": "static __u8 *kye_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_KYE_ERGO_525V:\n\t\t/* the fixups that need to be done:\n\t\t *   - change led usage page to button for extra buttons\n\t\t *   - report size 8 count 1 must be size 1 count 8 for button\n\t\t *     bitfield\n\t\t *   - change the button usage range to 4-7 for the extra\n\t\t *     buttons\n\t\t */\n\t\tif (*rsize >= 74 &&\n\t\t\trdesc[61] == 0x05 && rdesc[62] == 0x08 &&\n\t\t\trdesc[63] == 0x19 && rdesc[64] == 0x08 &&\n\t\t\trdesc[65] == 0x29 && rdesc[66] == 0x0f &&\n\t\t\trdesc[71] == 0x75 && rdesc[72] == 0x08 &&\n\t\t\trdesc[73] == 0x95 && rdesc[74] == 0x01) {\n\t\t\thid_info(hdev,\n\t\t\t\t \"fixing up Kye/Genius Ergo Mouse \"\n\t\t\t\t \"report descriptor\\n\");\n\t\t\trdesc[62] = 0x09;\n\t\t\trdesc[64] = 0x04;\n\t\t\trdesc[66] = 0x07;\n\t\t\trdesc[72] = 0x01;\n\t\t\trdesc[74] = 0x08;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_I405X:\n\t\tif (*rsize == EASYPEN_I405X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_i405x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_i405x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_MOUSEPEN_I608X:\n\t\tif (*rsize == MOUSEPEN_I608X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = mousepen_i608x_rdesc_fixed;\n\t\t\t*rsize = sizeof(mousepen_i608x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_M610X:\n\t\tif (*rsize == EASYPEN_M610X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_m610x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_m610x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Gila Gaming Mouse\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GX_IMPERATOR:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 83,\n\t\t\t\t\t\"Genius Gx Imperator Keyboard\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_MANTICORE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Manticore Keyboard\");\n\t\tbreak;\n\t}\n\treturn rdesc;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}",
                        "code_after_change": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 31 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}",
                        "cve_id": "CVE-2014-3184"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 582,
            "cve_id": "CVE-2014-3184",
            "code_snippet": "static __u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\tstruct usb_device_descriptor *udesc;\n\t__u16 bcdDevice, rev_maj, rev_min;\n\n\tif ((drv_data->quirks & LG_RDESC) && *rsize >= 90 && rdesc[83] == 0x26 &&\n\t\t\trdesc[84] == 0x8c && rdesc[85] == 0x02) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up Logitech keyboard report descriptor\\n\");\n\t\trdesc[84] = rdesc[89] = 0x4d;\n\t\trdesc[85] = rdesc[90] = 0x10;\n\t}\n\tif ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 50 &&\n\t\t\trdesc[32] == 0x81 && rdesc[33] == 0x06 &&\n\t\t\trdesc[49] == 0x81 && rdesc[50] == 0x06) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up rel/abs in Logitech report descriptor\\n\");\n\t\trdesc[33] = rdesc[50] = 0x02;\n\t}\n\n\tswitch (hdev->product) {\n\n\t/* Several wheels report as this id when operating in emulation mode. */\n\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\tudesc = &(hid_to_usb_dev(hdev)->descriptor);\n\t\tif (!udesc) {\n\t\t\thid_err(hdev, \"NULL USB device descriptor\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\t\trev_maj = bcdDevice >> 8;\n\t\trev_min = bcdDevice & 0xff;\n\n\t\t/* Update the report descriptor for only the Driving Force wheel */\n\t\tif (rev_maj == 1 && rev_min == 2 &&\n\t\t\t\t*rsize == DF_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force report descriptor\\n\");\n\t\t\trdesc = df_rdesc_fixed;\n\t\t\t*rsize = sizeof(df_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tif (*rsize == MOMO_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Force (Red) report descriptor\\n\");\n\t\t\trdesc = momo_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tif (*rsize == MOMO2_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Racing Force (Black) report descriptor\\n\");\n\t\t\trdesc = momo2_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo2_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:\n\t\tif (*rsize == FV_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Formula Vibration report descriptor\\n\");\n\t\t\trdesc = fv_rdesc_fixed;\n\t\t\t*rsize = sizeof(fv_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tif (*rsize == DFP_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force Pro report descriptor\\n\");\n\t\t\trdesc = dfp_rdesc_fixed;\n\t\t\t*rsize = sizeof(dfp_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\tif (*rsize >= 101 && rdesc[41] == 0x95 && rdesc[42] == 0x0B &&\n\t\t\t\trdesc[47] == 0x05 && rdesc[48] == 0x09) {\n\t\t\thid_info(hdev, \"fixing up Logitech Speed Force Wireless report descriptor\\n\");\n\t\t\trdesc[41] = 0x05;\n\t\t\trdesc[42] = 0x09;\n\t\t\trdesc[47] = 0x95;\n\t\t\trdesc[48] = 0x0B;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rdesc;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}",
                        "code_after_change": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 31 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}",
                        "cve_id": "CVE-2014-3184"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 647,
            "cve_id": "CVE-2014-6416",
            "code_snippet": "static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tchar *dbuf;\n\tchar *ticket_buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tdbuf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!dbuf)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tticket_buf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!ticket_buf)\n\t\tgoto out_dbuf;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end,\n\t\t\t\t\t dbuf, ticket_buf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tkfree(ticket_buf);\nout_dbuf:\n\tkfree(dbuf);\n\treturn ret;\n\nbad:\n\tret = -EINVAL;\n\tgoto out;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
                        "code_after_change": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *preply = &reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
                        "cve_id": "CVE-2014-6416"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 829,
            "cve_id": "CVE-2015-4036",
            "code_snippet": "static void\nvhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\t/* TODO: share lun setup code with virtio-scsi.ko */\n\t\t/*\n\t\t * Note: evt->event is zeroed when we allocate it and\n\t\t * lun[4-7] need to be zero according to virtio-scsi spec.\n\t\t */\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int tipc_l2_device_event(struct notifier_block *nb, unsigned long evt,\n\t\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\tstruct tipc_bearer *b;\n\n\tb = rtnl_dereference(dev->tipc_ptr);\n\tif (!b)\n\t\treturn NOTIFY_DONE;\n\n\tb->mtu = dev->mtu;\n\n\tswitch (evt) {\n\tcase NETDEV_CHANGE:\n\t\tif (netif_carrier_ok(dev))\n\t\t\tbreak;\n\tcase NETDEV_UP:\n\t\ttest_and_set_bit_lock(0, &b->up);\n\t\tbreak;\n\tcase NETDEV_GOING_DOWN:\n\t\tclear_bit_unlock(0, &b->up);\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_CHANGEADDR:\n\t\tb->media->raw2addr(b, &b->addr,\n\t\t\t\t   (char *)dev->dev_addr);\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\tcase NETDEV_CHANGENAME:\n\t\tbearer_disable(dev_net(dev), b);\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
                        "code_after_change": "static int tipc_l2_device_event(struct notifier_block *nb, unsigned long evt,\n\t\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\tstruct tipc_bearer *b;\n\n\tb = rtnl_dereference(dev->tipc_ptr);\n\tif (!b)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (evt) {\n\tcase NETDEV_CHANGE:\n\t\tif (netif_carrier_ok(dev))\n\t\t\tbreak;\n\tcase NETDEV_UP:\n\t\ttest_and_set_bit_lock(0, &b->up);\n\t\tbreak;\n\tcase NETDEV_GOING_DOWN:\n\t\tclear_bit_unlock(0, &b->up);\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (tipc_mtu_bad(dev, 0)) {\n\t\t\tbearer_disable(net, b);\n\t\t\tbreak;\n\t\t}\n\t\tb->mtu = dev->mtu;\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_CHANGEADDR:\n\t\tb->media->raw2addr(b, &b->addr,\n\t\t\t\t   (char *)dev->dev_addr);\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\tcase NETDEV_CHANGENAME:\n\t\tbearer_disable(dev_net(dev), b);\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
                        "cve_id": "CVE-2016-8632"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct se_portal_group *\nvhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\n\tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}",
                        "code_after_change": "static struct se_portal_group *\nvhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\n\tstruct vhost_scsi_tpg *tpg;\n\tu16 tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}",
                        "cve_id": "CVE-2015-4036"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 841,
            "cve_id": "CVE-2015-5283",
            "code_snippet": "static __exit void sctp_exit(void)\n{\n\t/* BUG.  This should probably do something useful like clean\n\t * up all the remaining associations and all that memory.\n\t */\n\n\t/* Unregister with inet6/inet layers. */\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\n\tunregister_pernet_subsys(&sctp_net_ops);\n\n\t/* Free protosw registrations */\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\n\t/* Unregister with socket layer. */\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\n\tsctp_sysctl_unregister();\n\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\n\trcu_barrier(); /* Wait for completion of call_rcu()'s */\n\n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static __init int sctp_init(void)\n{\n\tint i;\n\tint status = -EINVAL;\n\tunsigned long goal;\n\tunsigned long limit;\n\tint max_share;\n\tint order;\n\n\tsock_skb_cb_check_size(sizeof(struct sctp_ulpevent));\n\n\t/* Allocate bind_bucket and chunk caches. */\n\tstatus = -ENOBUFS;\n\tsctp_bucket_cachep = kmem_cache_create(\"sctp_bind_bucket\",\n\t\t\t\t\t       sizeof(struct sctp_bind_bucket),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_bucket_cachep)\n\t\tgoto out;\n\n\tsctp_chunk_cachep = kmem_cache_create(\"sctp_chunk\",\n\t\t\t\t\t       sizeof(struct sctp_chunk),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_chunk_cachep)\n\t\tgoto err_chunk_cachep;\n\n\tstatus = percpu_counter_init(&sctp_sockets_allocated, 0, GFP_KERNEL);\n\tif (status)\n\t\tgoto err_percpu_counter_init;\n\n\t/* Implementation specific variables. */\n\n\t/* Initialize default stream count setup information. */\n\tsctp_max_instreams    \t\t= SCTP_DEFAULT_INSTREAMS;\n\tsctp_max_outstreams   \t\t= SCTP_DEFAULT_OUTSTREAMS;\n\n\t/* Initialize handle used for association ids. */\n\tidr_init(&sctp_assocs_id);\n\n\tlimit = nr_free_buffer_pages() / 8;\n\tlimit = max(limit, 128UL);\n\tsysctl_sctp_mem[0] = limit / 4 * 3;\n\tsysctl_sctp_mem[1] = limit;\n\tsysctl_sctp_mem[2] = sysctl_sctp_mem[0] * 2;\n\n\t/* Set per-socket limits to no more than 1/128 the pressure threshold*/\n\tlimit = (sysctl_sctp_mem[1]) << (PAGE_SHIFT - 7);\n\tmax_share = min(4UL*1024*1024, limit);\n\n\tsysctl_sctp_rmem[0] = SK_MEM_QUANTUM; /* give each asoc 1 page min */\n\tsysctl_sctp_rmem[1] = 1500 * SKB_TRUESIZE(1);\n\tsysctl_sctp_rmem[2] = max(sysctl_sctp_rmem[1], max_share);\n\n\tsysctl_sctp_wmem[0] = SK_MEM_QUANTUM;\n\tsysctl_sctp_wmem[1] = 16*1024;\n\tsysctl_sctp_wmem[2] = max(64*1024, max_share);\n\n\t/* Size and allocate the association hash table.\n\t * The methodology is similar to that of the tcp hash tables.\n\t */\n\tif (totalram_pages >= (128 * 1024))\n\t\tgoal = totalram_pages >> (22 - PAGE_SHIFT);\n\telse\n\t\tgoal = totalram_pages >> (24 - PAGE_SHIFT);\n\n\tfor (order = 0; (1UL << order) < goal; order++)\n\t\t;\n\n\tdo {\n\t\tsctp_assoc_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_hashbucket);\n\t\tif ((sctp_assoc_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_assoc_hashtable = (struct sctp_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_assoc_hashtable && --order > 0);\n\tif (!sctp_assoc_hashtable) {\n\t\tpr_err(\"Failed association hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ahash_alloc;\n\t}\n\tfor (i = 0; i < sctp_assoc_hashsize; i++) {\n\t\trwlock_init(&sctp_assoc_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_assoc_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the endpoint hash table.  */\n\tsctp_ep_hashsize = 64;\n\tsctp_ep_hashtable =\n\t\tkmalloc(64 * sizeof(struct sctp_hashbucket), GFP_KERNEL);\n\tif (!sctp_ep_hashtable) {\n\t\tpr_err(\"Failed endpoint_hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ehash_alloc;\n\t}\n\tfor (i = 0; i < sctp_ep_hashsize; i++) {\n\t\trwlock_init(&sctp_ep_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_ep_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the SCTP port hash table.  */\n\tdo {\n\t\tsctp_port_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_bind_hashbucket);\n\t\tif ((sctp_port_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_port_hashtable = (struct sctp_bind_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_port_hashtable && --order > 0);\n\tif (!sctp_port_hashtable) {\n\t\tpr_err(\"Failed bind hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_bhash_alloc;\n\t}\n\tfor (i = 0; i < sctp_port_hashsize; i++) {\n\t\tspin_lock_init(&sctp_port_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_port_hashtable[i].chain);\n\t}\n\n\tpr_info(\"Hash tables configured (established %d bind %d)\\n\",\n\t\tsctp_assoc_hashsize, sctp_port_hashsize);\n\n\tsctp_sysctl_register();\n\n\tINIT_LIST_HEAD(&sctp_address_families);\n\tsctp_v4_pf_init();\n\tsctp_v6_pf_init();\n\n\tstatus = sctp_v4_protosw_init();\n\n\tif (status)\n\t\tgoto err_protosw_init;\n\n\tstatus = sctp_v6_protosw_init();\n\tif (status)\n\t\tgoto err_v6_protosw_init;\n\n\tstatus = register_pernet_subsys(&sctp_net_ops);\n\tif (status)\n\t\tgoto err_register_pernet_subsys;\n\n\tstatus = sctp_v4_add_protocol();\n\tif (status)\n\t\tgoto err_add_protocol;\n\n\t/* Register SCTP with inet6 layer.  */\n\tstatus = sctp_v6_add_protocol();\n\tif (status)\n\t\tgoto err_v6_add_protocol;\n\nout:\n\treturn status;\nerr_v6_add_protocol:\n\tsctp_v4_del_protocol();\nerr_add_protocol:\n\tunregister_pernet_subsys(&sctp_net_ops);\nerr_register_pernet_subsys:\n\tsctp_v6_protosw_exit();\nerr_v6_protosw_init:\n\tsctp_v4_protosw_exit();\nerr_protosw_init:\n\tsctp_v4_pf_exit();\n\tsctp_v6_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\nerr_bhash_alloc:\n\tkfree(sctp_ep_hashtable);\nerr_ehash_alloc:\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\nerr_ahash_alloc:\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\nerr_percpu_counter_init:\n\tkmem_cache_destroy(sctp_chunk_cachep);\nerr_chunk_cachep:\n\tkmem_cache_destroy(sctp_bucket_cachep);\n\tgoto out;\n}",
                        "code_after_change": "static __init int sctp_init(void)\n{\n\tint i;\n\tint status = -EINVAL;\n\tunsigned long goal;\n\tunsigned long limit;\n\tint max_share;\n\tint order;\n\n\tsock_skb_cb_check_size(sizeof(struct sctp_ulpevent));\n\n\t/* Allocate bind_bucket and chunk caches. */\n\tstatus = -ENOBUFS;\n\tsctp_bucket_cachep = kmem_cache_create(\"sctp_bind_bucket\",\n\t\t\t\t\t       sizeof(struct sctp_bind_bucket),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_bucket_cachep)\n\t\tgoto out;\n\n\tsctp_chunk_cachep = kmem_cache_create(\"sctp_chunk\",\n\t\t\t\t\t       sizeof(struct sctp_chunk),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_chunk_cachep)\n\t\tgoto err_chunk_cachep;\n\n\tstatus = percpu_counter_init(&sctp_sockets_allocated, 0, GFP_KERNEL);\n\tif (status)\n\t\tgoto err_percpu_counter_init;\n\n\t/* Implementation specific variables. */\n\n\t/* Initialize default stream count setup information. */\n\tsctp_max_instreams    \t\t= SCTP_DEFAULT_INSTREAMS;\n\tsctp_max_outstreams   \t\t= SCTP_DEFAULT_OUTSTREAMS;\n\n\t/* Initialize handle used for association ids. */\n\tidr_init(&sctp_assocs_id);\n\n\tlimit = nr_free_buffer_pages() / 8;\n\tlimit = max(limit, 128UL);\n\tsysctl_sctp_mem[0] = limit / 4 * 3;\n\tsysctl_sctp_mem[1] = limit;\n\tsysctl_sctp_mem[2] = sysctl_sctp_mem[0] * 2;\n\n\t/* Set per-socket limits to no more than 1/128 the pressure threshold*/\n\tlimit = (sysctl_sctp_mem[1]) << (PAGE_SHIFT - 7);\n\tmax_share = min(4UL*1024*1024, limit);\n\n\tsysctl_sctp_rmem[0] = SK_MEM_QUANTUM; /* give each asoc 1 page min */\n\tsysctl_sctp_rmem[1] = 1500 * SKB_TRUESIZE(1);\n\tsysctl_sctp_rmem[2] = max(sysctl_sctp_rmem[1], max_share);\n\n\tsysctl_sctp_wmem[0] = SK_MEM_QUANTUM;\n\tsysctl_sctp_wmem[1] = 16*1024;\n\tsysctl_sctp_wmem[2] = max(64*1024, max_share);\n\n\t/* Size and allocate the association hash table.\n\t * The methodology is similar to that of the tcp hash tables.\n\t */\n\tif (totalram_pages >= (128 * 1024))\n\t\tgoal = totalram_pages >> (22 - PAGE_SHIFT);\n\telse\n\t\tgoal = totalram_pages >> (24 - PAGE_SHIFT);\n\n\tfor (order = 0; (1UL << order) < goal; order++)\n\t\t;\n\n\tdo {\n\t\tsctp_assoc_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_hashbucket);\n\t\tif ((sctp_assoc_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_assoc_hashtable = (struct sctp_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_assoc_hashtable && --order > 0);\n\tif (!sctp_assoc_hashtable) {\n\t\tpr_err(\"Failed association hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ahash_alloc;\n\t}\n\tfor (i = 0; i < sctp_assoc_hashsize; i++) {\n\t\trwlock_init(&sctp_assoc_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_assoc_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the endpoint hash table.  */\n\tsctp_ep_hashsize = 64;\n\tsctp_ep_hashtable =\n\t\tkmalloc(64 * sizeof(struct sctp_hashbucket), GFP_KERNEL);\n\tif (!sctp_ep_hashtable) {\n\t\tpr_err(\"Failed endpoint_hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ehash_alloc;\n\t}\n\tfor (i = 0; i < sctp_ep_hashsize; i++) {\n\t\trwlock_init(&sctp_ep_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_ep_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the SCTP port hash table.  */\n\tdo {\n\t\tsctp_port_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_bind_hashbucket);\n\t\tif ((sctp_port_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_port_hashtable = (struct sctp_bind_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_port_hashtable && --order > 0);\n\tif (!sctp_port_hashtable) {\n\t\tpr_err(\"Failed bind hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_bhash_alloc;\n\t}\n\tfor (i = 0; i < sctp_port_hashsize; i++) {\n\t\tspin_lock_init(&sctp_port_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_port_hashtable[i].chain);\n\t}\n\n\tpr_info(\"Hash tables configured (established %d bind %d)\\n\",\n\t\tsctp_assoc_hashsize, sctp_port_hashsize);\n\n\tsctp_sysctl_register();\n\n\tINIT_LIST_HEAD(&sctp_address_families);\n\tsctp_v4_pf_init();\n\tsctp_v6_pf_init();\n\n\tstatus = register_pernet_subsys(&sctp_defaults_ops);\n\tif (status)\n\t\tgoto err_register_defaults;\n\n\tstatus = sctp_v4_protosw_init();\n\tif (status)\n\t\tgoto err_protosw_init;\n\n\tstatus = sctp_v6_protosw_init();\n\tif (status)\n\t\tgoto err_v6_protosw_init;\n\n\tstatus = register_pernet_subsys(&sctp_ctrlsock_ops);\n\tif (status)\n\t\tgoto err_register_ctrlsock;\n\n\tstatus = sctp_v4_add_protocol();\n\tif (status)\n\t\tgoto err_add_protocol;\n\n\t/* Register SCTP with inet6 layer.  */\n\tstatus = sctp_v6_add_protocol();\n\tif (status)\n\t\tgoto err_v6_add_protocol;\n\nout:\n\treturn status;\nerr_v6_add_protocol:\n\tsctp_v4_del_protocol();\nerr_add_protocol:\n\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\nerr_register_ctrlsock:\n\tsctp_v6_protosw_exit();\nerr_v6_protosw_init:\n\tsctp_v4_protosw_exit();\nerr_protosw_init:\n\tunregister_pernet_subsys(&sctp_defaults_ops);\nerr_register_defaults:\n\tsctp_v4_pf_exit();\n\tsctp_v6_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\nerr_bhash_alloc:\n\tkfree(sctp_ep_hashtable);\nerr_ehash_alloc:\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\nerr_ahash_alloc:\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\nerr_percpu_counter_init:\n\tkmem_cache_destroy(sctp_chunk_cachep);\nerr_chunk_cachep:\n\tkmem_cache_destroy(sctp_bucket_cachep);\n\tgoto out;\n}",
                        "cve_id": "CVE-2015-5283"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1030,
            "cve_id": "CVE-2016-3134",
            "code_snippet": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(&e->arp))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static bool check_underflow(const struct ipt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(&e->ip))\n\t\treturn false;\n\tt = ipt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
                        "code_after_change": "static bool check_underflow(const struct ipt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = ipt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1031,
            "cve_id": "CVE-2016-3134",
            "code_snippet": "static int mark_source_chains(const struct xt_table_info *newinfo,\n\t\t\t      unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t * to 0 as we leave), and comefrom to save source hook bitmask.\n\t */\n\tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct arpt_entry *e\n\t\t\t= (struct arpt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)arpt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {\n\t\t\t\tpr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom\n\t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct arpt_entry) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 && unconditional(&e->arp)) ||\n\t\t\t    visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t * big jump.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct arpt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ip6t_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct ip6t_entry) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 &&\n\t\t\t     unconditional(&e->ipv6)) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ip6t_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
                        "code_after_change": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ip6t_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ip6t_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1032,
            "cve_id": "CVE-2016-3134",
            "code_snippet": "static int\ncheck_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1033,
            "cve_id": "CVE-2016-3134",
            "code_snippet": "static inline int\nget_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int\nget_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
                        "code_after_change": "static inline int\nget_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (unconditional(s) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1034,
            "cve_id": "CVE-2016-3134",
            "code_snippet": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ipt_entry *e = (struct ipt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ipt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct ipt_entry) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 && unconditional(&e->ip)) ||\n\t\t\t    visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ipt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ip6t_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct ip6t_entry) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 &&\n\t\t\t     unconditional(&e->ipv6)) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ip6t_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
                        "code_after_change": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ip6t_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ip6t_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1113,
            "cve_id": "CVE-2016-4998",
            "code_snippet": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int\ncheck_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->target_offset,\n\t\t\t\t\t    e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}",
                        "code_after_change": "static inline int\ncheck_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t\t    e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
                        "code_after_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "NO"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 0
        },
        {
            "id": 1114,
            "cve_id": "CVE-2016-4998",
            "code_snippet": "static int\ncheck_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1201,
            "cve_id": "CVE-2016-8632",
            "code_snippet": "int tipc_enable_l2_media(struct net *net, struct tipc_bearer *b,\n\t\t\t struct nlattr *attr[])\n{\n\tstruct net_device *dev;\n\tchar *driver_name = strchr((const char *)b->name, ':') + 1;\n\n\t/* Find device with specified name */\n\tdev = dev_get_by_name(net, driver_name);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\t/* Associate TIPC bearer with L2 bearer */\n\trcu_assign_pointer(b->media_ptr, dev);\n\tmemset(&b->bcast_addr, 0, sizeof(b->bcast_addr));\n\tmemcpy(b->bcast_addr.value, dev->broadcast, b->media->hwaddr_len);\n\tb->bcast_addr.media_id = b->media->type_id;\n\tb->bcast_addr.broadcast = 1;\n\tb->mtu = dev->mtu;\n\tb->media->raw2addr(b, &b->addr, (char *)dev->dev_addr);\n\trcu_assign_pointer(dev->tipc_ptr, b);\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int tipc_udp_enable(struct net *net, struct tipc_bearer *b,\n\t\t\t   struct nlattr *attrs[])\n{\n\tint err = -EINVAL;\n\tstruct udp_bearer *ub;\n\tstruct udp_media_addr remote = {0};\n\tstruct udp_media_addr local = {0};\n\tstruct udp_port_cfg udp_conf = {0};\n\tstruct udp_tunnel_sock_cfg tuncfg = {NULL};\n\tstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\n\n\tub = kzalloc(sizeof(*ub), GFP_ATOMIC);\n\tif (!ub)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ub->rcast.list);\n\n\tif (!attrs[TIPC_NLA_BEARER_UDP_OPTS])\n\t\tgoto err;\n\n\tif (nla_parse_nested(opts, TIPC_NLA_UDP_MAX,\n\t\t\t     attrs[TIPC_NLA_BEARER_UDP_OPTS],\n\t\t\t     tipc_nl_udp_policy))\n\t\tgoto err;\n\n\tif (!opts[TIPC_NLA_UDP_LOCAL] || !opts[TIPC_NLA_UDP_REMOTE]) {\n\t\tpr_err(\"Invalid UDP bearer configuration\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_LOCAL], &local,\n\t\t\t\t  &ub->ifindex);\n\tif (err)\n\t\tgoto err;\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_REMOTE], &remote, NULL);\n\tif (err)\n\t\tgoto err;\n\n\tb->bcast_addr.media_id = TIPC_MEDIA_TYPE_UDP;\n\tb->bcast_addr.broadcast = 1;\n\trcu_assign_pointer(b->media_ptr, ub);\n\trcu_assign_pointer(ub->bearer, b);\n\ttipc_udp_media_addr_set(&b->addr, &local);\n\tif (local.proto == htons(ETH_P_IP)) {\n\t\tstruct net_device *dev;\n\n\t\tdev = __ip_dev_find(net, local.ipv4.s_addr, false);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tudp_conf.family = AF_INET;\n\t\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n\t\tudp_conf.use_udp_checksums = false;\n\t\tub->ifindex = dev->ifindex;\n\t\tb->mtu = dev->mtu - sizeof(struct iphdr)\n\t\t\t- sizeof(struct udphdr);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (local.proto == htons(ETH_P_IPV6)) {\n\t\tudp_conf.family = AF_INET6;\n\t\tudp_conf.use_udp6_tx_checksums = true;\n\t\tudp_conf.use_udp6_rx_checksums = true;\n\t\tudp_conf.local_ip6 = in6addr_any;\n\t\tb->mtu = 1280;\n#endif\n\t} else {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto err;\n\t}\n\tudp_conf.local_udp_port = local.port;\n\terr = udp_sock_create(net, &udp_conf, &ub->ubsock);\n\tif (err)\n\t\tgoto err;\n\ttuncfg.sk_user_data = ub;\n\ttuncfg.encap_type = 1;\n\ttuncfg.encap_rcv = tipc_udp_recv;\n\ttuncfg.encap_destroy = NULL;\n\tsetup_udp_tunnel_sock(net, ub->ubsock, &tuncfg);\n\n\t/**\n\t * The bcast media address port is used for all peers and the ip\n\t * is used if it's a multicast address.\n\t */\n\tmemcpy(&b->bcast_addr.value, &remote, sizeof(remote));\n\tif (tipc_udp_is_mcast_addr(&remote))\n\t\terr = enable_mcast(ub, &remote);\n\telse\n\t\terr = tipc_udp_rcast_add(b, &remote);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tif (ub->ubsock)\n\t\tudp_tunnel_sock_release(ub->ubsock);\n\tkfree(ub);\n\treturn err;\n}",
                        "code_after_change": "static int tipc_udp_enable(struct net *net, struct tipc_bearer *b,\n\t\t\t   struct nlattr *attrs[])\n{\n\tint err = -EINVAL;\n\tstruct udp_bearer *ub;\n\tstruct udp_media_addr remote = {0};\n\tstruct udp_media_addr local = {0};\n\tstruct udp_port_cfg udp_conf = {0};\n\tstruct udp_tunnel_sock_cfg tuncfg = {NULL};\n\tstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\n\n\tub = kzalloc(sizeof(*ub), GFP_ATOMIC);\n\tif (!ub)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ub->rcast.list);\n\n\tif (!attrs[TIPC_NLA_BEARER_UDP_OPTS])\n\t\tgoto err;\n\n\tif (nla_parse_nested(opts, TIPC_NLA_UDP_MAX,\n\t\t\t     attrs[TIPC_NLA_BEARER_UDP_OPTS],\n\t\t\t     tipc_nl_udp_policy))\n\t\tgoto err;\n\n\tif (!opts[TIPC_NLA_UDP_LOCAL] || !opts[TIPC_NLA_UDP_REMOTE]) {\n\t\tpr_err(\"Invalid UDP bearer configuration\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_LOCAL], &local,\n\t\t\t\t  &ub->ifindex);\n\tif (err)\n\t\tgoto err;\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_REMOTE], &remote, NULL);\n\tif (err)\n\t\tgoto err;\n\n\tb->bcast_addr.media_id = TIPC_MEDIA_TYPE_UDP;\n\tb->bcast_addr.broadcast = 1;\n\trcu_assign_pointer(b->media_ptr, ub);\n\trcu_assign_pointer(ub->bearer, b);\n\ttipc_udp_media_addr_set(&b->addr, &local);\n\tif (local.proto == htons(ETH_P_IP)) {\n\t\tstruct net_device *dev;\n\n\t\tdev = __ip_dev_find(net, local.ipv4.s_addr, false);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tudp_conf.family = AF_INET;\n\t\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n\t\tudp_conf.use_udp_checksums = false;\n\t\tub->ifindex = dev->ifindex;\n\t\tif (tipc_mtu_bad(dev, sizeof(struct iphdr) +\n\t\t\t\t      sizeof(struct udphdr))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tb->mtu = dev->mtu - sizeof(struct iphdr)\n\t\t\t- sizeof(struct udphdr);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (local.proto == htons(ETH_P_IPV6)) {\n\t\tudp_conf.family = AF_INET6;\n\t\tudp_conf.use_udp6_tx_checksums = true;\n\t\tudp_conf.use_udp6_rx_checksums = true;\n\t\tudp_conf.local_ip6 = in6addr_any;\n\t\tb->mtu = 1280;\n#endif\n\t} else {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto err;\n\t}\n\tudp_conf.local_udp_port = local.port;\n\terr = udp_sock_create(net, &udp_conf, &ub->ubsock);\n\tif (err)\n\t\tgoto err;\n\ttuncfg.sk_user_data = ub;\n\ttuncfg.encap_type = 1;\n\ttuncfg.encap_rcv = tipc_udp_recv;\n\ttuncfg.encap_destroy = NULL;\n\tsetup_udp_tunnel_sock(net, ub->ubsock, &tuncfg);\n\n\t/**\n\t * The bcast media address port is used for all peers and the ip\n\t * is used if it's a multicast address.\n\t */\n\tmemcpy(&b->bcast_addr.value, &remote, sizeof(remote));\n\tif (tipc_udp_is_mcast_addr(&remote))\n\t\terr = enable_mcast(ub, &remote);\n\telse\n\t\terr = tipc_udp_rcast_add(b, &remote);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tif (ub->ubsock)\n\t\tudp_tunnel_sock_release(ub->ubsock);\n\tkfree(ub);\n\treturn err;\n}",
                        "cve_id": "CVE-2016-8632"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1204,
            "cve_id": "CVE-2016-8633",
            "code_snippet": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tu16 source_node_id;\n\tu32 specifier_id;\n\tu32 ver;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\n\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\n\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\n\n\tif (specifier_id == IANA_SPECIFIER_ID &&\n\t    (ver == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || ver == RFC3146_SW_VERSION\n#endif\n\t    )) {\n\t\tbuf_ptr += 2;\n\t\tlength -= IEEE1394_GASP_HDR_SIZE;\n\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\n\t\t\t\t      context->card->generation, true);\n\t}\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\t/* A datagram fragment has been received, now the fun begins. */\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
                        "code_after_change": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\tif (len <= RFC2374_UNFRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\n\t/* A datagram fragment has been received, now the fun begins. */\n\n\tif (len <= RFC2374_FRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tif (fg_off + len > dg_size)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
                        "cve_id": "CVE-2016-8633"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1345,
            "cve_id": "CVE-2017-12762",
            "code_snippet": "char *\nisdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\n\tif (p) {\n\t\t/* Slave-Name MUST not be empty */\n\t\tif (!strlen(p + 1))\n\t\t\treturn NULL;\n\t\tstrcpy(newname, p + 1);\n\t\t*p = 0;\n\t\t/* Master must already exist */\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\t/* Master must be a real interface, not a slave */\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\t/* Master must not be started yet */\n\t\tif (isdn_net_device_started(n))\n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\nisdn_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(file_inode(file));\n\tisdn_ctrl c;\n\tint drvidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\tcase IIOCGETDVR:\n\t\t\treturn (TTY_DV +\n\t\t\t\t(NET_DV << 8) +\n\t\t\t\t(INF_DV << 16));\n\t\tcase IIOCGETCPS:\n\t\t\tif (arg) {\n\t\t\t\tulong __user *p = argp;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCNETGPN:\n\t\t\t/* Get peer phone number of a connected\n\t\t\t * isdn network interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefore, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\tcase IIOCNETDWRSET:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\treturn (-EINVAL);\n\t\tcase IIOCNETLCR:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\treturn -ENODEV;\n\t\tcase IIOCNETAIF:\n\t\t\t/* Add a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\ts = name;\n\t\t\t} else {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETASL:\n\t\t\t/* Add a slave to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETDIF:\n\t\t\t/* Delete a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETSCF:\n\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGCF:\n\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETANM:\n\t\t\t/* Add a phone-number to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGNM:\n\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDNM:\n\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDIL:\n\t\t\t/* Force dialing of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase IIOCNETALN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_dial_slave(name);\n\t\tcase IIOCNETDLN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\tcase IIOCNETHUP:\n\t\t\t/* Force hangup of a network-interface */\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_net_force_hangup(name);\n\t\t\tbreak;\n\t\tcase IIOCSETVER:\n\t\t\tdev->net_verbose = arg;\n\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\treturn 0;\n\t\tcase IIOCSETGST:\n\t\t\tif (arg)\n\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\telse\n\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\treturn 0;\n\t\tcase IIOCSETBRJ:\n\t\t\tdrvidx = -1;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drvidx == -1)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (iocts.arg)\n\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\telse\n\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\treturn 0;\n\t\tcase IIOCSIGPRF:\n\t\t\tdev->profd = current;\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase IIOCGETPRF:\n\t\t\t/* Get all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t\t ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t}\n\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETPRF:\n\t\t\t/* Set all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t\t   ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETMAP:\n\t\tcase IIOCGETMAP:\n\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\tif (arg) {\n\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\tsnprintf(bname, sizeof(bname), \"%s%s\",\n\t\t\t\t\t\t\t strlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t dev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t (i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCDBGVAR:\n\t\t\tif (arg) {\n\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tc.driver = drvidx;\n\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\tc.arg = cmd;\n\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\tret = isdn_command(&c);\n\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}",
                        "code_after_change": "static int\nisdn_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(file_inode(file));\n\tisdn_ctrl c;\n\tint drvidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\tcase IIOCGETDVR:\n\t\t\treturn (TTY_DV +\n\t\t\t\t(NET_DV << 8) +\n\t\t\t\t(INF_DV << 16));\n\t\tcase IIOCGETCPS:\n\t\t\tif (arg) {\n\t\t\t\tulong __user *p = argp;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCNETGPN:\n\t\t\t/* Get peer phone number of a connected\n\t\t\t * isdn network interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefore, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\tcase IIOCNETDWRSET:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\treturn (-EINVAL);\n\t\tcase IIOCNETLCR:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\treturn -ENODEV;\n\t\tcase IIOCNETAIF:\n\t\t\t/* Add a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\ts = name;\n\t\t\t} else {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETASL:\n\t\t\t/* Add a slave to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbname[sizeof(bname)-1] = 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETDIF:\n\t\t\t/* Delete a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETSCF:\n\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGCF:\n\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETANM:\n\t\t\t/* Add a phone-number to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGNM:\n\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDNM:\n\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDIL:\n\t\t\t/* Force dialing of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase IIOCNETALN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_dial_slave(name);\n\t\tcase IIOCNETDLN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\tcase IIOCNETHUP:\n\t\t\t/* Force hangup of a network-interface */\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_net_force_hangup(name);\n\t\t\tbreak;\n\t\tcase IIOCSETVER:\n\t\t\tdev->net_verbose = arg;\n\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\treturn 0;\n\t\tcase IIOCSETGST:\n\t\t\tif (arg)\n\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\telse\n\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\treturn 0;\n\t\tcase IIOCSETBRJ:\n\t\t\tdrvidx = -1;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drvidx == -1)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (iocts.arg)\n\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\telse\n\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\treturn 0;\n\t\tcase IIOCSIGPRF:\n\t\t\tdev->profd = current;\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase IIOCGETPRF:\n\t\t\t/* Get all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t\t ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t}\n\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETPRF:\n\t\t\t/* Set all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t\t   ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETMAP:\n\t\tcase IIOCGETMAP:\n\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\tif (arg) {\n\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\tsnprintf(bname, sizeof(bname), \"%s%s\",\n\t\t\t\t\t\t\t strlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t dev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t (i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCDBGVAR:\n\t\t\tif (arg) {\n\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tc.driver = drvidx;\n\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\tc.arg = cmd;\n\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\tret = isdn_command(&c);\n\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}",
                        "cve_id": "CVE-2017-12762"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1379,
            "cve_id": "CVE-2017-15126",
            "code_snippet": "static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\n\t\tif (!ret) {\n\t\t\tspin_lock(&ctx->event_wqh.lock);\n\t\t\tif (!list_empty(&fork_event)) {\n\t\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t\t       wq.entry);\n\t\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\t}\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t}\n\t}\n\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}",
                        "code_after_change": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}",
                        "cve_id": "CVE-2017-15126"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1392,
            "cve_id": "CVE-2017-16526",
            "code_snippet": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}",
                        "code_after_change": "void uwbd_start(struct uwb_rc *rc)\n{\n\tstruct task_struct *task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (IS_ERR(task)) {\n\t\trc->uwbd.task = NULL;\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\t} else {\n\t\trc->uwbd.task = task;\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n\t}\n}",
                        "cve_id": "CVE-2017-16526"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1437,
            "cve_id": "CVE-2017-16996",
            "code_snippet": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno, int off,\n\t\t\t    int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* ctx accesses must be at a fixed offset, so that we can\n\t\t * determine what type of data were returned.\n\t\t */\n\t\tif (reg->off) {\n\t\t\tverbose(env,\n\t\t\t\t\"dereference of modified ctx ptr R%d off=%d+%d, ctx+const is allowed, ctx+const+const is not\\n\",\n\t\t\t\tregno, reg->off, off - reg->off);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env,\n\t\t\t\t\"variable ctx access var_off=%s off=%d size=%d\",\n\t\t\t\ttn_buf, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE)\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\telse\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\tregs[value_regno].id = 0;\n\t\t\tregs[value_regno].off = 0;\n\t\t\tregs[value_regno].range = 0;\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* stack accesses must be at a fixed offset, so that we can\n\t\t * determine what type of data were returned.\n\t\t * See check_stack_read().\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"variable stack access var_off=%s off=%d size=%d\",\n\t\t\t\ttn_buf, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\toff += reg->var_off.value;\n\t\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\t\tverbose(env, \"invalid stack off=%d size=%d\\n\", off,\n\t\t\t\tsize);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (env->prog->aux->stack_depth < -off)\n\t\t\tenv->prog->aux->stack_depth = -off;\n\n\t\tif (t == BPF_WRITE)\n\t\t\terr = check_stack_write(env, state, off, size,\n\t\t\t\t\t\tvalue_regno);\n\t\telse\n\t\t\terr = check_stack_read(env, state, off, size,\n\t\t\t\t\t       value_regno);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str[reg->type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tregs[value_regno].var_off =\n\t\t\ttnum_cast(regs[value_regno].var_off, size);\n\t\t__update_reg_bounds(&regs[value_regno]);\n\t}\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (base_type(reg->type) == PTR_TO_MEM) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\n\t\tif (type_may_be_null(reg->type)) {\n\t\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\t\treg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && rdonly_mem) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && value_regno >= 0 && (t == BPF_READ || rdonly_mem))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf, &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (base_type(reg_type) == PTR_TO_BTF_ID) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = func(env, reg);\n\t\terr = update_stack_depth(env, state, off);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_BTF_ID) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BUF) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\t\tconst char *buf_info;\n\t\tu32 *max_access;\n\n\t\tif (rdonly_mem) {\n\t\t\tif (t == BPF_WRITE) {\n\t\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tbuf_info = \"rdonly\";\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tbuf_info = \"rdwr\";\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  buf_info, max_access);\n\n\t\tif (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
                        "code_after_change": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (base_type(reg->type) == PTR_TO_MEM) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\n\t\tif (type_may_be_null(reg->type)) {\n\t\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\t\treg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && rdonly_mem) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && value_regno >= 0 && (t == BPF_READ || rdonly_mem))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ptr_off_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf, &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (base_type(reg_type) == PTR_TO_BTF_ID) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = func(env, reg);\n\t\terr = update_stack_depth(env, state, off);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_BTF_ID) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BUF) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\t\tconst char *buf_info;\n\t\tu32 *max_access;\n\n\t\tif (rdonly_mem) {\n\t\t\tif (t == BPF_WRITE) {\n\t\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tbuf_info = \"rdonly\";\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tbuf_info = \"rdwr\";\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  buf_info, max_access);\n\n\t\tif (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
                        "cve_id": "CVE-2021-4204"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t\tregs[insn->dst_reg].live |= REG_LIVE_WRITTEN;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\t/* high 32 bits are known zero. */\n\t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(\n\t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);\n\t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t\tregs[insn->dst_reg].live |= REG_LIVE_WRITTEN;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\tcoerce_reg_to_size(&regs[insn->dst_reg], 4);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-16996"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1491,
            "cve_id": "CVE-2017-18222",
            "code_snippet": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
                        "code_after_change": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-18222"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1546,
            "cve_id": "CVE-2017-5547",
            "code_snippet": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\treturn -EIO;\n\t}\n\treturn brightness;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}",
                        "code_after_change": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-5547"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1549,
            "cve_id": "CVE-2017-5548",
            "code_snippet": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar build[ATUSB_BUILD_SIZE + 1];\n\tint ret;\n\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\treturn ret;\n}",
                        "code_after_change": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(3, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-5548"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1618,
            "cve_id": "CVE-2017-7895",
            "code_snippet": "int\nnfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tstruct kvec *tail = rqstp->rq_arg.tail;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The count must equal the amount of data passed.\n\t */\n\tif (args->count != args->len)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
                        "code_after_change": "int\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
                        "cve_id": "CVE-2017-7895"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1623,
            "cve_id": "CVE-2017-8062",
            "code_snippet": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\t/* reset board */\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\t/* attach demod */\n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.spec_inv = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.agc_inv = 0;\n\tm88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;\n\tm88ds3103_pdata.envelope_mode = 0;\n\tm88ds3103_pdata.lnb_hv_pol = 1;\n\tm88ds3103_pdata.lnb_en_pol = 0;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x68;\n\tboard_info.platform_data = &m88ds3103_pdata;\n\trequest_module(\"m88ds3103\");\n\tclient = i2c_new_device(&d->i2c_adap, &board_info);\n\tif (client == NULL || client->dev.driver == NULL)\n\t\treturn -ENODEV;\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);\n\n\tstate->i2c_client_demod = client;\n\n\t/* attach tuner */\n\tts2020_config.fe = adap->fe_adap[0].fe;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"ts2022\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x60;\n\tboard_info.platform_data = &ts2020_config;\n\trequest_module(\"ts2020\");\n\tclient = i2c_new_device(i2c_adapter, &board_info);\n\n\tif (client == NULL || client->dev.driver == NULL) {\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\t/* delegate signal strength measurement to tuner */\n\tadap->fe_adap[0].fe->ops.read_signal_strength =\n\t\t\tadap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;\n\n\tstate->i2c_client_tuner = client;\n\n\t/* hook fe: need to resync the slave fifo when signal locks */\n\tstate->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;\n\n\tstate->last_lock = 0;\n\n\treturn 0;\n}",
                        "code_after_change": "static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct dw2102_state *state;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\n\tstate = d->priv;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tif (mutex_lock_interruptible(&d->data_mutex) < 0) {\n\t\tmutex_unlock(&d->i2c_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\tswitch (num) {\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase SU3000_STREAM_CTRL:\n\t\t\tstate->data[0] = msg[0].buf[0] + 0x36;\n\t\t\tstate->data[1] = 3;\n\t\t\tstate->data[2] = 0;\n\t\t\tif (dvb_usb_generic_rw(d, state->data, 3,\n\t\t\t\t\tstate->data, 0, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tbreak;\n\t\tcase DW2102_RC_QUERY:\n\t\t\tstate->data[0] = 0x10;\n\t\t\tif (dvb_usb_generic_rw(d, state->data, 1,\n\t\t\t\t\tstate->data, 2, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tmsg[0].buf[1] = state->data[0];\n\t\t\tmsg[0].buf[0] = state->data[1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* always i2c write*/\n\t\t\tstate->data[0] = 0x08;\n\t\t\tstate->data[1] = msg[0].addr;\n\t\t\tstate->data[2] = msg[0].len;\n\n\t\t\tmemcpy(&state->data[3], msg[0].buf, msg[0].len);\n\n\t\t\tif (dvb_usb_generic_rw(d, state->data, msg[0].len + 3,\n\t\t\t\t\t\tstate->data, 1, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/* always i2c read */\n\t\tstate->data[0] = 0x09;\n\t\tstate->data[1] = msg[0].len;\n\t\tstate->data[2] = msg[1].len;\n\t\tstate->data[3] = msg[0].addr;\n\t\tmemcpy(&state->data[4], msg[0].buf, msg[0].len);\n\n\t\tif (dvb_usb_generic_rw(d, state->data, msg[0].len + 4,\n\t\t\t\t\tstate->data, msg[1].len + 1, 0) < 0)\n\t\t\terr(\"i2c transfer failed.\");\n\n\t\tmemcpy(msg[1].buf, &state->data[1], msg[1].len);\n\t\tbreak;\n\tdefault:\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet.\");\n\t\tbreak;\n\t}\n\tmutex_unlock(&d->data_mutex);\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}",
                        "cve_id": "CVE-2017-8062"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1629,
            "cve_id": "CVE-2017-8068",
            "code_snippet": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
                        "code_after_change": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(&data, 1, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, buf, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-8068"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1726,
            "cve_id": "CVE-2018-1120",
            "code_snippet": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\n\t/* Ensure the process spawned far enough to have an environment. */\n\tif (!mm || !mm->env_end)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!mmget_not_zero(mm))\n\t\tgoto free;\n\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\n\t\tthis_len = env_end - (env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (env_start + src), page, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t _count, loff_t *pos)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tchar *page;\n\tunsigned long count = _count;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tunsigned long len1, len2, len;\n\tunsigned long p;\n\tchar c;\n\tssize_t rv;\n\n\tBUG_ON(*pos < 0);\n\n\ttsk = get_proc_task(file_inode(file));\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(tsk);\n\tput_task_struct(tsk);\n\tif (!mm)\n\t\treturn 0;\n\t/* Check if process spawned far enough to have cmdline. */\n\tif (!mm->env_end) {\n\t\trv = 0;\n\t\tgoto out_mmput;\n\t}\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page) {\n\t\trv = -ENOMEM;\n\t\tgoto out_mmput;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\targ_start = mm->arg_start;\n\targ_end = mm->arg_end;\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\tBUG_ON(arg_start > arg_end);\n\tBUG_ON(env_start > env_end);\n\n\tlen1 = arg_end - arg_start;\n\tlen2 = env_end - env_start;\n\n\t/* Empty ARGV. */\n\tif (len1 == 0) {\n\t\trv = 0;\n\t\tgoto out_free_page;\n\t}\n\t/*\n\t * Inherently racy -- command line shares address space\n\t * with code and data.\n\t */\n\trv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);\n\tif (rv <= 0)\n\t\tgoto out_free_page;\n\n\trv = 0;\n\n\tif (c == '\\0') {\n\t\t/* Command line (set of strings) occupies whole ARGV. */\n\t\tif (len1 <= *pos)\n\t\t\tgoto out_free_page;\n\n\t\tp = arg_start + *pos;\n\t\tlen = len1 - *pos;\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count;\n\t\t\tint nr_read;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Command line (1 string) occupies ARGV and\n\t\t * extends into ENVP.\n\t\t */\n\t\tstruct {\n\t\t\tunsigned long p;\n\t\t\tunsigned long len;\n\t\t} cmdline[2] = {\n\t\t\t{ .p = arg_start, .len = len1 },\n\t\t\t{ .p = env_start, .len = len2 },\n\t\t};\n\t\tloff_t pos1 = *pos;\n\t\tunsigned int i;\n\n\t\ti = 0;\n\t\twhile (i < 2 && pos1 >= cmdline[i].len) {\n\t\t\tpos1 -= cmdline[i].len;\n\t\t\ti++;\n\t\t}\n\t\twhile (i < 2) {\n\t\t\tp = cmdline[i].p + pos1;\n\t\t\tlen = cmdline[i].len - pos1;\n\t\t\twhile (count > 0 && len > 0) {\n\t\t\t\tunsigned int _count, l;\n\t\t\t\tint nr_read;\n\t\t\t\tbool final;\n\n\t\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\t\tif (nr_read < 0)\n\t\t\t\t\trv = nr_read;\n\t\t\t\tif (nr_read <= 0)\n\t\t\t\t\tgoto out_free_page;\n\n\t\t\t\t/*\n\t\t\t\t * Command line can be shorter than whole ARGV\n\t\t\t\t * even if last \"marker\" byte says it is not.\n\t\t\t\t */\n\t\t\t\tfinal = false;\n\t\t\t\tl = strnlen(page, nr_read);\n\t\t\t\tif (l < nr_read) {\n\t\t\t\t\tnr_read = l;\n\t\t\t\t\tfinal = true;\n\t\t\t\t}\n\n\t\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\t\trv = -EFAULT;\n\t\t\t\t\tgoto out_free_page;\n\t\t\t\t}\n\n\t\t\t\tp\t+= nr_read;\n\t\t\t\tlen\t-= nr_read;\n\t\t\t\tbuf\t+= nr_read;\n\t\t\t\tcount\t-= nr_read;\n\t\t\t\trv\t+= nr_read;\n\n\t\t\t\tif (final)\n\t\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\t/* Only first chunk can be read partially. */\n\t\t\tpos1 = 0;\n\t\t\ti++;\n\t\t}\n\t}\n\nout_free_page:\n\tfree_page((unsigned long)page);\nout_mmput:\n\tmmput(mm);\n\tif (rv > 0)\n\t\t*pos += rv;\n\treturn rv;\n}",
                        "code_after_change": "static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t _count, loff_t *pos)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tchar *page;\n\tunsigned long count = _count;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tunsigned long len1, len2, len;\n\tunsigned long p;\n\tchar c;\n\tssize_t rv;\n\n\tBUG_ON(*pos < 0);\n\n\ttsk = get_proc_task(file_inode(file));\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(tsk);\n\tput_task_struct(tsk);\n\tif (!mm)\n\t\treturn 0;\n\t/* Check if process spawned far enough to have cmdline. */\n\tif (!mm->env_end) {\n\t\trv = 0;\n\t\tgoto out_mmput;\n\t}\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page) {\n\t\trv = -ENOMEM;\n\t\tgoto out_mmput;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\targ_start = mm->arg_start;\n\targ_end = mm->arg_end;\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\tBUG_ON(arg_start > arg_end);\n\tBUG_ON(env_start > env_end);\n\n\tlen1 = arg_end - arg_start;\n\tlen2 = env_end - env_start;\n\n\t/* Empty ARGV. */\n\tif (len1 == 0) {\n\t\trv = 0;\n\t\tgoto out_free_page;\n\t}\n\t/*\n\t * Inherently racy -- command line shares address space\n\t * with code and data.\n\t */\n\trv = access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_ANON);\n\tif (rv <= 0)\n\t\tgoto out_free_page;\n\n\trv = 0;\n\n\tif (c == '\\0') {\n\t\t/* Command line (set of strings) occupies whole ARGV. */\n\t\tif (len1 <= *pos)\n\t\t\tgoto out_free_page;\n\n\t\tp = arg_start + *pos;\n\t\tlen = len1 - *pos;\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count;\n\t\t\tint nr_read;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Command line (1 string) occupies ARGV and\n\t\t * extends into ENVP.\n\t\t */\n\t\tstruct {\n\t\t\tunsigned long p;\n\t\t\tunsigned long len;\n\t\t} cmdline[2] = {\n\t\t\t{ .p = arg_start, .len = len1 },\n\t\t\t{ .p = env_start, .len = len2 },\n\t\t};\n\t\tloff_t pos1 = *pos;\n\t\tunsigned int i;\n\n\t\ti = 0;\n\t\twhile (i < 2 && pos1 >= cmdline[i].len) {\n\t\t\tpos1 -= cmdline[i].len;\n\t\t\ti++;\n\t\t}\n\t\twhile (i < 2) {\n\t\t\tp = cmdline[i].p + pos1;\n\t\t\tlen = cmdline[i].len - pos1;\n\t\t\twhile (count > 0 && len > 0) {\n\t\t\t\tunsigned int _count, l;\n\t\t\t\tint nr_read;\n\t\t\t\tbool final;\n\n\t\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\t\tnr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);\n\t\t\t\tif (nr_read < 0)\n\t\t\t\t\trv = nr_read;\n\t\t\t\tif (nr_read <= 0)\n\t\t\t\t\tgoto out_free_page;\n\n\t\t\t\t/*\n\t\t\t\t * Command line can be shorter than whole ARGV\n\t\t\t\t * even if last \"marker\" byte says it is not.\n\t\t\t\t */\n\t\t\t\tfinal = false;\n\t\t\t\tl = strnlen(page, nr_read);\n\t\t\t\tif (l < nr_read) {\n\t\t\t\t\tnr_read = l;\n\t\t\t\t\tfinal = true;\n\t\t\t\t}\n\n\t\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\t\trv = -EFAULT;\n\t\t\t\t\tgoto out_free_page;\n\t\t\t\t}\n\n\t\t\t\tp\t+= nr_read;\n\t\t\t\tlen\t-= nr_read;\n\t\t\t\tbuf\t+= nr_read;\n\t\t\t\tcount\t-= nr_read;\n\t\t\t\trv\t+= nr_read;\n\n\t\t\t\tif (final)\n\t\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\t/* Only first chunk can be read partially. */\n\t\t\tpos1 = 0;\n\t\t\ti++;\n\t\t}\n\t}\n\nout_free_page:\n\tfree_page((unsigned long)page);\nout_mmput:\n\tmmput(mm);\n\tif (rv > 0)\n\t\t*pos += rv;\n\treturn rv;\n}",
                        "cve_id": "CVE-2018-1120"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1950,
            "cve_id": "CVE-2018-7740",
            "code_snippet": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tstruct resv_map *resv_map;\n\tlong gbl_reserve;\n\n\t/*\n\t * Only apply hugepage reservation if asked. At fault time, an\n\t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n\t */\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tresv_map = inode_resv_map(inode);\n\n\t\tchg = region_chg(resv_map, from, to);\n\n\t} else {\n\t\tresv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * There must be enough pages in the subpool for the mapping. If\n\t * the subpool has a minimum size, there may be some global\n\t * reservations already in place (gbl_reserve).\n\t */\n\tgbl_reserve = hugepage_subpool_get_pages(spool, chg);\n\tif (gbl_reserve < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n\t */\n\tret = hugetlb_acct_memory(h, gbl_reserve);\n\tif (ret < 0) {\n\t\t/* put back original number of pages, chg */\n\t\t(void)hugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tlong add = region_add(resv_map, from, to);\n\n\t\tif (unlikely(chg > add)) {\n\t\t\t/*\n\t\t\t * pages in this range were added to the reserve\n\t\t\t * map between region_chg and region_add.  This\n\t\t\t * indicates a race with alloc_huge_page.  Adjust\n\t\t\t * the subpool and reserve counts modified above\n\t\t\t * based on the difference.\n\t\t\t */\n\t\t\tlong rsv_adjust;\n\n\t\t\trsv_adjust = hugepage_subpool_put_pages(spool,\n\t\t\t\t\t\t\t\tchg - add);\n\t\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t\t}\n\t}\n\treturn 0;\nout_err:\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\t/* Don't call region_abort if region_chg failed */\n\t\tif (chg >= 0)\n\t\t\tregion_abort(resv_map, from, to);\n\tif (vma && is_vma_resv_set(vma, HPAGE_RESV_OWNER))\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tint write = (gup_flags & FOLL_WRITE);\n\tint foreign = (gup_flags & FOLL_REMOTE);\n\n\tif (vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn -EFAULT;\n\n\tif (write) {\n\t\tif (!(vm_flags & VM_WRITE)) {\n\t\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\t\treturn -EFAULT;\n\t\t\t/*\n\t\t\t * We used to let the write,force case do COW in a\n\t\t\t * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could\n\t\t\t * set a breakpoint in a read-only mapping of an\n\t\t\t * executable, without corrupting the file (yet only\n\t\t\t * when that file had been opened for writing!).\n\t\t\t * Anon pages in shared mappings are surprising: now\n\t\t\t * just reject it.\n\t\t\t */\n\t\t\tif (!is_cow_mapping(vm_flags))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (!(vm_flags & VM_READ)) {\n\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\treturn -EFAULT;\n\t\t/*\n\t\t * Is there actually any vma we can reach here which does not\n\t\t * have VM_MAYREAD set?\n\t\t */\n\t\tif (!(vm_flags & VM_MAYREAD))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * gups are always data accesses, not instruction\n\t * fetches, so execute=false here\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
                        "code_after_change": "static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tint write = (gup_flags & FOLL_WRITE);\n\tint foreign = (gup_flags & FOLL_REMOTE);\n\n\tif (vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn -EFAULT;\n\n\tif (gup_flags & FOLL_ANON && !vma_is_anonymous(vma))\n\t\treturn -EFAULT;\n\n\tif (write) {\n\t\tif (!(vm_flags & VM_WRITE)) {\n\t\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\t\treturn -EFAULT;\n\t\t\t/*\n\t\t\t * We used to let the write,force case do COW in a\n\t\t\t * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could\n\t\t\t * set a breakpoint in a read-only mapping of an\n\t\t\t * executable, without corrupting the file (yet only\n\t\t\t * when that file had been opened for writing!).\n\t\t\t * Anon pages in shared mappings are surprising: now\n\t\t\t * just reject it.\n\t\t\t */\n\t\t\tif (!is_cow_mapping(vm_flags))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (!(vm_flags & VM_READ)) {\n\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\treturn -EFAULT;\n\t\t/*\n\t\t * Is there actually any vma we can reach here which does not\n\t\t * have VM_MAYREAD set?\n\t\t */\n\t\tif (!(vm_flags & VM_MAYREAD))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * gups are always data accesses, not instruction\n\t * fetches, so execute=false here\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
                        "cve_id": "CVE-2018-1120"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 3281,
            "cve_id": "CVE-2021-4204",
            "code_snippet": "static int check_func_arg(struct bpf_verifier_env *env, u32 arg,\n\t\t\t  struct bpf_call_arg_meta *meta,\n\t\t\t  const struct bpf_func_proto *fn)\n{\n\tu32 regno = BPF_REG_1 + arg;\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_arg_type arg_type = fn->arg_type[arg];\n\tenum bpf_reg_type type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (base_type(arg_type) == ARG_PTR_TO_MAP_VALUE ||\n\t    base_type(arg_type) == ARG_PTR_TO_UNINIT_MAP_VALUE) {\n\t\terr = resolve_map_arg_type(env, meta, &arg_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (register_is_null(reg) && type_may_be_null(arg_type))\n\t\t/* A NULL register has a SCALAR_VALUE type, so skip\n\t\t * type checking.\n\t\t */\n\t\tgoto skip_type_check;\n\n\terr = check_reg_type(env, regno, arg_type, fn->arg_btf_id[arg]);\n\tif (err)\n\t\treturn err;\n\n\tif (type == PTR_TO_CTX) {\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\nskip_type_check:\n\tif (reg->ref_obj_id) {\n\t\tif (meta->ref_obj_id) {\n\t\t\tverbose(env, \"verifier internal error: more than one arg with ref_obj_id R%d %u %u\\n\",\n\t\t\t\tregno, reg->ref_obj_id,\n\t\t\t\tmeta->ref_obj_id);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tmeta->ref_obj_id = reg->ref_obj_id;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tif (meta->map_ptr) {\n\t\t\t/* Use map_uid (which is unique id of inner map) to reject:\n\t\t\t * inner_map1 = bpf_map_lookup_elem(outer_map, key1)\n\t\t\t * inner_map2 = bpf_map_lookup_elem(outer_map, key2)\n\t\t\t * if (inner_map1 && inner_map2) {\n\t\t\t *     timer = bpf_map_lookup_elem(inner_map1);\n\t\t\t *     if (timer)\n\t\t\t *         // mismatch would have been allowed\n\t\t\t *         bpf_timer_init(timer, inner_map2);\n\t\t\t * }\n\t\t\t *\n\t\t\t * Comparing map_ptr is enough to distinguish normal and outer maps.\n\t\t\t */\n\t\t\tif (meta->map_ptr != reg->map_ptr ||\n\t\t\t    meta->map_uid != reg->map_uid) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"timer pointer in R1 map_uid=%d doesn't match map pointer in R2 map_uid=%d\\n\",\n\t\t\t\t\tmeta->map_uid, reg->map_uid);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tmeta->map_ptr = reg->map_ptr;\n\t\tmeta->map_uid = reg->map_uid;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (base_type(arg_type) == ARG_PTR_TO_MAP_VALUE ||\n\t\t   base_type(arg_type) == ARG_PTR_TO_UNINIT_MAP_VALUE) {\n\t\tif (type_may_be_null(arg_type) && register_is_null(reg))\n\t\t\treturn 0;\n\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->raw_mode = (arg_type == ARG_PTR_TO_UNINIT_MAP_VALUE);\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      meta);\n\t} else if (arg_type == ARG_PTR_TO_PERCPU_BTF_ID) {\n\t\tif (!reg->btf_id) {\n\t\t\tverbose(env, \"Helper has invalid btf_id in R%d\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->ret_btf = reg->btf;\n\t\tmeta->ret_btf_id = reg->btf_id;\n\t} else if (arg_type == ARG_PTR_TO_SPIN_LOCK) {\n\t\tif (meta->func_id == BPF_FUNC_spin_lock) {\n\t\t\tif (process_spin_lock(env, regno, true))\n\t\t\t\treturn -EACCES;\n\t\t} else if (meta->func_id == BPF_FUNC_spin_unlock) {\n\t\t\tif (process_spin_lock(env, regno, false))\n\t\t\t\treturn -EACCES;\n\t\t} else {\n\t\t\tverbose(env, \"verifier internal error\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (arg_type == ARG_PTR_TO_TIMER) {\n\t\tif (process_timer_func(env, regno, meta))\n\t\t\treturn -EACCES;\n\t} else if (arg_type == ARG_PTR_TO_FUNC) {\n\t\tmeta->subprogno = reg->subprogno;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\t/* The access to this pointer is only checked when we hit the\n\t\t * next is_mem_size argument below.\n\t\t */\n\t\tmeta->raw_mode = (arg_type == ARG_PTR_TO_UNINIT_MEM);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* This is used to refine r0 return value bounds for helpers\n\t\t * that enforce this value as an upper bound on return values.\n\t\t * See do_refine_retval_range() for helpers that can refine\n\t\t * the return value. C type of helper is u32 so we pull register\n\t\t * bound from umax_value however, if negative verifier errors\n\t\t * out. Only upper bounds can be learned because retval is an\n\t\t * int type and negative retvals are allowed.\n\t\t */\n\t\tmeta->msize_max_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t\tif (!err)\n\t\t\terr = mark_chain_precision(env, regno);\n\t} else if (arg_type_is_alloc_size(arg_type)) {\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"R%d is not a known constant'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->mem_size = reg->var_off.value;\n\t} else if (arg_type_is_int_ptr(arg_type)) {\n\t\tint size = int_ptr_type_to_size(arg_type);\n\n\t\terr = check_helper_mem_access(env, regno, size, false, meta);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_ptr_alignment(env, reg, 0, size, true);\n\t} else if (arg_type == ARG_PTR_TO_CONST_STR) {\n\t\tstruct bpf_map *map = reg->map_ptr;\n\t\tint map_off;\n\t\tu64 map_addr;\n\t\tchar *str_ptr;\n\n\t\tif (!bpf_map_is_rdonly(map)) {\n\t\t\tverbose(env, \"R%d does not point to a readonly map'\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"R%d is not a constant address'\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!map->ops->map_direct_value_addr) {\n\t\t\tverbose(env, \"no direct value access support for this map type\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_map_access(env, regno, reg->off,\n\t\t\t\t       map->value_size - reg->off, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmap_off = reg->off + reg->var_off.value;\n\t\terr = map->ops->map_direct_value_addr(map, &map_addr, map_off);\n\t\tif (err) {\n\t\t\tverbose(env, \"direct value access on string failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tstr_ptr = (char *)(long)(map_addr);\n\t\tif (!strnchr(str_ptr + map_off, map->value_size - map_off, 0)) {\n\t\t\tverbose(env, \"string is not zero-terminated\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (base_type(reg->type) == PTR_TO_MEM) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\n\t\tif (type_may_be_null(reg->type)) {\n\t\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\t\treg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && rdonly_mem) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && value_regno >= 0 && (t == BPF_READ || rdonly_mem))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf, &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (base_type(reg_type) == PTR_TO_BTF_ID) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = func(env, reg);\n\t\terr = update_stack_depth(env, state, off);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_BTF_ID) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BUF) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\t\tconst char *buf_info;\n\t\tu32 *max_access;\n\n\t\tif (rdonly_mem) {\n\t\t\tif (t == BPF_WRITE) {\n\t\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tbuf_info = \"rdonly\";\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tbuf_info = \"rdwr\";\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  buf_info, max_access);\n\n\t\tif (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
                        "code_after_change": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (base_type(reg->type) == PTR_TO_MEM) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\n\t\tif (type_may_be_null(reg->type)) {\n\t\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\t\treg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && rdonly_mem) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && value_regno >= 0 && (t == BPF_READ || rdonly_mem))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ptr_off_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf, &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (base_type(reg_type) == PTR_TO_BTF_ID) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = func(env, reg);\n\t\terr = update_stack_depth(env, state, off);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_BTF_ID) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BUF) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\t\tconst char *buf_info;\n\t\tu32 *max_access;\n\n\t\tif (rdonly_mem) {\n\t\t\tif (t == BPF_WRITE) {\n\t\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tbuf_info = \"rdonly\";\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tbuf_info = \"rdwr\";\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  buf_info, max_access);\n\n\t\tif (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
                        "cve_id": "CVE-2021-4204"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ctx_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve_ret = btf_resolve_size(btf, ref_t, &type_size);\n\t\t\tif (IS_ERR(resolve_ret)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t\ti, btf_type_str(ref_t), ref_tname,\n\t\t\t\t\tPTR_ERR(resolve_ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (check_mem_reg(env, reg, regno, type_size))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tbpf_log(log, \"reg type unsupported for arg#%d %sfunction %s#%d\\n\", i,\n\t\t\t\tis_kfunc ? \"kernel \" : \"\", func_name, func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ptr_off_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve_ret = btf_resolve_size(btf, ref_t, &type_size);\n\t\t\tif (IS_ERR(resolve_ret)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t\ti, btf_type_str(ref_t), ref_tname,\n\t\t\t\t\tPTR_ERR(resolve_ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (check_mem_reg(env, reg, regno, type_size))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tbpf_log(log, \"reg type unsupported for arg#%d %sfunction %s#%d\\n\", i,\n\t\t\t\tis_kfunc ? \"kernel \" : \"\", func_name, func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2021-4204"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t\tregs[insn->dst_reg].live |= REG_LIVE_WRITTEN;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\t/* high 32 bits are known zero. */\n\t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(\n\t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);\n\t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t\tregs[insn->dst_reg].live |= REG_LIVE_WRITTEN;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\tcoerce_reg_to_size(&regs[insn->dst_reg], 4);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-16996"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 3795,
            "cve_id": "CVE-2022-3625",
            "code_snippet": "static int devlink_param_set(struct devlink *devlink,\n\t\t\t     const struct devlink_param *param,\n\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tif (!param->set)\n\t\treturn -EOPNOTSUPP;\n\treturn param->set(devlink, param->id, ctx);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int devlink_param_get(struct devlink *devlink,\n\t\t\t     const struct devlink_param *param,\n\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tif (!param->get)\n\t\treturn -EOPNOTSUPP;\n\treturn param->get(devlink, param->id, ctx);\n}",
                        "code_after_change": "static int devlink_param_get(struct devlink *devlink,\n\t\t\t     const struct devlink_param *param,\n\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tif (!param->get || devlink->reload_failed)\n\t\treturn -EOPNOTSUPP;\n\treturn param->get(devlink, param->id, ctx);\n}",
                        "cve_id": "CVE-2022-3625"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        }
    ],
    "non_vul_data": [
        {
            "id": 5,
            "cve_id": "CVE-2007-6761",
            "code_snippet": "static void\nvideobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\n\tdprintk(2,\"vm_close %p [count=%u,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}",
                        "code_after_change": "static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}",
                        "cve_id": "CVE-2007-6761"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 29,
            "cve_id": "CVE-2010-5332",
            "code_snippet": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
                        "code_after_change": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
                        "cve_id": "CVE-2010-5332"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 31,
            "cve_id": "CVE-2011-4098",
            "code_snippet": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tunsigned int nr_blks;\n\tsector_t lblock = offset >> inode->i_blkbits;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\n\twhile (len) {\n\t\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\t\tbh_map.b_size = len;\n\t\tset_buffer_zeronew(&bh_map);\n\n\t\terror = gfs2_block_map(inode, lblock, &bh_map, 1);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t\tlen -= bh_map.b_size;\n\t\tnr_blks = bh_map.b_size >> inode->i_blkbits;\n\t\tlblock += nr_blks;\n\t\tif (!buffer_new(&bh_map))\n\t\t\tcontinue;\n\t\tif (unlikely(!buffer_zeronew(&bh_map))) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (offset + len > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))\n\t\ti_size_write(inode, offset + len);\n\n\tmark_inode_dirty(inode);\n\nout:\n\tbrelse(dibh);\n\treturn error;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const unsigned int maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, ptrs_per_blk - mp->mp_list[end_of_metadata]);\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_block(ip, &bn, &n);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[i-1], 1);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[end_of_metadata], 1);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}",
                        "code_after_change": "static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const unsigned int maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint ret;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, ptrs_per_blk - mp->mp_list[end_of_metadata]);\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_block(ip, &bn, &n);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[i-1], 1);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[end_of_metadata], 1);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tif (buffer_zeronew(bh_map)) {\n\t\t\t\tret = sb_issue_zeroout(sb, dblock, dblks,\n\t\t\t\t\t\t       GFP_NOFS);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfs_err(sdp,\n\t\t\t\t\t       \"Failed to zero data buffers\\n\");\n\t\t\t\t\tclear_buffer_zeronew(bh_map);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}",
                        "cve_id": "CVE-2011-4098"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 55,
            "cve_id": "CVE-2012-3364",
            "code_snippet": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);\n\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\n\treturn data;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = *data++;\n\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\n\treturn data;\n}",
                        "code_after_change": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = min_t(__u8, *data++, NFC_SENSB_RES_MAXSIZE);\n\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\n\treturn data;\n}",
                        "cve_id": "CVE-2012-3364"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 148,
            "cve_id": "CVE-2012-6712",
            "code_snippet": "static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (sta_id >= IWLAGN_STATION_COUNT) {\n\t\tIWL_ERR(priv, \"invalid sta_id %u\", sta_id);\n\t\treturn -EINVAL;\n\t}\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tiwl_sta_ucode_activate(priv, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\n\t/*\n\t * XXX: The MAC address in the command buffer is often changed from\n\t * the original sent to the device. That is, the MAC address\n\t * written to the command buffer often is not the same MAC address\n\t * read from the command buffer when the command returns. This\n\t * issue has not yet been resolved and this debugging is left to\n\t * observe the problem.\n\t */\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn ret;\n}",
                        "code_after_change": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tret = iwl_sta_ucode_activate(priv, sta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\n\t/*\n\t * XXX: The MAC address in the command buffer is often changed from\n\t * the original sent to the device. That is, the MAC address\n\t * written to the command buffer often is not the same MAC address\n\t * read from the command buffer when the command returns. This\n\t * issue has not yet been resolved and this debugging is left to\n\t * observe the problem.\n\t */\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn ret;\n}",
                        "cve_id": "CVE-2012-6712"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 156,
            "cve_id": "CVE-2013-0231",
            "code_snippet": "int xen_pcibk_enable_msix(struct xen_pcibk_device *pdev,\n\t\t\t  struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint i, result;\n\tstruct msix_entry *entries;\n\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable MSI-X\\n\",\n\t\t       pci_name(dev));\n\tif (op->value > SH_INFO_MAX_VEC)\n\t\treturn -EINVAL;\n\n\tentries = kmalloc(op->value * sizeof(*entries), GFP_KERNEL);\n\tif (entries == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < op->value; i++) {\n\t\tentries[i].entry = op->msix_entries[i].entry;\n\t\tentries[i].vector = op->msix_entries[i].vector;\n\t}\n\n\tresult = pci_enable_msix(dev, entries, op->value);\n\n\tif (result == 0) {\n\t\tfor (i = 0; i < op->value; i++) {\n\t\t\top->msix_entries[i].entry = entries[i].entry;\n\t\t\tif (entries[i].vector)\n\t\t\t\top->msix_entries[i].vector =\n\t\t\t\t\txen_pirq_from_irq(entries[i].vector);\n\t\t\t\tif (unlikely(verbose_request))\n\t\t\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: \" \\\n\t\t\t\t\t\t\"MSI-X[%d]: %d\\n\",\n\t\t\t\t\t\tpci_name(dev), i,\n\t\t\t\t\t\top->msix_entries[i].vector);\n\t\t}\n\t} else\n\t\tpr_warn_ratelimited(DRV_NAME \": %s: error enabling MSI-X for guest %u: err %d!\\n\",\n\t\t\t\t    pci_name(dev), pdev->xdev->otherend_id,\n\t\t\t\t    result);\n\tkfree(entries);\n\n\top->value = result;\n\tdev_data = pci_get_drvdata(dev);\n\tif (dev_data)\n\t\tdev_data->ack_intr = 0;\n\n\treturn result > 0 ? 0 : result;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int xen_pcibk_enable_msi(struct xen_pcibk_device *pdev,\n\t\t\t struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint otherend = pdev->xdev->otherend_id;\n\tint status;\n\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable MSI\\n\", pci_name(dev));\n\n\tstatus = pci_enable_msi(dev);\n\n\tif (status) {\n\t\tprintk(KERN_ERR \"error enable msi for guest %x status %x\\n\",\n\t\t\totherend, status);\n\t\top->value = 0;\n\t\treturn XEN_PCI_ERR_op_failed;\n\t}\n\n\t/* The value the guest needs is actually the IDT vector, not the\n\t * the local domain's IRQ number. */\n\n\top->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: MSI: %d\\n\", pci_name(dev),\n\t\t\top->value);\n\n\tdev_data = pci_get_drvdata(dev);\n\tif (dev_data)\n\t\tdev_data->ack_intr = 0;\n\n\treturn 0;\n}",
                        "code_after_change": "int xen_pcibk_enable_msi(struct xen_pcibk_device *pdev,\n\t\t\t struct pci_dev *dev, struct xen_pci_op *op)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint status;\n\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable MSI\\n\", pci_name(dev));\n\n\tstatus = pci_enable_msi(dev);\n\n\tif (status) {\n\t\tpr_warn_ratelimited(DRV_NAME \": %s: error enabling MSI for guest %u: err %d\\n\",\n\t\t\t\t    pci_name(dev), pdev->xdev->otherend_id,\n\t\t\t\t    status);\n\t\top->value = 0;\n\t\treturn XEN_PCI_ERR_op_failed;\n\t}\n\n\t/* The value the guest needs is actually the IDT vector, not the\n\t * the local domain's IRQ number. */\n\n\top->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG DRV_NAME \": %s: MSI: %d\\n\", pci_name(dev),\n\t\t\top->value);\n\n\tdev_data = pci_get_drvdata(dev);\n\tif (dev_data)\n\t\tdev_data->ack_intr = 0;\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2013-0231"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
                        "code_after_change": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
                        "cve_id": "CVE-2010-5332"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int lg4ff_init(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tstruct usb_device_descriptor *udesc;\n\tint error, i, j;\n\t__u16 bcdDevice, rev_maj, rev_min;\n\n\t/* Find the report to use */\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"No output report found\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Check that the report looks ok */\n\treport = list_entry(report_list->next, struct hid_report, list);\n\tif (!report) {\n\t\thid_err(hid, \"NULL output report\\n\");\n\t\treturn -1;\n\t}\n\n\tfield = report->field[0];\n\tif (!field) {\n\t\thid_err(hid, \"NULL field\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Check what wheel has been connected */\n\tfor (i = 0; i < ARRAY_SIZE(lg4ff_devices); i++) {\n\t\tif (hid->product == lg4ff_devices[i].product_id) {\n\t\t\tdbg_hid(\"Found compatible device, product ID %04X\\n\", lg4ff_devices[i].product_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(lg4ff_devices)) {\n\t\thid_err(hid, \"Device is not supported by lg4ff driver. If you think it should be, consider reporting a bug to\"\n\t\t\t     \"LKML, Simon Wood <simon@mungewell.org> or Michal Maly <madcatxster@gmail.com>\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Attempt to switch wheel to native mode when applicable */\n\tudesc = &(hid_to_usb_dev(hid)->descriptor);\n\tif (!udesc) {\n\t\thid_err(hid, \"NULL USB device descriptor\\n\");\n\t\treturn -1;\n\t}\n\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\trev_maj = bcdDevice >> 8;\n\trev_min = bcdDevice & 0xff;\n\n\tif (lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_WHEEL) {\n\t\tdbg_hid(\"Generic wheel detected, can it do native?\\n\");\n\t\tdbg_hid(\"USB revision: %2x.%02x\\n\", rev_maj, rev_min);\n\n\t\tfor (j = 0; j < ARRAY_SIZE(lg4ff_revs); j++) {\n\t\t\tif (lg4ff_revs[j].rev_maj == rev_maj && lg4ff_revs[j].rev_min == rev_min) {\n\t\t\t\thid_lg4ff_switch_native(hid, lg4ff_revs[j].command);\n\t\t\t\thid_info(hid, \"Switched to native mode\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set supported force feedback capabilities */\n\tfor (j = 0; lg4ff_devices[i].ff_effects[j] >= 0; j++)\n\t\tset_bit(lg4ff_devices[i].ff_effects[j], dev->ffbit);\n\n\terror = input_ff_create_memless(dev, NULL, hid_lg4ff_play);\n\n\tif (error)\n\t\treturn error;\n\n\t/* Check if autocentering is available and\n\t * set the centering force to zero by default */\n\tif (test_bit(FF_AUTOCENTER, dev->ffbit)) {\n\t\tif (rev_maj == FFEX_REV_MAJ && rev_min == FFEX_REV_MIN)\t/* Formula Force EX expects different autocentering command */\n\t\t\tdev->ff->set_autocenter = hid_lg4ff_set_autocenter_ffex;\n\t\telse\n\t\t\tdev->ff->set_autocenter = hid_lg4ff_set_autocenter_default;\n\n\t\tdev->ff->set_autocenter(dev, 0);\n\t}\n\n\t/* Get private driver data */\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Cannot add device, private driver data not allocated\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize device properties */\n\tentry = kzalloc(sizeof(struct lg4ff_device_entry), GFP_KERNEL);\n\tif (!entry) {\n\t\thid_err(hid, \"Cannot add device, insufficient memory to allocate device properties.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdrv_data->device_props = entry;\n\n\tentry->product_id = lg4ff_devices[i].product_id;\n\tentry->min_range = lg4ff_devices[i].min_range;\n\tentry->max_range = lg4ff_devices[i].max_range;\n\tentry->set_range = lg4ff_devices[i].set_range;\n\n\t/* Create sysfs interface */\n\terror = device_create_file(&hid->dev, &dev_attr_range);\n\tif (error)\n\t\treturn error;\n\tdbg_hid(\"sysfs interface created\\n\");\n\n\t/* Set the maximum range to start with */\n\tentry->range = entry->max_range;\n\tif (entry->set_range != NULL)\n\t\tentry->set_range(hid, entry->range);\n\n#ifdef CONFIG_LEDS_CLASS\n\t/* register led subsystem - G27 only */\n\tentry->led_state = 0;\n\tfor (j = 0; j < 5; j++)\n\t\tentry->led[j] = NULL;\n\n\tif (lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_G27_WHEEL) {\n\t\tstruct led_classdev *led;\n\t\tsize_t name_sz;\n\t\tchar *name;\n\n\t\tlg4ff_set_leds(hid, 0);\n\n\t\tname_sz = strlen(dev_name(&hid->dev)) + 8;\n\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\n\t\t\tif (!led) {\n\t\t\t\thid_err(hid, \"can't allocate memory for LED %d\\n\", j);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tname = (void *)(&led[1]);\n\t\t\tsnprintf(name, name_sz, \"%s::RPM%d\", dev_name(&hid->dev), j+1);\n\t\t\tled->name = name;\n\t\t\tled->brightness = 0;\n\t\t\tled->max_brightness = 1;\n\t\t\tled->brightness_get = lg4ff_led_get_brightness;\n\t\t\tled->brightness_set = lg4ff_led_set_brightness;\n\n\t\t\tentry->led[j] = led;\n\t\t\terror = led_classdev_register(&hid->dev, led);\n\n\t\t\tif (error) {\n\t\t\t\thid_err(hid, \"failed to register LED %d. Aborting.\\n\", j);\nerr:\n\t\t\t\t/* Deregister LEDs (if any) */\n\t\t\t\tfor (j = 0; j < 5; j++) {\n\t\t\t\t\tled = entry->led[j];\n\t\t\t\t\tentry->led[j] = NULL;\n\t\t\t\t\tif (!led)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tled_classdev_unregister(led);\n\t\t\t\t\tkfree(led);\n\t\t\t\t}\n\t\t\t\tgoto out;\t/* Let the driver continue without LEDs */\n\t\t\t}\n\t\t}\n\t}\nout:\n#endif\n\thid_info(hid, \"Force feedback support for Logitech Gaming Wheels\\n\");\n\treturn 0;\n}",
                        "code_after_change": "int lg4ff_init(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tstruct usb_device_descriptor *udesc;\n\tint error, i, j;\n\t__u16 bcdDevice, rev_maj, rev_min;\n\n\t/* Check that the report looks ok */\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\treturn -1;\n\n\t/* Check what wheel has been connected */\n\tfor (i = 0; i < ARRAY_SIZE(lg4ff_devices); i++) {\n\t\tif (hid->product == lg4ff_devices[i].product_id) {\n\t\t\tdbg_hid(\"Found compatible device, product ID %04X\\n\", lg4ff_devices[i].product_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(lg4ff_devices)) {\n\t\thid_err(hid, \"Device is not supported by lg4ff driver. If you think it should be, consider reporting a bug to\"\n\t\t\t     \"LKML, Simon Wood <simon@mungewell.org> or Michal Maly <madcatxster@gmail.com>\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Attempt to switch wheel to native mode when applicable */\n\tudesc = &(hid_to_usb_dev(hid)->descriptor);\n\tif (!udesc) {\n\t\thid_err(hid, \"NULL USB device descriptor\\n\");\n\t\treturn -1;\n\t}\n\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\trev_maj = bcdDevice >> 8;\n\trev_min = bcdDevice & 0xff;\n\n\tif (lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_WHEEL) {\n\t\tdbg_hid(\"Generic wheel detected, can it do native?\\n\");\n\t\tdbg_hid(\"USB revision: %2x.%02x\\n\", rev_maj, rev_min);\n\n\t\tfor (j = 0; j < ARRAY_SIZE(lg4ff_revs); j++) {\n\t\t\tif (lg4ff_revs[j].rev_maj == rev_maj && lg4ff_revs[j].rev_min == rev_min) {\n\t\t\t\thid_lg4ff_switch_native(hid, lg4ff_revs[j].command);\n\t\t\t\thid_info(hid, \"Switched to native mode\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set supported force feedback capabilities */\n\tfor (j = 0; lg4ff_devices[i].ff_effects[j] >= 0; j++)\n\t\tset_bit(lg4ff_devices[i].ff_effects[j], dev->ffbit);\n\n\terror = input_ff_create_memless(dev, NULL, hid_lg4ff_play);\n\n\tif (error)\n\t\treturn error;\n\n\t/* Check if autocentering is available and\n\t * set the centering force to zero by default */\n\tif (test_bit(FF_AUTOCENTER, dev->ffbit)) {\n\t\tif (rev_maj == FFEX_REV_MAJ && rev_min == FFEX_REV_MIN)\t/* Formula Force EX expects different autocentering command */\n\t\t\tdev->ff->set_autocenter = hid_lg4ff_set_autocenter_ffex;\n\t\telse\n\t\t\tdev->ff->set_autocenter = hid_lg4ff_set_autocenter_default;\n\n\t\tdev->ff->set_autocenter(dev, 0);\n\t}\n\n\t/* Get private driver data */\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Cannot add device, private driver data not allocated\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize device properties */\n\tentry = kzalloc(sizeof(struct lg4ff_device_entry), GFP_KERNEL);\n\tif (!entry) {\n\t\thid_err(hid, \"Cannot add device, insufficient memory to allocate device properties.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdrv_data->device_props = entry;\n\n\tentry->product_id = lg4ff_devices[i].product_id;\n\tentry->min_range = lg4ff_devices[i].min_range;\n\tentry->max_range = lg4ff_devices[i].max_range;\n\tentry->set_range = lg4ff_devices[i].set_range;\n\n\t/* Create sysfs interface */\n\terror = device_create_file(&hid->dev, &dev_attr_range);\n\tif (error)\n\t\treturn error;\n\tdbg_hid(\"sysfs interface created\\n\");\n\n\t/* Set the maximum range to start with */\n\tentry->range = entry->max_range;\n\tif (entry->set_range != NULL)\n\t\tentry->set_range(hid, entry->range);\n\n#ifdef CONFIG_LEDS_CLASS\n\t/* register led subsystem - G27 only */\n\tentry->led_state = 0;\n\tfor (j = 0; j < 5; j++)\n\t\tentry->led[j] = NULL;\n\n\tif (lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_G27_WHEEL) {\n\t\tstruct led_classdev *led;\n\t\tsize_t name_sz;\n\t\tchar *name;\n\n\t\tlg4ff_set_leds(hid, 0);\n\n\t\tname_sz = strlen(dev_name(&hid->dev)) + 8;\n\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\n\t\t\tif (!led) {\n\t\t\t\thid_err(hid, \"can't allocate memory for LED %d\\n\", j);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tname = (void *)(&led[1]);\n\t\t\tsnprintf(name, name_sz, \"%s::RPM%d\", dev_name(&hid->dev), j+1);\n\t\t\tled->name = name;\n\t\t\tled->brightness = 0;\n\t\t\tled->max_brightness = 1;\n\t\t\tled->brightness_get = lg4ff_led_get_brightness;\n\t\t\tled->brightness_set = lg4ff_led_set_brightness;\n\n\t\t\tentry->led[j] = led;\n\t\t\terror = led_classdev_register(&hid->dev, led);\n\n\t\t\tif (error) {\n\t\t\t\thid_err(hid, \"failed to register LED %d. Aborting.\\n\", j);\nerr:\n\t\t\t\t/* Deregister LEDs (if any) */\n\t\t\t\tfor (j = 0; j < 5; j++) {\n\t\t\t\t\tled = entry->led[j];\n\t\t\t\t\tentry->led[j] = NULL;\n\t\t\t\t\tif (!led)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tled_classdev_unregister(led);\n\t\t\t\t\tkfree(led);\n\t\t\t\t}\n\t\t\t\tgoto out;\t/* Let the driver continue without LEDs */\n\t\t\t}\n\t\t}\n\t}\nout:\n#endif\n\thid_info(hid, \"Force feedback support for Logitech Gaming Wheels\\n\");\n\treturn 0;\n}",
                        "cve_id": "CVE-2013-2893"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 160,
            "cve_id": "CVE-2013-0309",
            "code_snippet": "static inline int pmd_large(pmd_t pte)\n{\n\treturn pmd_flags(pte) & _PAGE_PSE;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}",
                        "code_after_change": "static inline int pmd_present(pmd_t pmd)\n{\n\t/*\n\t * Checking for _PAGE_PSE is needed too because\n\t * split_huge_page will temporarily clear the present bit (but\n\t * the _PAGE_PSE flag will remain set at all times while the\n\t * _PAGE_PRESENT bit is clear).\n\t */\n\treturn pmd_flags(pmd) & (_PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE);\n}",
                        "cve_id": "CVE-2013-0309"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 175,
            "cve_id": "CVE-2013-1772",
            "code_snippet": "void console_unlock(void)\n{\n\tstatic u64 seen_seq;\n\tunsigned long flags;\n\tbool wake_klogd = false;\n\tbool retry;\n\n\tif (console_suspended) {\n\t\tup(&console_sem);\n\t\treturn;\n\t}\n\n\tconsole_may_schedule = 0;\n\nagain:\n\tfor (;;) {\n\t\tstruct log *msg;\n\t\tstatic char text[LOG_LINE_MAX];\n\t\tsize_t len;\n\t\tint level;\n\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tif (seen_seq != log_next_seq) {\n\t\t\twake_klogd = true;\n\t\t\tseen_seq = log_next_seq;\n\t\t}\n\n\t\tif (console_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t}\n\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tlevel = msg->level & 7;\n\t\tlen = msg->text_len;\n\t\tif (len+1 >= sizeof(text))\n\t\t\tlen = sizeof(text)-1;\n\t\tmemcpy(text, log_text(msg), len);\n\t\ttext[len++] = '\\n';\n\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(level, text, len);\n\t\tstart_critical_timings();\n\t\tlocal_irq_restore(flags);\n\t}\n\tconsole_locked = 0;\n\n\t/* Release the exclusive_console once it is used */\n\tif (unlikely(exclusive_console))\n\t\texclusive_console = NULL;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup(&console_sem);\n\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n\n\tif (wake_klogd)\n\t\twake_up_klogd();\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void register_console(struct console *newcon)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct console *bcon = NULL;\n\n\t/*\n\t * before we register a new CON_BOOT console, make sure we don't\n\t * already have a valid console\n\t */\n\tif (console_drivers && newcon->flags & CON_BOOT) {\n\t\t/* find the last or real console */\n\t\tfor_each_console(bcon) {\n\t\t\tif (!(bcon->flags & CON_BOOT)) {\n\t\t\t\tprintk(KERN_INFO \"Too late to register bootconsole %s%d\\n\",\n\t\t\t\t\tnewcon->name, newcon->index);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (console_drivers && console_drivers->flags & CON_BOOT)\n\t\tbcon = console_drivers;\n\n\tif (preferred_console < 0 || bcon || !console_drivers)\n\t\tpreferred_console = selected_console;\n\n\tif (newcon->early_setup)\n\t\tnewcon->early_setup();\n\n\t/*\n\t *\tSee if we want to use this console driver. If we\n\t *\tdidn't select a console we take the first one\n\t *\tthat registers here.\n\t */\n\tif (preferred_console < 0) {\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = 0;\n\t\tif (newcon->setup == NULL ||\n\t\t    newcon->setup(newcon, NULL) == 0) {\n\t\t\tnewcon->flags |= CON_ENABLED;\n\t\t\tif (newcon->device) {\n\t\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\t\tpreferred_console = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tSee if this console matches one we selected on\n\t *\tthe command line.\n\t */\n\tfor (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0];\n\t\t\ti++) {\n\t\tif (strcmp(console_cmdline[i].name, newcon->name) != 0)\n\t\t\tcontinue;\n\t\tif (newcon->index >= 0 &&\n\t\t    newcon->index != console_cmdline[i].index)\n\t\t\tcontinue;\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = console_cmdline[i].index;\n#ifdef CONFIG_A11Y_BRAILLE_CONSOLE\n\t\tif (console_cmdline[i].brl_options) {\n\t\t\tnewcon->flags |= CON_BRL;\n\t\t\tbraille_register_console(newcon,\n\t\t\t\t\tconsole_cmdline[i].index,\n\t\t\t\t\tconsole_cmdline[i].options,\n\t\t\t\t\tconsole_cmdline[i].brl_options);\n\t\t\treturn;\n\t\t}\n#endif\n\t\tif (newcon->setup &&\n\t\t    newcon->setup(newcon, console_cmdline[i].options) != 0)\n\t\t\tbreak;\n\t\tnewcon->flags |= CON_ENABLED;\n\t\tnewcon->index = console_cmdline[i].index;\n\t\tif (i == selected_console) {\n\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\t\tpreferred_console = selected_console;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(newcon->flags & CON_ENABLED))\n\t\treturn;\n\n\t/*\n\t * If we have a bootconsole, and are switching to a real console,\n\t * don't print everything out again, since when the boot console, and\n\t * the real console are the same physical device, it's annoying to\n\t * see the beginning boot messages twice\n\t */\n\tif (bcon && ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))\n\t\tnewcon->flags &= ~CON_PRINTBUFFER;\n\n\t/*\n\t *\tPut this console in the list - keep the\n\t *\tpreferred driver at the head of the list.\n\t */\n\tconsole_lock();\n\tif ((newcon->flags & CON_CONSDEV) || console_drivers == NULL) {\n\t\tnewcon->next = console_drivers;\n\t\tconsole_drivers = newcon;\n\t\tif (newcon->next)\n\t\t\tnewcon->next->flags &= ~CON_CONSDEV;\n\t} else {\n\t\tnewcon->next = console_drivers->next;\n\t\tconsole_drivers->next = newcon;\n\t}\n\tif (newcon->flags & CON_PRINTBUFFER) {\n\t\t/*\n\t\t * console_unlock(); will print out the buffered messages\n\t\t * for us.\n\t\t */\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tcon_start = log_start;\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\t\t/*\n\t\t * We're about to replay the log buffer.  Only do this to the\n\t\t * just-registered console to avoid excessive message spam to\n\t\t * the already-registered consoles.\n\t\t */\n\t\texclusive_console = newcon;\n\t}\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\t/*\n\t * By unregistering the bootconsoles after we enable the real console\n\t * we get the \"console xxx enabled\" message on all the consoles -\n\t * boot consoles, real consoles, etc - this is to ensure that end\n\t * users know there might be something in the kernel's log buffer that\n\t * went to the bootconsole (that they do not see on the real console)\n\t */\n\tif (bcon &&\n\t    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &&\n\t    !keep_bootcon) {\n\t\t/* we need to iterate through twice, to make sure we print\n\t\t * everything out, before we unregister the console(s)\n\t\t */\n\t\tprintk(KERN_INFO \"console [%s%d] enabled, bootconsole disabled\\n\",\n\t\t\tnewcon->name, newcon->index);\n\t\tfor_each_console(bcon)\n\t\t\tif (bcon->flags & CON_BOOT)\n\t\t\t\tunregister_console(bcon);\n\t} else {\n\t\tprintk(KERN_INFO \"%sconsole [%s%d] enabled\\n\",\n\t\t\t(newcon->flags & CON_BOOT) ? \"boot\" : \"\" ,\n\t\t\tnewcon->name, newcon->index);\n\t}\n}",
                        "code_after_change": "int do_syslog(int type, char __user *buf, int len, bool from_file)\n{\n\tbool clear = false;\n\tstatic int saved_console_loglevel = -1;\n\tint error;\n\n\terror = check_syslog_permissions(type, from_file);\n\tif (error)\n\t\tgoto out;\n\n\terror = security_syslog(type);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase SYSLOG_ACTION_CLOSE:\t/* Close log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_OPEN:\t/* Open log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_READ:\t/* Read from log */\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terror = wait_event_interruptible(log_wait,\n\t\t\t\t\t\t syslog_seq != log_next_seq);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = syslog_print(buf, len);\n\t\tbreak;\n\t/* Read/clear last kernel messages */\n\tcase SYSLOG_ACTION_READ_CLEAR:\n\t\tclear = true;\n\t\t/* FALL THRU */\n\t/* Read last kernel messages */\n\tcase SYSLOG_ACTION_READ_ALL:\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terror = syslog_print_all(buf, len, clear);\n\t\tbreak;\n\t/* Clear ring buffer */\n\tcase SYSLOG_ACTION_CLEAR:\n\t\tsyslog_print_all(NULL, 0, true);\n\t/* Disable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_OFF:\n\t\tif (saved_console_loglevel == -1)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t/* Enable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_ON:\n\t\tif (saved_console_loglevel != -1) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = -1;\n\t\t}\n\t\tbreak;\n\t/* Set level of messages printed to console */\n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\terror = -EINVAL;\n\t\tif (len < 1 || len > 8)\n\t\t\tgoto out;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t/* Implicitly re-enable logging to console */\n\t\tsaved_console_loglevel = -1;\n\t\terror = 0;\n\t\tbreak;\n\t/* Number of chars in the log buffer */\n\tcase SYSLOG_ACTION_SIZE_UNREAD:\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t}\n\t\tif (from_file) {\n\t\t\t/*\n\t\t\t * Short-cut for poll(/\"proc/kmsg\") which simply checks\n\t\t\t * for pending data, not the size; return the count of\n\t\t\t * records, not the length.\n\t\t\t */\n\t\t\terror = log_next_idx - syslog_idx;\n\t\t} else {\n\t\t\tu64 seq;\n\t\t\tu32 idx;\n\n\t\t\terror = 0;\n\t\t\tseq = syslog_seq;\n\t\t\tidx = syslog_idx;\n\t\t\twhile (seq < log_next_seq) {\n\t\t\t\terror += syslog_print_line(idx, NULL, 0);\n\t\t\t\tidx = log_next(idx);\n\t\t\t\tseq++;\n\t\t\t}\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tbreak;\n\t/* Size of the log buffer */\n\tcase SYSLOG_ACTION_SIZE_BUFFER:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\treturn error;\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 176,
            "cve_id": "CVE-2013-1772",
            "code_snippet": "void __init setup_log_buf(int early)\n{\n\tunsigned long flags;\n\tchar *new_log_buf;\n\tint free;\n\n\tif (!new_log_buf_len)\n\t\treturn;\n\n\tif (early) {\n\t\tunsigned long mem;\n\n\t\tmem = memblock_alloc(new_log_buf_len, PAGE_SIZE);\n\t\tif (!mem)\n\t\t\treturn;\n\t\tnew_log_buf = __va(mem);\n\t} else {\n\t\tnew_log_buf = alloc_bootmem_nopanic(new_log_buf_len);\n\t}\n\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"log_buf_len: %ld bytes not available\\n\",\n\t\t\tnew_log_buf_len);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\tfree = __LOG_BUF_LEN - log_next_idx;\n\tmemcpy(log_buf, __log_buf, __LOG_BUF_LEN);\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tpr_info(\"log_buf_len: %d\\n\", log_buf_len);\n\tpr_info(\"early log buf free: %d(%d%%)\\n\",\n\t\tfree, (free * 100) / __LOG_BUF_LEN);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tunsigned long end;\n\tunsigned chars;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tend = log_end & LOG_BUF_MASK;\n\tchars = logged_chars;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (chars > end) {\n\t\ts1 = log_buf + log_buf_len - chars + end;\n\t\tl1 = chars - end;\n\n\t\ts2 = log_buf;\n\t\tl2 = end;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + end - chars;\n\t\tl2 = chars;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "code_after_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tu64 idx;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tif (syslog_seq < log_first_seq)\n\t\tidx = syslog_idx;\n\telse\n\t\tidx = log_first_idx;\n\n\tif (idx > log_next_idx) {\n\t\ts1 = log_buf;\n\t\tl1 = log_next_idx;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_buf_len - idx;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_next_idx - idx;\n\t}\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 177,
            "cve_id": "CVE-2013-1772",
            "code_snippet": "void kdb_syslog_data(char *syslog_data[4])\n{\n\tsyslog_data[0] = log_buf;\n\tsyslog_data[1] = log_buf + log_buf_len;\n\tsyslog_data[2] = log_buf + log_first_idx;\n\tsyslog_data[3] = log_buf + log_next_idx;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tunsigned long end;\n\tunsigned chars;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tend = log_end & LOG_BUF_MASK;\n\tchars = logged_chars;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (chars > end) {\n\t\ts1 = log_buf + log_buf_len - chars + end;\n\t\tl1 = chars - end;\n\n\t\ts2 = log_buf;\n\t\tl2 = end;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + end - chars;\n\t\tl2 = chars;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "code_after_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tu64 idx;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tif (syslog_seq < log_first_seq)\n\t\tidx = syslog_idx;\n\telse\n\t\tidx = log_first_idx;\n\n\tif (idx > log_next_idx) {\n\t\ts1 = log_buf;\n\t\tl1 = log_next_idx;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_buf_len - idx;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_next_idx - idx;\n\t}\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 178,
            "cve_id": "CVE-2013-1772",
            "code_snippet": "void log_buf_kexec_setup(void)\n{\n\tVMCOREINFO_SYMBOL(log_buf);\n\tVMCOREINFO_SYMBOL(log_buf_len);\n\tVMCOREINFO_SYMBOL(log_first_idx);\n\tVMCOREINFO_SYMBOL(log_next_idx);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tunsigned long end;\n\tunsigned chars;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tend = log_end & LOG_BUF_MASK;\n\tchars = logged_chars;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (chars > end) {\n\t\ts1 = log_buf + log_buf_len - chars + end;\n\t\tl1 = chars - end;\n\n\t\ts2 = log_buf;\n\t\tl2 = end;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + end - chars;\n\t\tl2 = chars;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "code_after_change": "void kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tu64 idx;\n\tstruct kmsg_dumper *dumper;\n\tconst char *s1, *s2;\n\tunsigned long l1, l2;\n\tunsigned long flags;\n\n\tif ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)\n\t\treturn;\n\n\t/* Theoretically, the log could move on after we do this, but\n\t   there's not a lot we can do about that. The new messages\n\t   will overwrite the start of what we dump. */\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tif (syslog_seq < log_first_seq)\n\t\tidx = syslog_idx;\n\telse\n\t\tidx = log_first_idx;\n\n\tif (idx > log_next_idx) {\n\t\ts1 = log_buf;\n\t\tl1 = log_next_idx;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_buf_len - idx;\n\t} else {\n\t\ts1 = \"\";\n\t\tl1 = 0;\n\n\t\ts2 = log_buf + idx;\n\t\tl2 = log_next_idx - idx;\n\t}\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list)\n\t\tdumper->dump(dumper, reason, s1, l1, s2, l2);\n\trcu_read_unlock();\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int do_syslog(int type, char __user *buf, int len, bool from_file)\n{\n\tunsigned i, j, limit, count;\n\tint do_clear = 0;\n\tchar c;\n\tint error;\n\n\terror = check_syslog_permissions(type, from_file);\n\tif (error)\n\t\tgoto out;\n\n\terror = security_syslog(type);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase SYSLOG_ACTION_CLOSE:\t/* Close log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_OPEN:\t/* Open log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_READ:\t/* Read from log */\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terror = wait_event_interruptible(log_wait,\n\t\t\t\t\t\t\t(log_start - log_end));\n\t\tif (error)\n\t\t\tgoto out;\n\t\ti = 0;\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\twhile (!error && (log_start != log_end) && i < len) {\n\t\t\tc = LOG_BUF(log_start);\n\t\t\tlog_start++;\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\terror = __put_user(c,buf);\n\t\t\tbuf++;\n\t\t\ti++;\n\t\t\tcond_resched();\n\t\t\traw_spin_lock_irq(&logbuf_lock);\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tif (!error)\n\t\t\terror = i;\n\t\tbreak;\n\t/* Read/clear last kernel messages */\n\tcase SYSLOG_ACTION_READ_CLEAR:\n\t\tdo_clear = 1;\n\t\t/* FALL THRU */\n\t/* Read last kernel messages */\n\tcase SYSLOG_ACTION_READ_ALL:\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tcount = len;\n\t\tif (count > log_buf_len)\n\t\t\tcount = log_buf_len;\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\tif (count > logged_chars)\n\t\t\tcount = logged_chars;\n\t\tif (do_clear)\n\t\t\tlogged_chars = 0;\n\t\tlimit = log_end;\n\t\t/*\n\t\t * __put_user() could sleep, and while we sleep\n\t\t * printk() could overwrite the messages\n\t\t * we try to copy to user space. Therefore\n\t\t * the messages are copied in reverse. <manfreds>\n\t\t */\n\t\tfor (i = 0; i < count && !error; i++) {\n\t\t\tj = limit-1-i;\n\t\t\tif (j + log_buf_len < log_end)\n\t\t\t\tbreak;\n\t\t\tc = LOG_BUF(j);\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\terror = __put_user(c,&buf[count-1-i]);\n\t\t\tcond_resched();\n\t\t\traw_spin_lock_irq(&logbuf_lock);\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = i;\n\t\tif (i != count) {\n\t\t\tint offset = count-error;\n\t\t\t/* buffer overflow during copy, correct user buffer. */\n\t\t\tfor (i = 0; i < error; i++) {\n\t\t\t\tif (__get_user(c,&buf[i+offset]) ||\n\t\t\t\t    __put_user(c,&buf[i])) {\n\t\t\t\t\terror = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t/* Clear ring buffer */\n\tcase SYSLOG_ACTION_CLEAR:\n\t\tlogged_chars = 0;\n\t\tbreak;\n\t/* Disable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_OFF:\n\t\tif (saved_console_loglevel == -1)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t/* Enable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_ON:\n\t\tif (saved_console_loglevel != -1) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = -1;\n\t\t}\n\t\tbreak;\n\t/* Set level of messages printed to console */\n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\terror = -EINVAL;\n\t\tif (len < 1 || len > 8)\n\t\t\tgoto out;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t/* Implicitly re-enable logging to console */\n\t\tsaved_console_loglevel = -1;\n\t\terror = 0;\n\t\tbreak;\n\t/* Number of chars in the log buffer */\n\tcase SYSLOG_ACTION_SIZE_UNREAD:\n\t\terror = log_end - log_start;\n\t\tbreak;\n\t/* Size of the log buffer */\n\tcase SYSLOG_ACTION_SIZE_BUFFER:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\treturn error;\n}",
                        "code_after_change": "int do_syslog(int type, char __user *buf, int len, bool from_file)\n{\n\tbool clear = false;\n\tstatic int saved_console_loglevel = -1;\n\tint error;\n\n\terror = check_syslog_permissions(type, from_file);\n\tif (error)\n\t\tgoto out;\n\n\terror = security_syslog(type);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase SYSLOG_ACTION_CLOSE:\t/* Close log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_OPEN:\t/* Open log */\n\t\tbreak;\n\tcase SYSLOG_ACTION_READ:\t/* Read from log */\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terror = wait_event_interruptible(log_wait,\n\t\t\t\t\t\t syslog_seq != log_next_seq);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = syslog_print(buf, len);\n\t\tbreak;\n\t/* Read/clear last kernel messages */\n\tcase SYSLOG_ACTION_READ_CLEAR:\n\t\tclear = true;\n\t\t/* FALL THRU */\n\t/* Read last kernel messages */\n\tcase SYSLOG_ACTION_READ_ALL:\n\t\terror = -EINVAL;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(VERIFY_WRITE, buf, len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terror = syslog_print_all(buf, len, clear);\n\t\tbreak;\n\t/* Clear ring buffer */\n\tcase SYSLOG_ACTION_CLEAR:\n\t\tsyslog_print_all(NULL, 0, true);\n\t/* Disable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_OFF:\n\t\tif (saved_console_loglevel == -1)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t/* Enable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_ON:\n\t\tif (saved_console_loglevel != -1) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = -1;\n\t\t}\n\t\tbreak;\n\t/* Set level of messages printed to console */\n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\terror = -EINVAL;\n\t\tif (len < 1 || len > 8)\n\t\t\tgoto out;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t/* Implicitly re-enable logging to console */\n\t\tsaved_console_loglevel = -1;\n\t\terror = 0;\n\t\tbreak;\n\t/* Number of chars in the log buffer */\n\tcase SYSLOG_ACTION_SIZE_UNREAD:\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t}\n\t\tif (from_file) {\n\t\t\t/*\n\t\t\t * Short-cut for poll(/\"proc/kmsg\") which simply checks\n\t\t\t * for pending data, not the size; return the count of\n\t\t\t * records, not the length.\n\t\t\t */\n\t\t\terror = log_next_idx - syslog_idx;\n\t\t} else {\n\t\t\tu64 seq;\n\t\t\tu32 idx;\n\n\t\t\terror = 0;\n\t\t\tseq = syslog_seq;\n\t\t\tidx = syslog_idx;\n\t\t\twhile (seq < log_next_seq) {\n\t\t\t\terror += syslog_print_line(idx, NULL, 0);\n\t\t\t\tidx = log_next(idx);\n\t\t\t\tseq++;\n\t\t\t}\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tbreak;\n\t/* Size of the log buffer */\n\tcase SYSLOG_ACTION_SIZE_BUFFER:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\treturn error;\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
                        "code_after_change": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *preply = &reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
                        "cve_id": "CVE-2014-6416"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tif (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\tsize_t size;\n\t\t\tint max = vfio_pci_get_irq_count(vdev, hdr.index);\n\n\t\t\tif (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)\n\t\t\t\tsize = sizeof(uint8_t);\n\t\t\telse if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)\n\t\t\t\tsize = sizeof(int32_t);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (hdr.argsz - minsz < hdr.count * size ||\n\t\t\t    hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
                        "code_after_change": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\tvoid *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t      indx, 0, buf, size, 500);\n\tif (ret > 0 && ret <= size)\n\t\tmemcpy(data, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}",
                        "cve_id": "CVE-2016-9083"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int uac_mixer_unit_get_channels(struct mixer_build *state,\n\t\t\t\t       struct uac_mixer_unit_descriptor *desc)\n{\n\tint mu_channels;\n\tvoid *c;\n\n\tif (desc->bLength < sizeof(*desc))\n\t\treturn -EINVAL;\n\tif (!desc->bNrInPins)\n\t\treturn -EINVAL;\n\n\tswitch (state->mixer->protocol) {\n\tcase UAC_VERSION_1:\n\tcase UAC_VERSION_2:\n\tdefault:\n\t\tif (desc->bLength < sizeof(*desc) + desc->bNrInPins + 1)\n\t\t\treturn 0; /* no bmControls -> skip */\n\t\tmu_channels = uac_mixer_unit_bNrChannels(desc);\n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tmu_channels = get_cluster_channels_v3(state,\n\t\t\t\tuac3_mixer_unit_wClusterDescrID(desc));\n\t\tbreak;\n\t}\n\n\tif (!mu_channels)\n\t\treturn 0;\n\n\tc = uac_mixer_unit_bmControls(desc, state->mixer->protocol);\n\tif (c - (void *)desc + (mu_channels - 1) / 8 >= desc->bLength)\n\t\treturn 0; /* no bmControls -> skip */\n\n\treturn mu_channels;\n}",
                        "code_after_change": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n\t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
                        "cve_id": "CVE-2019-15117"
                    },
                    "vul_output": "NO"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 0
        },
        {
            "id": 179,
            "cve_id": "CVE-2013-1772",
            "code_snippet": "asmlinkage int vprintk(const char *fmt, va_list args)\n{\n\treturn vprintk_emit(0, -1, NULL, 0, fmt, args);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "asmlinkage int printk(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n#ifdef CONFIG_KGDB_KDB\n\tif (unlikely(kdb_trap_printk)) {\n\t\tva_start(args, fmt);\n\t\tr = vkdb_printf(fmt, args);\n\t\tva_end(args);\n\t\treturn r;\n\t}\n#endif\n\tva_start(args, fmt);\n\tr = vprintk(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
                        "code_after_change": "asmlinkage int printk(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n#ifdef CONFIG_KGDB_KDB\n\tif (unlikely(kdb_trap_printk)) {\n\t\tva_start(args, fmt);\n\t\tr = vkdb_printf(fmt, args);\n\t\tva_end(args);\n\t\treturn r;\n\t}\n#endif\n\tva_start(args, fmt);\n\tr = vprintk_emit(0, -1, NULL, 0, fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
                        "cve_id": "CVE-2013-1772"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\treturn -EINVAL;\n\n\tif (!error)\n\t\terror = size;\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n}",
                        "code_after_change": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *largs = NULL, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\t/* AppArmor requires that the buffer must be null terminated atm */\n\tif (args[size - 1] != '\\0') {\n\t\t/* null terminate */\n\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\n\t\tif (!args)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(args, value, size);\n\t\targs[size] = '\\0';\n\t}\n\n\terror = -EINVAL;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\tgoto out;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\tgoto out;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\tgoto fail;\n\n\tif (!error)\n\t\terror = size;\nout:\n\tkfree(largs);\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\tgoto out;\n}",
                        "cve_id": "CVE-2016-6187"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int\nnfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\t/* now decode the pathname, which might be larger than the first page.\n\t * As we have to check for nul's anyway, we copy it into a new page\n\t * This page appears in the rq_res.pages list, but as pages_len is always\n\t * 0, it won't get in the way\n\t */\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\t/* first copy and check from the first page */\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t/* now copy next page if there is one */\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\n\treturn 1;\n}",
                        "code_after_change": "static int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ptr_off_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve_ret = btf_resolve_size(btf, ref_t, &type_size);\n\t\t\tif (IS_ERR(resolve_ret)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t\ti, btf_type_str(ref_t), ref_tname,\n\t\t\t\t\tPTR_ERR(resolve_ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (check_mem_reg(env, reg, regno, type_size))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tbpf_log(log, \"reg type unsupported for arg#%d %sfunction %s#%d\\n\", i,\n\t\t\t\tis_kfunc ? \"kernel \" : \"\", func_name, func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-7895"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ctx_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve_ret = btf_resolve_size(btf, ref_t, &type_size);\n\t\t\tif (IS_ERR(resolve_ret)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d reference type('%s %s') size cannot be determined: %ld\\n\",\n\t\t\t\t\ti, btf_type_str(ref_t), ref_tname,\n\t\t\t\t\tPTR_ERR(resolve_ret));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (check_mem_reg(env, reg, regno, type_size))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tbpf_log(log, \"reg type unsupported for arg#%d %sfunction %s#%d\\n\", i,\n\t\t\t\tis_kfunc ? \"kernel \" : \"\", func_name, func_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
                        "code_after_change": "int\nnfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\t/* now decode the pathname, which might be larger than the first page.\n\t * As we have to check for nul's anyway, we copy it into a new page\n\t * This page appears in the rq_res.pages list, but as pages_len is always\n\t * 0, it won't get in the way\n\t */\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\t/* first copy and check from the first page */\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tif ((void *)old > vec->iov_base + vec->iov_len)\n\t\treturn 0;\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t/* now copy next page if there is one */\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\n\treturn 1;\n}",
                        "cve_id": "CVE-2021-4204"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
                        "code_after_change": "int\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
                        "cve_id": "CVE-2017-7895"
                    },
                    "vul_output": "NO"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 0
        },
        {
            "id": 186,
            "cve_id": "CVE-2013-1773",
            "code_snippet": "static int\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char nc;\n\tunsigned char *op;\n\tunsigned int ec;\n\tint i, k, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tif (nls) {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     *outlen += 1)\n\t\t\t{\n\t\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\t\tif (i > len - 5)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tec = 0;\n\t\t\t\t\tfor (k = 1; k < 5; k++) {\n\t\t\t\t\t\tnc = ip[k];\n\t\t\t\t\t\tec <<= 4;\n\t\t\t\t\t\tif (nc >= '0' && nc <= '9') {\n\t\t\t\t\t\t\tec |= nc - '0';\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'a' && nc <= 'f') {\n\t\t\t\t\t\t\tec |= nc - ('a' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'A' && nc <= 'F') {\n\t\t\t\t\t\t\tec |= nc - ('A' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t\t*op++ = ec & 0xFF;\n\t\t\t\t\t*op++ = ec >> 8;\n\t\t\t\t\tip += 5;\n\t\t\t\t\ti += 5;\n\t\t\t\t} else {\n\t\t\t\t\tif ((charlen = nls->char2uni(ip, len - i, (wchar_t *)op)) < 0)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tip += charlen;\n\t\t\t\t\ti += charlen;\n\t\t\t\t\top += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t} else {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     i++, *outlen += 1)\n\t\t\t{\n\t\t\t\t*op++ = *ip++;\n\t\t\t\t*op++ = 0;\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t}\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const unsigned int maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, ptrs_per_blk - mp->mp_list[end_of_metadata]);\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_block(ip, &bn, &n);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[i-1], 1);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[end_of_metadata], 1);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}",
                        "code_after_change": "static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,\n\t\t\t   struct buffer_head *bh_map, struct metapath *mp,\n\t\t\t   const unsigned int sheight,\n\t\t\t   const unsigned int height,\n\t\t\t   const unsigned int maxlen)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct super_block *sb = sdp->sd_vfs;\n\tstruct buffer_head *dibh = mp->mp_bh[0];\n\tu64 bn, dblock = 0;\n\tunsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;\n\tunsigned dblks = 0;\n\tunsigned ptrs_per_blk;\n\tconst unsigned end_of_metadata = height - 1;\n\tint ret;\n\tint eob = 0;\n\tenum alloc_state state;\n\t__be64 *ptr;\n\t__be64 zero_bn = 0;\n\n\tBUG_ON(sheight < 1);\n\tBUG_ON(dibh == NULL);\n\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\n\tif (height == sheight) {\n\t\tstruct buffer_head *bh;\n\t\t/* Bottom indirect block exists, find unalloced extent size */\n\t\tptr = metapointer(end_of_metadata, mp);\n\t\tbh = mp->mp_bh[end_of_metadata];\n\t\tdblks = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen,\n\t\t\t\t\t   &eob);\n\t\tBUG_ON(dblks < 1);\n\t\tstate = ALLOC_DATA;\n\t} else {\n\t\t/* Need to allocate indirect blocks */\n\t\tptrs_per_blk = height > 1 ? sdp->sd_inptrs : sdp->sd_diptrs;\n\t\tdblks = min(maxlen, ptrs_per_blk - mp->mp_list[end_of_metadata]);\n\t\tif (height == ip->i_height) {\n\t\t\t/* Writing into existing tree, extend tree down */\n\t\t\tiblks = height - sheight;\n\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t} else {\n\t\t\t/* Building up tree height */\n\t\t\tstate = ALLOC_GROW_HEIGHT;\n\t\t\tiblks = height - ip->i_height;\n\t\t\tbranch_start = metapath_branch_start(mp);\n\t\t\tiblks += (height - branch_start);\n\t\t}\n\t}\n\n\t/* start of the second part of the function (state machine) */\n\n\tblks = dblks + iblks;\n\ti = sheight;\n\tdo {\n\t\tint error;\n\t\tn = blks - alloced;\n\t\terror = gfs2_alloc_block(ip, &bn, &n);\n\t\tif (error)\n\t\t\treturn error;\n\t\talloced += n;\n\t\tif (state != ALLOC_DATA || gfs2_is_jdata(ip))\n\t\t\tgfs2_trans_add_unrevoke(sdp, bn, n);\n\t\tswitch (state) {\n\t\t/* Growing height of tree */\n\t\tcase ALLOC_GROW_HEIGHT:\n\t\t\tif (i == 1) {\n\t\t\t\tptr = (__be64 *)(dibh->b_data +\n\t\t\t\t\t\t sizeof(struct gfs2_dinode));\n\t\t\t\tzero_bn = *ptr;\n\t\t\t}\n\t\t\tfor (; i - 1 < height - ip->i_height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i, 0, bn++);\n\t\t\tif (i - 1 == height - ip->i_height) {\n\t\t\t\ti--;\n\t\t\t\tgfs2_buffer_copy_tail(mp->mp_bh[i],\n\t\t\t\t\t\tsizeof(struct gfs2_meta_header),\n\t\t\t\t\t\tdibh, sizeof(struct gfs2_dinode));\n\t\t\t\tgfs2_buffer_clear_tail(dibh,\n\t\t\t\t\t\tsizeof(struct gfs2_dinode) +\n\t\t\t\t\t\tsizeof(__be64));\n\t\t\t\tptr = (__be64 *)(mp->mp_bh[i]->b_data +\n\t\t\t\t\tsizeof(struct gfs2_meta_header));\n\t\t\t\t*ptr = zero_bn;\n\t\t\t\tstate = ALLOC_GROW_DEPTH;\n\t\t\t\tfor(i = branch_start; i < height; i++) {\n\t\t\t\t\tif (mp->mp_bh[i] == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tbrelse(mp->mp_bh[i]);\n\t\t\t\t\tmp->mp_bh[i] = NULL;\n\t\t\t\t}\n\t\t\t\ti = branch_start;\n\t\t\t}\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Branching from existing tree */\n\t\tcase ALLOC_GROW_DEPTH:\n\t\t\tif (i > 1 && i < height)\n\t\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[i-1], 1);\n\t\t\tfor (; i < height && n > 0; i++, n--)\n\t\t\t\tgfs2_indirect_init(mp, ip->i_gl, i,\n\t\t\t\t\t\t   mp->mp_list[i-1], bn++);\n\t\t\tif (i == height)\n\t\t\t\tstate = ALLOC_DATA;\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t/* Tree complete, adding data blocks */\n\t\tcase ALLOC_DATA:\n\t\t\tBUG_ON(n > dblks);\n\t\t\tBUG_ON(mp->mp_bh[end_of_metadata] == NULL);\n\t\t\tgfs2_trans_add_bh(ip->i_gl, mp->mp_bh[end_of_metadata], 1);\n\t\t\tdblks = n;\n\t\t\tptr = metapointer(end_of_metadata, mp);\n\t\t\tdblock = bn;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*ptr++ = cpu_to_be64(bn++);\n\t\t\tif (buffer_zeronew(bh_map)) {\n\t\t\t\tret = sb_issue_zeroout(sb, dblock, dblks,\n\t\t\t\t\t\t       GFP_NOFS);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfs_err(sdp,\n\t\t\t\t\t       \"Failed to zero data buffers\\n\");\n\t\t\t\t\tclear_buffer_zeronew(bh_map);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ((state != ALLOC_DATA) || !dblock);\n\n\tip->i_height = height;\n\tgfs2_add_inode_blocks(&ip->i_inode, alloced);\n\tgfs2_dinode_out(ip, mp->mp_bh[0]->b_data);\n\tmap_bh(bh_map, inode->i_sb, dblock);\n\tbh_map->b_size = dblks << inode->i_blkbits;\n\tset_buffer_new(bh_map);\n\treturn 0;\n}",
                        "cve_id": "CVE-2011-4098"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\nisdn_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(file_inode(file));\n\tisdn_ctrl c;\n\tint drvidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\tcase IIOCGETDVR:\n\t\t\treturn (TTY_DV +\n\t\t\t\t(NET_DV << 8) +\n\t\t\t\t(INF_DV << 16));\n\t\tcase IIOCGETCPS:\n\t\t\tif (arg) {\n\t\t\t\tulong __user *p = argp;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCNETGPN:\n\t\t\t/* Get peer phone number of a connected\n\t\t\t * isdn network interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefore, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\tcase IIOCNETDWRSET:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\treturn (-EINVAL);\n\t\tcase IIOCNETLCR:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\treturn -ENODEV;\n\t\tcase IIOCNETAIF:\n\t\t\t/* Add a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\ts = name;\n\t\t\t} else {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETASL:\n\t\t\t/* Add a slave to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETDIF:\n\t\t\t/* Delete a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETSCF:\n\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGCF:\n\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETANM:\n\t\t\t/* Add a phone-number to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGNM:\n\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDNM:\n\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDIL:\n\t\t\t/* Force dialing of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase IIOCNETALN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_dial_slave(name);\n\t\tcase IIOCNETDLN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\tcase IIOCNETHUP:\n\t\t\t/* Force hangup of a network-interface */\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_net_force_hangup(name);\n\t\t\tbreak;\n\t\tcase IIOCSETVER:\n\t\t\tdev->net_verbose = arg;\n\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\treturn 0;\n\t\tcase IIOCSETGST:\n\t\t\tif (arg)\n\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\telse\n\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\treturn 0;\n\t\tcase IIOCSETBRJ:\n\t\t\tdrvidx = -1;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drvidx == -1)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (iocts.arg)\n\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\telse\n\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\treturn 0;\n\t\tcase IIOCSIGPRF:\n\t\t\tdev->profd = current;\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase IIOCGETPRF:\n\t\t\t/* Get all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t\t ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t}\n\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETPRF:\n\t\t\t/* Set all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t\t   ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETMAP:\n\t\tcase IIOCGETMAP:\n\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\tif (arg) {\n\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\tsnprintf(bname, sizeof(bname), \"%s%s\",\n\t\t\t\t\t\t\t strlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t dev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t (i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCDBGVAR:\n\t\t\tif (arg) {\n\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tc.driver = drvidx;\n\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\tc.arg = cmd;\n\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\tret = isdn_command(&c);\n\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}",
                        "code_after_change": "static ssize_t kmsg_writev(struct kiocb *iocb, const struct iovec *iv,\n\t\t\t   unsigned long count, loff_t pos)\n{\n\tchar *buf, *line;\n\tint i;\n\tint level = default_message_loglevel;\n\tint facility = 1;\t/* LOG_USER */\n\tsize_t len = iov_length(iv, count);\n\tssize_t ret = len;\n\n\tif (len > 1024)\n\t\treturn -EINVAL;\n\tbuf = kmalloc(len+1, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tline = buf;\n\tfor (i = 0; i < count; i++) {\n\t\tif (copy_from_user(line, iv[i].iov_base, iv[i].iov_len))\n\t\t\tgoto out;\n\t\tline += iv[i].iov_len;\n\t}\n\n\t/*\n\t * Extract and skip the syslog prefix <[0-9]*>. Coming from userspace\n\t * the decimal value represents 32bit, the lower 3 bit are the log\n\t * level, the rest are the log facility.\n\t *\n\t * If no prefix or no userspace facility is specified, we\n\t * enforce LOG_USER, to be able to reliably distinguish\n\t * kernel-generated messages from userspace-injected ones.\n\t */\n\tline = buf;\n\tif (line[0] == '<') {\n\t\tchar *endp = NULL;\n\n\t\ti = simple_strtoul(line+1, &endp, 10);\n\t\tif (endp && endp[0] == '>') {\n\t\t\tlevel = i & 7;\n\t\t\tif (i >> 3)\n\t\t\t\tfacility = i >> 3;\n\t\t\tendp++;\n\t\t\tlen -= endp - line;\n\t\t\tline = endp;\n\t\t}\n\t}\n\tline[len] = '\\0';\n\n\tprintk_emit(facility, level, NULL, 0, \"%s\", line);\nout:\n\tkfree(buf);\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-12762"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 206,
            "cve_id": "CVE-2013-1860",
            "code_snippet": "static int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock); /*concurrent reads */\n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = ACCESS_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\ti++;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = cntr ? cntr : -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t/* may have happened while we slept */\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) { /* read completed, error happened */\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * recheck whether we've lost the race\n\t\t * against the completion handler\n\t\t */\n\t\tif (!test_bit(WDM_READ, &desc->flags)) { /* lost race */\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!desc->reslength) { /* zero length read */\n\t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n\t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t/* in case we had outstanding data */\n\tif (!desc->length)\n\t\tclear_bit(WDM_READ, &desc->flags);\n\n\tspin_unlock_irq(&desc->iuspin);\n\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}",
                        "code_after_change": "static ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock); /*concurrent reads */\n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = ACCESS_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\t\t\trv = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\ti++;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = cntr ? cntr : -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t/* may have happened while we slept */\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) { /* read completed, error happened */\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * recheck whether we've lost the race\n\t\t * against the completion handler\n\t\t */\n\t\tif (!test_bit(WDM_READ, &desc->flags)) { /* lost race */\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (!desc->reslength) { /* zero length read */\n\t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n\t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t/* in case we had outstanding data */\n\tif (!desc->length)\n\t\tclear_bit(WDM_READ, &desc->flags);\n\n\tspin_unlock_irq(&desc->iuspin);\n\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}",
                        "cve_id": "CVE-2013-1860"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 229,
            "cve_id": "CVE-2013-2234",
            "code_snippet": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}",
                        "code_after_change": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2013-2234"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,\n\t\t\t\tstruct usb_interface *intf,\n\t\t\t\tu8 *buffer,\n\t\t\t\tint buflen)\n{\n\t/* duplicates are ignored */\n\tstruct usb_cdc_union_desc *union_header = NULL;\n\n\t/* duplicates are not tolerated */\n\tstruct usb_cdc_header_desc *header = NULL;\n\tstruct usb_cdc_ether_desc *ether = NULL;\n\tstruct usb_cdc_mdlm_detail_desc *detail = NULL;\n\tstruct usb_cdc_mdlm_desc *desc = NULL;\n\n\tunsigned int elength;\n\tint cnt = 0;\n\n\tmemset(hdr, 0x00, sizeof(struct usb_cdc_parsed_header));\n\thdr->phonet_magic_present = false;\n\twhile (buflen > 0) {\n\t\telength = buffer[0];\n\t\tif (!elength) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage byte\\n\");\n\t\t\telength = 1;\n\t\t\tgoto next_desc;\n\t\t}\n\t\tif (buffer[1] != USB_DT_CS_INTERFACE) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage\\n\");\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tswitch (buffer[2]) {\n\t\tcase USB_CDC_UNION_TYPE: /* we've found it */\n\t\t\tif (elength < sizeof(struct usb_cdc_union_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (union_header) {\n\t\t\t\tdev_err(&intf->dev, \"More than one union descriptor, skipping ...\\n\");\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t\tunion_header = (struct usb_cdc_union_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_COUNTRY_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_country_functional_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_country_functional_desc =\n\t\t\t\t(struct usb_cdc_country_functional_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_HEADER_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_header_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (header)\n\t\t\t\treturn -EINVAL;\n\t\t\theader = (struct usb_cdc_header_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ACM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_acm_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_acm_descriptor =\n\t\t\t\t(struct usb_cdc_acm_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ETHERNET_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_ether_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (ether)\n\t\t\t\treturn -EINVAL;\n\t\t\tether = (struct usb_cdc_ether_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_CALL_MANAGEMENT_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_call_mgmt_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_call_mgmt_descriptor =\n\t\t\t\t(struct usb_cdc_call_mgmt_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_DMM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_dmm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_dmm_desc =\n\t\t\t\t(struct usb_cdc_dmm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_desc *))\n\t\t\t\tgoto next_desc;\n\t\t\tif (desc)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc = (struct usb_cdc_mdlm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_DETAIL_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_detail_desc *))\n\t\t\t\tgoto next_desc;\n\t\t\tif (detail)\n\t\t\t\treturn -EINVAL;\n\t\t\tdetail = (struct usb_cdc_mdlm_detail_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_NCM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_ncm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_ncm_desc = (struct usb_cdc_ncm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_desc))\n\t\t\t\tgoto next_desc;\n\n\t\t\thdr->usb_cdc_mbim_desc = (struct usb_cdc_mbim_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_EXTENDED_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_extended_desc))\n\t\t\t\tbreak;\n\t\t\thdr->usb_cdc_mbim_extended_desc =\n\t\t\t\t(struct usb_cdc_mbim_extended_desc *)buffer;\n\t\t\tbreak;\n\t\tcase CDC_PHONET_MAGIC_NUMBER:\n\t\t\thdr->phonet_magic_present = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * there are LOTS more CDC descriptors that\n\t\t\t * could legitimately be found here.\n\t\t\t */\n\t\t\tdev_dbg(&intf->dev, \"Ignoring descriptor: type %02x, length %ud\\n\",\n\t\t\t\t\tbuffer[2], elength);\n\t\t\tgoto next_desc;\n\t\t}\n\t\tcnt++;\nnext_desc:\n\t\tbuflen -= elength;\n\t\tbuffer += elength;\n\t}\n\thdr->usb_cdc_union_desc = union_header;\n\thdr->usb_cdc_header_desc = header;\n\thdr->usb_cdc_mdlm_detail_desc = detail;\n\thdr->usb_cdc_mdlm_desc = desc;\n\thdr->usb_cdc_ether_desc = ether;\n\treturn cnt;\n}",
                        "code_after_change": "int cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,\n\t\t\t\tstruct usb_interface *intf,\n\t\t\t\tu8 *buffer,\n\t\t\t\tint buflen)\n{\n\t/* duplicates are ignored */\n\tstruct usb_cdc_union_desc *union_header = NULL;\n\n\t/* duplicates are not tolerated */\n\tstruct usb_cdc_header_desc *header = NULL;\n\tstruct usb_cdc_ether_desc *ether = NULL;\n\tstruct usb_cdc_mdlm_detail_desc *detail = NULL;\n\tstruct usb_cdc_mdlm_desc *desc = NULL;\n\n\tunsigned int elength;\n\tint cnt = 0;\n\n\tmemset(hdr, 0x00, sizeof(struct usb_cdc_parsed_header));\n\thdr->phonet_magic_present = false;\n\twhile (buflen > 0) {\n\t\telength = buffer[0];\n\t\tif (!elength) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage byte\\n\");\n\t\t\telength = 1;\n\t\t\tgoto next_desc;\n\t\t}\n\t\tif ((buflen < elength) || (elength < 3)) {\n\t\t\tdev_err(&intf->dev, \"invalid descriptor buffer length\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (buffer[1] != USB_DT_CS_INTERFACE) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage\\n\");\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tswitch (buffer[2]) {\n\t\tcase USB_CDC_UNION_TYPE: /* we've found it */\n\t\t\tif (elength < sizeof(struct usb_cdc_union_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (union_header) {\n\t\t\t\tdev_err(&intf->dev, \"More than one union descriptor, skipping ...\\n\");\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t\tunion_header = (struct usb_cdc_union_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_COUNTRY_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_country_functional_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_country_functional_desc =\n\t\t\t\t(struct usb_cdc_country_functional_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_HEADER_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_header_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (header)\n\t\t\t\treturn -EINVAL;\n\t\t\theader = (struct usb_cdc_header_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ACM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_acm_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_acm_descriptor =\n\t\t\t\t(struct usb_cdc_acm_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ETHERNET_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_ether_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (ether)\n\t\t\t\treturn -EINVAL;\n\t\t\tether = (struct usb_cdc_ether_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_CALL_MANAGEMENT_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_call_mgmt_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_call_mgmt_descriptor =\n\t\t\t\t(struct usb_cdc_call_mgmt_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_DMM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_dmm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_dmm_desc =\n\t\t\t\t(struct usb_cdc_dmm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_desc *))\n\t\t\t\tgoto next_desc;\n\t\t\tif (desc)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc = (struct usb_cdc_mdlm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_DETAIL_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_detail_desc *))\n\t\t\t\tgoto next_desc;\n\t\t\tif (detail)\n\t\t\t\treturn -EINVAL;\n\t\t\tdetail = (struct usb_cdc_mdlm_detail_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_NCM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_ncm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_ncm_desc = (struct usb_cdc_ncm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_desc))\n\t\t\t\tgoto next_desc;\n\n\t\t\thdr->usb_cdc_mbim_desc = (struct usb_cdc_mbim_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_EXTENDED_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_extended_desc))\n\t\t\t\tbreak;\n\t\t\thdr->usb_cdc_mbim_extended_desc =\n\t\t\t\t(struct usb_cdc_mbim_extended_desc *)buffer;\n\t\t\tbreak;\n\t\tcase CDC_PHONET_MAGIC_NUMBER:\n\t\t\thdr->phonet_magic_present = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * there are LOTS more CDC descriptors that\n\t\t\t * could legitimately be found here.\n\t\t\t */\n\t\t\tdev_dbg(&intf->dev, \"Ignoring descriptor: type %02x, length %ud\\n\",\n\t\t\t\t\tbuffer[2], elength);\n\t\t\tgoto next_desc;\n\t\t}\n\t\tcnt++;\nnext_desc:\n\t\tbuflen -= elength;\n\t\tbuffer += elength;\n\t}\n\thdr->usb_cdc_union_desc = union_header;\n\thdr->usb_cdc_header_desc = header;\n\thdr->usb_cdc_mdlm_detail_desc = detail;\n\thdr->usb_cdc_mdlm_desc = desc;\n\thdr->usb_cdc_ether_desc = ether;\n\treturn cnt;\n}",
                        "cve_id": "CVE-2017-16534"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\t/* A datagram fragment has been received, now the fun begins. */\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
                        "code_after_change": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\tif (len <= RFC2374_UNFRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\n\t/* A datagram fragment has been received, now the fun begins. */\n\n\tif (len <= RFC2374_FRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tif (fg_off + len > dg_size)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
                        "cve_id": "CVE-2016-8633"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 249,
            "cve_id": "CVE-2013-2850",
            "code_snippet": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tchar *tmpptr = key + strlen(key);\n\t\t\t\t*tmpptr = '=';\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstart += strlen(key) + strlen(value) + 2;\n\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\n\tkfree(tmpbuf);\n\treturn 0;\n}",
                        "code_after_change": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstart += strlen(key) + strlen(value) + 2;\n\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\n\tkfree(tmpbuf);\n\treturn 0;\n}",
                        "cve_id": "CVE-2013-2850"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 260,
            "cve_id": "CVE-2013-2893",
            "code_snippet": "static int hid_lg3ff_play(struct input_dev *dev, void *data,\n\t\t\t struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\n\tint x, y;\n\n/*\n * Available values in the field should always be 63, but we only use up to\n * 35. Instead, clear the entire area, however big it is.\n */\n\tmemset(report->field[0]->value, 0,\n\t       sizeof(__s32) * report->field[0]->report_count);\n\n\tswitch (effect->type) {\n\tcase FF_CONSTANT:\n/*\n * Already clamped in ff_memless\n * 0 is center (different then other logitech)\n */\n\t\tx = effect->u.ramp.start_level;\n\t\ty = effect->u.ramp.end_level;\n\n\t\t/* send command byte */\n\t\treport->field[0]->value[0] = 0x51;\n\n/*\n * Sign backwards from other Force3d pro\n * which get recast here in two's complement 8 bits\n */\n\t\treport->field[0]->value[1] = (unsigned char)(-x);\n\t\treport->field[0]->value[31] = (unsigned char)(-y);\n\n\t\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output report found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treport = list_entry(report_list->next, struct hid_report, list);\n\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"output report is empty\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force feedback for Logitech RumblePad/Rumblepad 2 by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\n\treturn 0;\n}",
                        "code_after_change": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\n\t/* Check that the report looks ok */\n\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);\n\tif (!report)\n\t\treturn -ENODEV;\n\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force feedback for Logitech RumblePad/Rumblepad 2 by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2013-2893"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 264,
            "cve_id": "CVE-2013-2895",
            "code_snippet": "static int logi_dj_recv_send_report(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t    struct dj_report *dj_report)\n{\n\tstruct hid_device *hdev = djrcv_dev->hdev;\n\tstruct hid_report *report;\n\tstruct hid_report_enum *output_report_enum;\n\tu8 *data = (u8 *)(&dj_report->device_index);\n\tunsigned int i;\n\n\toutput_report_enum = &hdev->report_enum[HID_OUTPUT_REPORT];\n\treport = output_report_enum->report_id_hash[REPORT_ID_DJ_SHORT];\n\n\tif (!report) {\n\t\tdev_err(&hdev->dev, \"%s: unable to find dj report\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < DJREPORT_SHORT_LENGTH - 1; i++)\n\t\treport->field[0]->value[i] = data[i];\n\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tdjrcv_dev->querying_devices = false;\n\t\treturn;\n\t}\n\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t__func__, dj_report->device_index);\n\t\treturn;\n\t}\n\n\tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n\t\t/* The device is already known. No need to reallocate it. */\n\t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: hid_allocate_device failed\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\n\tdj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\n\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\"Logitech Unifying Device. Wireless PID:%02x%02x\",\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", dj_report->device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed allocating dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = get_unaligned_le32(\n\t\tdj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = dj_report->device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed adding dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}",
                        "code_after_change": "static int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct dj_receiver_dev *djrcv_dev;\n\tint retval;\n\n\tif (is_dj_device((struct dj_device *)hdev->driver_data))\n\t\treturn -ENODEV;\n\n\tdbg_hid(\"%s called for ifnum %d\\n\", __func__,\n\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\t/* Ignore interfaces 0 and 1, they will not carry any data, dont create\n\t * any hid_device for them */\n\tif (intf->cur_altsetting->desc.bInterfaceNumber !=\n\t    LOGITECH_DJ_INTERFACE_NUMBER) {\n\t\tdbg_hid(\"%s: ignoring ifnum %d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Treat interface 2 */\n\n\tdjrcv_dev = kzalloc(sizeof(struct dj_receiver_dev), GFP_KERNEL);\n\tif (!djrcv_dev) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:failed allocating dj_receiver_dev\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdjrcv_dev->hdev = hdev;\n\tINIT_WORK(&djrcv_dev->work, delayedwork_callback);\n\tspin_lock_init(&djrcv_dev->lock);\n\tif (kfifo_alloc(&djrcv_dev->notif_fifo,\n\t\t\tDJ_MAX_NUMBER_NOTIFICATIONS * sizeof(struct dj_report),\n\t\t\tGFP_KERNEL)) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:failed allocating notif_fifo\\n\", __func__);\n\t\tkfree(djrcv_dev);\n\t\treturn -ENOMEM;\n\t}\n\thid_set_drvdata(hdev, djrcv_dev);\n\n\t/* Call  to usbhid to fetch the HID descriptors of interface 2 and\n\t * subsequently call to the hid/hid-core to parse the fetched\n\t * descriptors, this will in turn create the hidraw and hiddev nodes\n\t * for interface 2 of the receiver */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:parse of interface 2 failed\\n\", __func__);\n\t\tgoto hid_parse_fail;\n\t}\n\n\tif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, REPORT_ID_DJ_SHORT,\n\t\t\t\t 0, DJREPORT_SHORT_LENGTH - 1)) {\n\t\tretval = -ENODEV;\n\t\tgoto hid_parse_fail;\n\t}\n\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (retval) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto switch_to_dj_mode_fail;\n\t}\n\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev, \"%s:hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\n\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev, \"%s:logi_dj_recv_query_paired_devices \"\n\t\t\t\"error:%d\\n\", __func__, retval);\n\t\tgoto logi_dj_recv_query_paired_devices_failed;\n\t}\n\n\treturn retval;\n\nlogi_dj_recv_query_paired_devices_failed:\n\thid_hw_close(hdev);\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\nhid_parse_fail:\n\tkfifo_free(&djrcv_dev->notif_fifo);\n\tkfree(djrcv_dev);\n\thid_set_drvdata(hdev, NULL);\n\treturn retval;\n\n}",
                        "cve_id": "CVE-2014-3182"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 306,
            "cve_id": "CVE-2013-4312",
            "code_snippet": "void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t}\n\tfp->f_cred->user->unix_inflight++;\n\tspin_unlock(&unix_gc_lock);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tspin_lock(&unix_gc_lock);\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t\tspin_unlock(&unix_gc_lock);\n\t}\n}",
                        "code_after_change": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tfp->f_cred->user->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}",
                        "cve_id": "CVE-2013-4312"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 335,
            "cve_id": "CVE-2013-4514",
            "code_snippet": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tsize_t len;\n\tint         ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tlen = min_t(size_t, wrqu->data.length, sizeof(lp->StationName));\n\tstrlcpy(lp->StationName, extra, len);\n\n\t/* Commit the adapter parameters */\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int buzz_init(struct hid_device *hdev)\n{\n\tstruct sony_sc *drv_data;\n\tstruct buzz_extra *buzz;\n\tint n, ret = 0;\n\tstruct led_classdev *led;\n\tsize_t name_sz;\n\tchar *name;\n\n\tdrv_data = hid_get_drvdata(hdev);\n\tBUG_ON(!(drv_data->quirks & BUZZ_CONTROLLER));\n\n\tbuzz = kzalloc(sizeof(*buzz), GFP_KERNEL);\n\tif (!buzz) {\n\t\thid_err(hdev, \"Insufficient memory, cannot allocate driver data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdrv_data->extra = buzz;\n\n\t/* Clear LEDs as we have no way of reading their initial state. This is\n\t * only relevant if the driver is loaded after somebody actively set the\n\t * LEDs to on */\n\tbuzz_set_leds(hdev, 0x00);\n\n\tname_sz = strlen(dev_name(&hdev->dev)) + strlen(\"::buzz#\") + 1;\n\n\tfor (n = 0; n < 4; n++) {\n\t\tled = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);\n\t\tif (!led) {\n\t\t\thid_err(hdev, \"Couldn't allocate memory for LED %d\\n\", n);\n\t\t\tgoto error_leds;\n\t\t}\n\n\t\tname = (void *)(&led[1]);\n\t\tsnprintf(name, name_sz, \"%s::buzz%d\", dev_name(&hdev->dev), n + 1);\n\t\tled->name = name;\n\t\tled->brightness = 0;\n\t\tled->max_brightness = 1;\n\t\tled->brightness_get = buzz_led_get_brightness;\n\t\tled->brightness_set = buzz_led_set_brightness;\n\n\t\tif (led_classdev_register(&hdev->dev, led)) {\n\t\t\thid_err(hdev, \"Failed to register LED %d\\n\", n);\n\t\t\tkfree(led);\n\t\t\tgoto error_leds;\n\t\t}\n\n\t\tbuzz->leds[n] = led;\n\t}\n\n\treturn ret;\n\nerror_leds:\n\tfor (n = 0; n < 4; n++) {\n\t\tled = buzz->leds[n];\n\t\tbuzz->leds[n] = NULL;\n\t\tif (!led)\n\t\t\tcontinue;\n\t\tled_classdev_unregister(led);\n\t\tkfree(led);\n\t}\n\n\tkfree(drv_data->extra);\n\tdrv_data->extra = NULL;\n\treturn ret;\n}",
                        "code_after_change": "static int buzz_init(struct hid_device *hdev)\n{\n\tstruct sony_sc *drv_data;\n\tstruct buzz_extra *buzz;\n\tint n, ret = 0;\n\tstruct led_classdev *led;\n\tsize_t name_sz;\n\tchar *name;\n\n\tdrv_data = hid_get_drvdata(hdev);\n\tBUG_ON(!(drv_data->quirks & BUZZ_CONTROLLER));\n\n\t/* Validate expected report characteristics. */\n\tif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\treturn -ENODEV;\n\n\tbuzz = kzalloc(sizeof(*buzz), GFP_KERNEL);\n\tif (!buzz) {\n\t\thid_err(hdev, \"Insufficient memory, cannot allocate driver data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdrv_data->extra = buzz;\n\n\t/* Clear LEDs as we have no way of reading their initial state. This is\n\t * only relevant if the driver is loaded after somebody actively set the\n\t * LEDs to on */\n\tbuzz_set_leds(hdev, 0x00);\n\n\tname_sz = strlen(dev_name(&hdev->dev)) + strlen(\"::buzz#\") + 1;\n\n\tfor (n = 0; n < 4; n++) {\n\t\tled = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);\n\t\tif (!led) {\n\t\t\thid_err(hdev, \"Couldn't allocate memory for LED %d\\n\", n);\n\t\t\tgoto error_leds;\n\t\t}\n\n\t\tname = (void *)(&led[1]);\n\t\tsnprintf(name, name_sz, \"%s::buzz%d\", dev_name(&hdev->dev), n + 1);\n\t\tled->name = name;\n\t\tled->brightness = 0;\n\t\tled->max_brightness = 1;\n\t\tled->brightness_get = buzz_led_get_brightness;\n\t\tled->brightness_set = buzz_led_set_brightness;\n\n\t\tif (led_classdev_register(&hdev->dev, led)) {\n\t\t\thid_err(hdev, \"Failed to register LED %d\\n\", n);\n\t\t\tkfree(led);\n\t\t\tgoto error_leds;\n\t\t}\n\n\t\tbuzz->leds[n] = led;\n\t}\n\n\treturn ret;\n\nerror_leds:\n\tfor (n = 0; n < 4; n++) {\n\t\tled = buzz->leds[n];\n\t\tbuzz->leds[n] = NULL;\n\t\tif (!led)\n\t\t\tcontinue;\n\t\tled_classdev_unregister(led);\n\t\tkfree(led);\n\t}\n\n\tkfree(drv_data->extra);\n\tdrv_data->extra = NULL;\n\treturn ret;\n}",
                        "cve_id": "CVE-2013-2890"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 344,
            "cve_id": "CVE-2013-4588",
            "code_snippet": "static int\ndo_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\tunsigned int copylen;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n\t\treturn -EINVAL;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tcopylen = get_arglen[GET_CMDID(cmd)];\n\tif (copylen > 128)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(arg, user, copylen) != 0)\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}",
                        "code_after_change": "static int\ndo_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tunsigned char arg[MAX_ARG_LEN];\n\tstruct ip_vs_service_user *usvc_compat;\n\tstruct ip_vs_service_user_kern usvc;\n\tstruct ip_vs_service *svc;\n\tstruct ip_vs_dest_user *udest_compat;\n\tstruct ip_vs_dest_user_kern udest;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)\n\t\treturn -EINVAL;\n\tif (len < 0 || len >  MAX_ARG_LEN)\n\t\treturn -EINVAL;\n\tif (len != set_arglen[SET_CMDID(cmd)]) {\n\t\tpr_err(\"set_ctl: len %u != %u\\n\",\n\t\t       len, set_arglen[SET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(arg, user, len) != 0)\n\t\treturn -EFAULT;\n\n\t/* increase the module use count */\n\tip_vs_use_count_inc();\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto out_dec;\n\t}\n\n\tif (cmd == IP_VS_SO_SET_FLUSH) {\n\t\t/* Flush the virtual service */\n\t\tret = ip_vs_flush();\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_TIMEOUT) {\n\t\t/* Set timeout values for (tcp tcpfin udp) */\n\t\tret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);\n\t\tgoto out_unlock;\n\t} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {\n\t\tstruct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;\n\t\tret = stop_sync_thread(dm->state);\n\t\tgoto out_unlock;\n\t}\n\n\tusvc_compat = (struct ip_vs_service_user *)arg;\n\tudest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);\n\n\t/* We only use the new structs internally, so copy userspace compat\n\t * structs to extended internal versions */\n\tip_vs_copy_usvc_compat(&usvc, usvc_compat);\n\tip_vs_copy_udest_compat(&udest, udest_compat);\n\n\tif (cmd == IP_VS_SO_SET_ZERO) {\n\t\t/* if no service address is set, zero counters in all */\n\t\tif (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {\n\t\t\tret = ip_vs_zero_all();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Check for valid protocol: TCP or UDP, even for fwmark!=0 */\n\tif (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {\n\t\tpr_err(\"set_ctl: invalid protocol: %d %pI4:%d %s\\n\",\n\t\t       usvc.protocol, &usvc.addr.ip,\n\t\t       ntohs(usvc.port), usvc.sched_name);\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Lookup the exact service by <protocol, addr, port> or fwmark */\n\tif (usvc.fwmark == 0)\n\t\tsvc = __ip_vs_service_get(usvc.af, usvc.protocol,\n\t\t\t\t\t  &usvc.addr, usvc.port);\n\telse\n\t\tsvc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);\n\n\tif (cmd != IP_VS_SO_SET_ADD\n\t    && (svc == NULL || svc->protocol != usvc.protocol)) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_SET_ADD:\n\t\tif (svc != NULL)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = ip_vs_add_service(&usvc, &svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDIT:\n\t\tret = ip_vs_edit_service(svc, &usvc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DEL:\n\t\tret = ip_vs_del_service(svc);\n\t\tif (!ret)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\tcase IP_VS_SO_SET_ZERO:\n\t\tret = ip_vs_zero_service(svc);\n\t\tbreak;\n\tcase IP_VS_SO_SET_ADDDEST:\n\t\tret = ip_vs_add_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_EDITDEST:\n\t\tret = ip_vs_edit_dest(svc, &udest);\n\t\tbreak;\n\tcase IP_VS_SO_SET_DELDEST:\n\t\tret = ip_vs_del_dest(svc, &udest);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (svc)\n\t\tip_vs_service_put(svc);\n\n  out_unlock:\n\tmutex_unlock(&__ip_vs_mutex);\n  out_dec:\n\t/* decrease the module use count */\n\tip_vs_use_count_dec();\n\n\treturn ret;\n}",
                        "cve_id": "CVE-2013-4588"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 360,
            "cve_id": "CVE-2013-6382",
            "code_snippet": "STATIC int\nxfs_compat_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tattrlist_cursor_kern_t\t*cursor;\n\tcompat_xfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -XFS_ERROR(EPERM);\n\tif (copy_from_user(&al_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -XFS_ERROR(EFAULT);\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -XFS_ERROR(EINVAL);\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -XFS_ERROR(EINVAL);\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -ENOMEM;\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(compat_ptr(al_hreq.buffer), kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "STATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -XFS_ERROR(EPERM);\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -XFS_ERROR(EFAULT);\n\tif (al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -XFS_ERROR(EINVAL);\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -XFS_ERROR(EINVAL);\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
                        "code_after_change": "STATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -XFS_ERROR(EPERM);\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -XFS_ERROR(EFAULT);\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -XFS_ERROR(EINVAL);\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -XFS_ERROR(EINVAL);\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
                        "cve_id": "CVE-2013-6382"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 530,
            "cve_id": "CVE-2014-0205",
            "code_snippet": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t/*\n\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n\t * q.key refs.\n\t */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\t/* unqueue_me() drops q.key ref */\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current_thread_info()->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n\n\tret = -ERESTART_RESTARTBLOCK;\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n\t\treturn -ENOMEM;\n\n\t/* stop the CPU */\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t/* restart the CPU */\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(hx);\n\n\treturn ret;\n}",
                        "code_after_change": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 *buf;\n\tint ret, pos = 0;\n\tu16 cpu_cs_register = cypress[type].cpu_cs_register;\n\n\tbuf = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\thx = (struct hexline *)buf;\n\n\t/* stop the CPU */\n\tbuf[0] = 1;\n\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t/* restart the CPU */\n\t\tbuf[0] = 0;\n\t\tif (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(buf);\n\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-8061"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static void *__io_uaddr_map(struct page ***pages, unsigned short *npages,\n\t\t\t    unsigned long uaddr, size_t size)\n{\n\tstruct page **page_array;\n\tunsigned int nr_pages;\n\tint ret, i;\n\n\t*npages = 0;\n\n\tif (uaddr & (PAGE_SIZE - 1) || !size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (nr_pages > USHRT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tpage_array = kvmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!page_array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = pin_user_pages_fast(uaddr, nr_pages, FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t\t\tpage_array);\n\tif (ret != nr_pages) {\nerr:\n\t\tio_pages_free(&page_array, ret > 0 ? ret : 0);\n\t\treturn ret < 0 ? ERR_PTR(ret) : ERR_PTR(-EFAULT);\n\t}\n\t/*\n\t * Should be a single page. If the ring is small enough that we can\n\t * use a normal page, that is fine. If we need multiple pages, then\n\t * userspace should use a huge page. That's the only way to guarantee\n\t * that we get contigious memory, outside of just being lucky or\n\t * (currently) having low memory fragmentation.\n\t */\n\tif (page_array[0] != page_array[ret - 1])\n\t\tgoto err;\n\n\t/*\n\t * Can't support mapping user allocated ring memory on 32-bit archs\n\t * where it could potentially reside in highmem. Just fail those with\n\t * -EINVAL, just like we did on kernels that didn't support this\n\t * feature.\n\t */\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (PageHighMem(page_array[i])) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t*pages = page_array;\n\t*npages = nr_pages;\n\treturn page_to_virt(page_array[0]);\n}",
                        "code_after_change": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
                        "cve_id": "CVE-2023-6560"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
                        "code_after_change": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\tloc->elf_ex.e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
                        "cve_id": "CVE-2016-9793"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, 0);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
                        "code_after_change": "static void *__io_uaddr_map(struct page ***pages, unsigned short *npages,\n\t\t\t    unsigned long uaddr, size_t size)\n{\n\tstruct page **page_array;\n\tunsigned int nr_pages;\n\tvoid *page_addr;\n\tint ret, i;\n\n\t*npages = 0;\n\n\tif (uaddr & (PAGE_SIZE - 1) || !size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (nr_pages > USHRT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tpage_array = kvmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!page_array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = pin_user_pages_fast(uaddr, nr_pages, FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t\t\tpage_array);\n\tif (ret != nr_pages) {\nerr:\n\t\tio_pages_free(&page_array, ret > 0 ? ret : 0);\n\t\treturn ret < 0 ? ERR_PTR(ret) : ERR_PTR(-EFAULT);\n\t}\n\n\tpage_addr = page_address(page_array[0]);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tret = -EINVAL;\n\n\t\t/*\n\t\t * Can't support mapping user allocated ring memory on 32-bit\n\t\t * archs where it could potentially reside in highmem. Just\n\t\t * fail those with -EINVAL, just like we did on kernels that\n\t\t * didn't support this feature.\n\t\t */\n\t\tif (PageHighMem(page_array[i]))\n\t\t\tgoto err;\n\n\t\t/*\n\t\t * No support for discontig pages for now, should either be a\n\t\t * single normal page, or a huge page. Later on we can add\n\t\t * support for remapping discontig pages, for now we will\n\t\t * just fail them with EINVAL.\n\t\t */\n\t\tif (page_address(page_array[i]) != page_addr)\n\t\t\tgoto err;\n\t\tpage_addr += PAGE_SIZE;\n\t}\n\n\t*pages = page_array;\n\t*npages = nr_pages;\n\treturn page_to_virt(page_array[0]);\n}",
                        "cve_id": "CVE-2017-1000253"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock);\n\treturn hb;\n}",
                        "code_after_change": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock);\n\treturn hb;\n}",
                        "cve_id": "CVE-2014-0205"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 531,
            "cve_id": "CVE-2014-0205",
            "code_snippet": "static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t int clockrt, u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = NULL;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2;\n\tstruct futex_q q;\n\tint res, ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trt_waiter.task = NULL;\n\n\tkey2 = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr2, fshared, &key2);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current,\n\t\t\t\t\t\t   fshared);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!&q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, fshared, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t/*\n\t * If fixup_pi_state_owner() faulted and was unable to handle the\n\t * fault, unlock the rt_mutex and return the fault to userspace.\n\t */\n\tif (ret == -EFAULT) {\n\t\tif (rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(fshared, &q.key);\nout_key2:\n\tput_futex_key(fshared, &key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void *__io_uaddr_map(struct page ***pages, unsigned short *npages,\n\t\t\t    unsigned long uaddr, size_t size)\n{\n\tstruct page **page_array;\n\tunsigned int nr_pages;\n\tint ret, i;\n\n\t*npages = 0;\n\n\tif (uaddr & (PAGE_SIZE - 1) || !size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (nr_pages > USHRT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tpage_array = kvmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!page_array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = pin_user_pages_fast(uaddr, nr_pages, FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t\t\tpage_array);\n\tif (ret != nr_pages) {\nerr:\n\t\tio_pages_free(&page_array, ret > 0 ? ret : 0);\n\t\treturn ret < 0 ? ERR_PTR(ret) : ERR_PTR(-EFAULT);\n\t}\n\t/*\n\t * Should be a single page. If the ring is small enough that we can\n\t * use a normal page, that is fine. If we need multiple pages, then\n\t * userspace should use a huge page. That's the only way to guarantee\n\t * that we get contigious memory, outside of just being lucky or\n\t * (currently) having low memory fragmentation.\n\t */\n\tif (page_array[0] != page_array[ret - 1])\n\t\tgoto err;\n\n\t/*\n\t * Can't support mapping user allocated ring memory on 32-bit archs\n\t * where it could potentially reside in highmem. Just fail those with\n\t * -EINVAL, just like we did on kernels that didn't support this\n\t * feature.\n\t */\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (PageHighMem(page_array[i])) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t*pages = page_array;\n\t*npages = nr_pages;\n\treturn page_to_virt(page_array[0]);\n}",
                        "code_after_change": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\tloc->elf_ex.e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
                        "cve_id": "CVE-2023-6560"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, 0);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
                        "code_after_change": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-1000253"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}",
                        "code_after_change": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n\t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
                        "cve_id": "CVE-2016-9793"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tif (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\tsize_t size;\n\t\t\tint max = vfio_pci_get_irq_count(vdev, hdr.index);\n\n\t\t\tif (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)\n\t\t\t\tsize = sizeof(uint8_t);\n\t\t\telse if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)\n\t\t\t\tsize = sizeof(int32_t);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (hdr.argsz - minsz < hdr.count * size ||\n\t\t\t    hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}",
                        "code_after_change": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock);\n\treturn hb;\n}",
                        "cve_id": "CVE-2016-9083"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock);\n\treturn hb;\n}",
                        "code_after_change": "static int hva_to_pfn_remapped(struct vm_area_struct *vma,\n\t\t\t       unsigned long addr, bool *async,\n\t\t\t       bool write_fault, bool *writable,\n\t\t\t       kvm_pfn_t *p_pfn)\n{\n\tkvm_pfn_t pfn;\n\tpte_t *ptep;\n\tspinlock_t *ptl;\n\tint r;\n\n\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\tif (r) {\n\t\t/*\n\t\t * get_user_pages fails for VM_IO and VM_PFNMAP vmas and does\n\t\t * not call the fault handler, so do it here.\n\t\t */\n\t\tbool unlocked = false;\n\t\tr = fixup_user_fault(current->mm, addr,\n\t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : 0),\n\t\t\t\t     &unlocked);\n\t\tif (unlocked)\n\t\t\treturn -EAGAIN;\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (write_fault && !pte_write(*ptep)) {\n\t\tpfn = KVM_PFN_ERR_RO_FAULT;\n\t\tgoto out;\n\t}\n\n\tif (writable)\n\t\t*writable = pte_write(*ptep);\n\tpfn = pte_pfn(*ptep);\n\n\t/*\n\t * Get a reference here because callers of *hva_to_pfn* and\n\t * *gfn_to_pfn* ultimately call kvm_release_pfn_clean on the\n\t * returned pfn.  This is only needed if the VMA has VM_MIXEDMAP\n\t * set, but the kvm_get_pfn/kvm_release_pfn_clean pair will\n\t * simply do nothing for reserved pfns.\n\t *\n\t * Whoever called remap_pfn_range is also going to call e.g.\n\t * unmap_mapping_range before the underlying pages are freed,\n\t * causing a call to our MMU notifier.\n\t *\n\t * Certain IO or PFNMAP mappings can be backed with valid\n\t * struct pages, but be allocated without refcounting e.g.,\n\t * tail pages of non-compound higher order allocations, which\n\t * would then underflow the refcount when the caller does the\n\t * required put_page. Don't allow those pages here.\n\t */ \n\tif (!kvm_try_get_pfn(pfn))\n\t\tr = -EFAULT;\n\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\t*p_pfn = pfn;\n\n\treturn r;\n}",
                        "cve_id": "CVE-2014-0205"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 578,
            "cve_id": "CVE-2014-3182",
            "code_snippet": "static int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\tbool report_processed = false;\n\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n\n\t/* Here we receive all data coming from iface 2, there are 4 cases:\n\t *\n\t * 1) Data should continue its normal processing i.e. data does not\n\t * come from the DJ collection, in which case we do nothing and\n\t * return 0, so hid-core can continue normal processing (will forward\n\t * to associated hidraw device)\n\t *\n\t * 2) Data is from DJ collection, and is intended for this driver i. e.\n\t * data contains arrival, departure, etc notifications, in which case\n\t * we queue them for delayed processing by the work queue. We return 1\n\t * to hid-core as no further processing is required from it.\n\t *\n\t * 3) Data is from DJ collection, and informs a connection change,\n\t * if the change means rf link loss, then we must send a null report\n\t * to the upper layer to discard potentially pressed keys that may be\n\t * repeated forever by the input layer. Return 1 to hid-core as no\n\t * further processing is required.\n\t *\n\t * 4) Data is from DJ collection and is an actual input event from\n\t * a paired DJ device in which case we forward it to the correct hid\n\t * device (via hid_input_report() ) and return 1 so hid-core does not do\n\t * anything else with it.\n\t */\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t\t__func__, dj_report->device_index);\n\t\treturn false;\n\t}\n\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n\t\tswitch (dj_report->report_type) {\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\t\tbreak;\n\t\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t\t    STATUS_LINKLOSS) {\n\t\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogi_dj_recv_forward_report(djrcv_dev, dj_report);\n\t\t}\n\t\treport_processed = true;\n\t}\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\treturn report_processed;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tdjrcv_dev->querying_devices = false;\n\t\treturn;\n\t}\n\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t__func__, dj_report->device_index);\n\t\treturn;\n\t}\n\n\tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n\t\t/* The device is already known. No need to reallocate it. */\n\t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: hid_allocate_device failed\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\n\tdj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\n\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\"Logitech Unifying Device. Wireless PID:%02x%02x\",\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", dj_report->device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed allocating dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = get_unaligned_le32(\n\t\tdj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = dj_report->device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed adding dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}",
                        "code_after_change": "static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tdjrcv_dev->querying_devices = false;\n\t\treturn;\n\t}\n\n\tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n\t\t/* The device is already known. No need to reallocate it. */\n\t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: hid_allocate_device failed\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\n\tdj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\n\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\"Logitech Unifying Device. Wireless PID:%02x%02x\",\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", dj_report->device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed allocating dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = get_unaligned_le32(\n\t\tdj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = dj_report->device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed adding dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}",
                        "cve_id": "CVE-2014-3182"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 581,
            "cve_id": "CVE-2014-3184",
            "code_snippet": "static __u8 *kye_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_KYE_ERGO_525V:\n\t\t/* the fixups that need to be done:\n\t\t *   - change led usage page to button for extra buttons\n\t\t *   - report size 8 count 1 must be size 1 count 8 for button\n\t\t *     bitfield\n\t\t *   - change the button usage range to 4-7 for the extra\n\t\t *     buttons\n\t\t */\n\t\tif (*rsize >= 75 &&\n\t\t\trdesc[61] == 0x05 && rdesc[62] == 0x08 &&\n\t\t\trdesc[63] == 0x19 && rdesc[64] == 0x08 &&\n\t\t\trdesc[65] == 0x29 && rdesc[66] == 0x0f &&\n\t\t\trdesc[71] == 0x75 && rdesc[72] == 0x08 &&\n\t\t\trdesc[73] == 0x95 && rdesc[74] == 0x01) {\n\t\t\thid_info(hdev,\n\t\t\t\t \"fixing up Kye/Genius Ergo Mouse \"\n\t\t\t\t \"report descriptor\\n\");\n\t\t\trdesc[62] = 0x09;\n\t\t\trdesc[64] = 0x04;\n\t\t\trdesc[66] = 0x07;\n\t\t\trdesc[72] = 0x01;\n\t\t\trdesc[74] = 0x08;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_I405X:\n\t\tif (*rsize == EASYPEN_I405X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_i405x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_i405x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_MOUSEPEN_I608X:\n\t\tif (*rsize == MOUSEPEN_I608X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = mousepen_i608x_rdesc_fixed;\n\t\t\t*rsize = sizeof(mousepen_i608x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_M610X:\n\t\tif (*rsize == EASYPEN_M610X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_m610x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_m610x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Gila Gaming Mouse\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GX_IMPERATOR:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 83,\n\t\t\t\t\t\"Genius Gx Imperator Keyboard\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_MANTICORE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"Genius Manticore Keyboard\");\n\t\tbreak;\n\t}\n\treturn rdesc;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}",
                        "code_after_change": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 31 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}",
                        "cve_id": "CVE-2014-3184"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 582,
            "cve_id": "CVE-2014-3184",
            "code_snippet": "static __u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\tstruct usb_device_descriptor *udesc;\n\t__u16 bcdDevice, rev_maj, rev_min;\n\n\tif ((drv_data->quirks & LG_RDESC) && *rsize >= 91 && rdesc[83] == 0x26 &&\n\t\t\trdesc[84] == 0x8c && rdesc[85] == 0x02) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up Logitech keyboard report descriptor\\n\");\n\t\trdesc[84] = rdesc[89] = 0x4d;\n\t\trdesc[85] = rdesc[90] = 0x10;\n\t}\n\tif ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 51 &&\n\t\t\trdesc[32] == 0x81 && rdesc[33] == 0x06 &&\n\t\t\trdesc[49] == 0x81 && rdesc[50] == 0x06) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up rel/abs in Logitech report descriptor\\n\");\n\t\trdesc[33] = rdesc[50] = 0x02;\n\t}\n\n\tswitch (hdev->product) {\n\n\t/* Several wheels report as this id when operating in emulation mode. */\n\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\tudesc = &(hid_to_usb_dev(hdev)->descriptor);\n\t\tif (!udesc) {\n\t\t\thid_err(hdev, \"NULL USB device descriptor\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\t\trev_maj = bcdDevice >> 8;\n\t\trev_min = bcdDevice & 0xff;\n\n\t\t/* Update the report descriptor for only the Driving Force wheel */\n\t\tif (rev_maj == 1 && rev_min == 2 &&\n\t\t\t\t*rsize == DF_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force report descriptor\\n\");\n\t\t\trdesc = df_rdesc_fixed;\n\t\t\t*rsize = sizeof(df_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tif (*rsize == MOMO_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Force (Red) report descriptor\\n\");\n\t\t\trdesc = momo_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tif (*rsize == MOMO2_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Racing Force (Black) report descriptor\\n\");\n\t\t\trdesc = momo2_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo2_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:\n\t\tif (*rsize == FV_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Formula Vibration report descriptor\\n\");\n\t\t\trdesc = fv_rdesc_fixed;\n\t\t\t*rsize = sizeof(fv_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tif (*rsize == DFP_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force Pro report descriptor\\n\");\n\t\t\trdesc = dfp_rdesc_fixed;\n\t\t\t*rsize = sizeof(dfp_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\tif (*rsize >= 101 && rdesc[41] == 0x95 && rdesc[42] == 0x0B &&\n\t\t\t\trdesc[47] == 0x05 && rdesc[48] == 0x09) {\n\t\t\thid_info(hdev, \"fixing up Logitech Speed Force Wireless report descriptor\\n\");\n\t\t\trdesc[41] = 0x05;\n\t\t\trdesc[42] = 0x09;\n\t\t\trdesc[47] = 0x95;\n\t\t\trdesc[48] = 0x0B;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rdesc;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}",
                        "code_after_change": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 31 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}",
                        "cve_id": "CVE-2014-3184"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 647,
            "cve_id": "CVE-2014-6416",
            "code_snippet": "static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\treturn -EINVAL;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
                        "code_after_change": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *preply = &reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
                        "cve_id": "CVE-2014-6416"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tu8 obuf[0x40], ibuf[0x40];\n\n\tif (!d)\n\t\treturn -ENODEV;\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tswitch (num) {\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase SU3000_STREAM_CTRL:\n\t\t\tobuf[0] = msg[0].buf[0] + 0x36;\n\t\t\tobuf[1] = 3;\n\t\t\tobuf[2] = 0;\n\t\t\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 0, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tbreak;\n\t\tcase DW2102_RC_QUERY:\n\t\t\tobuf[0] = 0x10;\n\t\t\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 2, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tmsg[0].buf[1] = ibuf[0];\n\t\t\tmsg[0].buf[0] = ibuf[1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* always i2c write*/\n\t\t\tobuf[0] = 0x08;\n\t\t\tobuf[1] = msg[0].addr;\n\t\t\tobuf[2] = msg[0].len;\n\n\t\t\tmemcpy(&obuf[3], msg[0].buf, msg[0].len);\n\n\t\t\tif (dvb_usb_generic_rw(d, obuf, msg[0].len + 3,\n\t\t\t\t\t\tibuf, 1, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/* always i2c read */\n\t\tobuf[0] = 0x09;\n\t\tobuf[1] = msg[0].len;\n\t\tobuf[2] = msg[1].len;\n\t\tobuf[3] = msg[0].addr;\n\t\tmemcpy(&obuf[4], msg[0].buf, msg[0].len);\n\n\t\tif (dvb_usb_generic_rw(d, obuf, msg[0].len + 4,\n\t\t\t\t\tibuf, msg[1].len + 1, 0) < 0)\n\t\t\terr(\"i2c transfer failed.\");\n\n\t\tmemcpy(msg[1].buf, &ibuf[1], msg[1].len);\n\t\tbreak;\n\tdefault:\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet.\");\n\t\tbreak;\n\t}\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}",
                        "code_after_change": "static inline int\ncheck_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t\t    e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-8062"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int\ncheck_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->target_offset,\n\t\t\t\t\t    e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}",
                        "code_after_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 829,
            "cve_id": "CVE-2015-4036",
            "code_snippet": "static void\nvhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\t/* TODO: share lun setup code with virtio-scsi.ko */\n\t\t/*\n\t\t * Note: evt->event is zeroed when we allocate it and\n\t\t * lun[4-7] need to be zero according to virtio-scsi spec.\n\t\t */\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int tipc_l2_device_event(struct notifier_block *nb, unsigned long evt,\n\t\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\tstruct tipc_bearer *b;\n\n\tb = rtnl_dereference(dev->tipc_ptr);\n\tif (!b)\n\t\treturn NOTIFY_DONE;\n\n\tb->mtu = dev->mtu;\n\n\tswitch (evt) {\n\tcase NETDEV_CHANGE:\n\t\tif (netif_carrier_ok(dev))\n\t\t\tbreak;\n\tcase NETDEV_UP:\n\t\ttest_and_set_bit_lock(0, &b->up);\n\t\tbreak;\n\tcase NETDEV_GOING_DOWN:\n\t\tclear_bit_unlock(0, &b->up);\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_CHANGEADDR:\n\t\tb->media->raw2addr(b, &b->addr,\n\t\t\t\t   (char *)dev->dev_addr);\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\tcase NETDEV_CHANGENAME:\n\t\tbearer_disable(dev_net(dev), b);\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
                        "code_after_change": "static int tipc_l2_device_event(struct notifier_block *nb, unsigned long evt,\n\t\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\tstruct tipc_bearer *b;\n\n\tb = rtnl_dereference(dev->tipc_ptr);\n\tif (!b)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (evt) {\n\tcase NETDEV_CHANGE:\n\t\tif (netif_carrier_ok(dev))\n\t\t\tbreak;\n\tcase NETDEV_UP:\n\t\ttest_and_set_bit_lock(0, &b->up);\n\t\tbreak;\n\tcase NETDEV_GOING_DOWN:\n\t\tclear_bit_unlock(0, &b->up);\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (tipc_mtu_bad(dev, 0)) {\n\t\t\tbearer_disable(net, b);\n\t\t\tbreak;\n\t\t}\n\t\tb->mtu = dev->mtu;\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_CHANGEADDR:\n\t\tb->media->raw2addr(b, &b->addr,\n\t\t\t\t   (char *)dev->dev_addr);\n\t\ttipc_reset_bearer(net, b);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\tcase NETDEV_CHANGENAME:\n\t\tbearer_disable(dev_net(dev), b);\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
                        "cve_id": "CVE-2016-8632"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static struct se_portal_group *\nvhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\n\tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}",
                        "code_after_change": "static struct se_portal_group *\nvhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\n\tstruct vhost_scsi_tpg *tpg;\n\tu16 tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}",
                        "cve_id": "CVE-2015-4036"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 841,
            "cve_id": "CVE-2015-5283",
            "code_snippet": "static __exit void sctp_exit(void)\n{\n\t/* BUG.  This should probably do something useful like clean\n\t * up all the remaining associations and all that memory.\n\t */\n\n\t/* Unregister with inet6/inet layers. */\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\n\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\n\n\t/* Free protosw registrations */\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\n\tunregister_pernet_subsys(&sctp_defaults_ops);\n\n\t/* Unregister with socket layer. */\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\n\tsctp_sysctl_unregister();\n\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\n\trcu_barrier(); /* Wait for completion of call_rcu()'s */\n\n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static __init int sctp_init(void)\n{\n\tint i;\n\tint status = -EINVAL;\n\tunsigned long goal;\n\tunsigned long limit;\n\tint max_share;\n\tint order;\n\n\tsock_skb_cb_check_size(sizeof(struct sctp_ulpevent));\n\n\t/* Allocate bind_bucket and chunk caches. */\n\tstatus = -ENOBUFS;\n\tsctp_bucket_cachep = kmem_cache_create(\"sctp_bind_bucket\",\n\t\t\t\t\t       sizeof(struct sctp_bind_bucket),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_bucket_cachep)\n\t\tgoto out;\n\n\tsctp_chunk_cachep = kmem_cache_create(\"sctp_chunk\",\n\t\t\t\t\t       sizeof(struct sctp_chunk),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_chunk_cachep)\n\t\tgoto err_chunk_cachep;\n\n\tstatus = percpu_counter_init(&sctp_sockets_allocated, 0, GFP_KERNEL);\n\tif (status)\n\t\tgoto err_percpu_counter_init;\n\n\t/* Implementation specific variables. */\n\n\t/* Initialize default stream count setup information. */\n\tsctp_max_instreams    \t\t= SCTP_DEFAULT_INSTREAMS;\n\tsctp_max_outstreams   \t\t= SCTP_DEFAULT_OUTSTREAMS;\n\n\t/* Initialize handle used for association ids. */\n\tidr_init(&sctp_assocs_id);\n\n\tlimit = nr_free_buffer_pages() / 8;\n\tlimit = max(limit, 128UL);\n\tsysctl_sctp_mem[0] = limit / 4 * 3;\n\tsysctl_sctp_mem[1] = limit;\n\tsysctl_sctp_mem[2] = sysctl_sctp_mem[0] * 2;\n\n\t/* Set per-socket limits to no more than 1/128 the pressure threshold*/\n\tlimit = (sysctl_sctp_mem[1]) << (PAGE_SHIFT - 7);\n\tmax_share = min(4UL*1024*1024, limit);\n\n\tsysctl_sctp_rmem[0] = SK_MEM_QUANTUM; /* give each asoc 1 page min */\n\tsysctl_sctp_rmem[1] = 1500 * SKB_TRUESIZE(1);\n\tsysctl_sctp_rmem[2] = max(sysctl_sctp_rmem[1], max_share);\n\n\tsysctl_sctp_wmem[0] = SK_MEM_QUANTUM;\n\tsysctl_sctp_wmem[1] = 16*1024;\n\tsysctl_sctp_wmem[2] = max(64*1024, max_share);\n\n\t/* Size and allocate the association hash table.\n\t * The methodology is similar to that of the tcp hash tables.\n\t */\n\tif (totalram_pages >= (128 * 1024))\n\t\tgoal = totalram_pages >> (22 - PAGE_SHIFT);\n\telse\n\t\tgoal = totalram_pages >> (24 - PAGE_SHIFT);\n\n\tfor (order = 0; (1UL << order) < goal; order++)\n\t\t;\n\n\tdo {\n\t\tsctp_assoc_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_hashbucket);\n\t\tif ((sctp_assoc_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_assoc_hashtable = (struct sctp_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_assoc_hashtable && --order > 0);\n\tif (!sctp_assoc_hashtable) {\n\t\tpr_err(\"Failed association hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ahash_alloc;\n\t}\n\tfor (i = 0; i < sctp_assoc_hashsize; i++) {\n\t\trwlock_init(&sctp_assoc_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_assoc_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the endpoint hash table.  */\n\tsctp_ep_hashsize = 64;\n\tsctp_ep_hashtable =\n\t\tkmalloc(64 * sizeof(struct sctp_hashbucket), GFP_KERNEL);\n\tif (!sctp_ep_hashtable) {\n\t\tpr_err(\"Failed endpoint_hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ehash_alloc;\n\t}\n\tfor (i = 0; i < sctp_ep_hashsize; i++) {\n\t\trwlock_init(&sctp_ep_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_ep_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the SCTP port hash table.  */\n\tdo {\n\t\tsctp_port_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_bind_hashbucket);\n\t\tif ((sctp_port_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_port_hashtable = (struct sctp_bind_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_port_hashtable && --order > 0);\n\tif (!sctp_port_hashtable) {\n\t\tpr_err(\"Failed bind hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_bhash_alloc;\n\t}\n\tfor (i = 0; i < sctp_port_hashsize; i++) {\n\t\tspin_lock_init(&sctp_port_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_port_hashtable[i].chain);\n\t}\n\n\tpr_info(\"Hash tables configured (established %d bind %d)\\n\",\n\t\tsctp_assoc_hashsize, sctp_port_hashsize);\n\n\tsctp_sysctl_register();\n\n\tINIT_LIST_HEAD(&sctp_address_families);\n\tsctp_v4_pf_init();\n\tsctp_v6_pf_init();\n\n\tstatus = sctp_v4_protosw_init();\n\n\tif (status)\n\t\tgoto err_protosw_init;\n\n\tstatus = sctp_v6_protosw_init();\n\tif (status)\n\t\tgoto err_v6_protosw_init;\n\n\tstatus = register_pernet_subsys(&sctp_net_ops);\n\tif (status)\n\t\tgoto err_register_pernet_subsys;\n\n\tstatus = sctp_v4_add_protocol();\n\tif (status)\n\t\tgoto err_add_protocol;\n\n\t/* Register SCTP with inet6 layer.  */\n\tstatus = sctp_v6_add_protocol();\n\tif (status)\n\t\tgoto err_v6_add_protocol;\n\nout:\n\treturn status;\nerr_v6_add_protocol:\n\tsctp_v4_del_protocol();\nerr_add_protocol:\n\tunregister_pernet_subsys(&sctp_net_ops);\nerr_register_pernet_subsys:\n\tsctp_v6_protosw_exit();\nerr_v6_protosw_init:\n\tsctp_v4_protosw_exit();\nerr_protosw_init:\n\tsctp_v4_pf_exit();\n\tsctp_v6_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\nerr_bhash_alloc:\n\tkfree(sctp_ep_hashtable);\nerr_ehash_alloc:\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\nerr_ahash_alloc:\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\nerr_percpu_counter_init:\n\tkmem_cache_destroy(sctp_chunk_cachep);\nerr_chunk_cachep:\n\tkmem_cache_destroy(sctp_bucket_cachep);\n\tgoto out;\n}",
                        "code_after_change": "static __init int sctp_init(void)\n{\n\tint i;\n\tint status = -EINVAL;\n\tunsigned long goal;\n\tunsigned long limit;\n\tint max_share;\n\tint order;\n\n\tsock_skb_cb_check_size(sizeof(struct sctp_ulpevent));\n\n\t/* Allocate bind_bucket and chunk caches. */\n\tstatus = -ENOBUFS;\n\tsctp_bucket_cachep = kmem_cache_create(\"sctp_bind_bucket\",\n\t\t\t\t\t       sizeof(struct sctp_bind_bucket),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_bucket_cachep)\n\t\tgoto out;\n\n\tsctp_chunk_cachep = kmem_cache_create(\"sctp_chunk\",\n\t\t\t\t\t       sizeof(struct sctp_chunk),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_chunk_cachep)\n\t\tgoto err_chunk_cachep;\n\n\tstatus = percpu_counter_init(&sctp_sockets_allocated, 0, GFP_KERNEL);\n\tif (status)\n\t\tgoto err_percpu_counter_init;\n\n\t/* Implementation specific variables. */\n\n\t/* Initialize default stream count setup information. */\n\tsctp_max_instreams    \t\t= SCTP_DEFAULT_INSTREAMS;\n\tsctp_max_outstreams   \t\t= SCTP_DEFAULT_OUTSTREAMS;\n\n\t/* Initialize handle used for association ids. */\n\tidr_init(&sctp_assocs_id);\n\n\tlimit = nr_free_buffer_pages() / 8;\n\tlimit = max(limit, 128UL);\n\tsysctl_sctp_mem[0] = limit / 4 * 3;\n\tsysctl_sctp_mem[1] = limit;\n\tsysctl_sctp_mem[2] = sysctl_sctp_mem[0] * 2;\n\n\t/* Set per-socket limits to no more than 1/128 the pressure threshold*/\n\tlimit = (sysctl_sctp_mem[1]) << (PAGE_SHIFT - 7);\n\tmax_share = min(4UL*1024*1024, limit);\n\n\tsysctl_sctp_rmem[0] = SK_MEM_QUANTUM; /* give each asoc 1 page min */\n\tsysctl_sctp_rmem[1] = 1500 * SKB_TRUESIZE(1);\n\tsysctl_sctp_rmem[2] = max(sysctl_sctp_rmem[1], max_share);\n\n\tsysctl_sctp_wmem[0] = SK_MEM_QUANTUM;\n\tsysctl_sctp_wmem[1] = 16*1024;\n\tsysctl_sctp_wmem[2] = max(64*1024, max_share);\n\n\t/* Size and allocate the association hash table.\n\t * The methodology is similar to that of the tcp hash tables.\n\t */\n\tif (totalram_pages >= (128 * 1024))\n\t\tgoal = totalram_pages >> (22 - PAGE_SHIFT);\n\telse\n\t\tgoal = totalram_pages >> (24 - PAGE_SHIFT);\n\n\tfor (order = 0; (1UL << order) < goal; order++)\n\t\t;\n\n\tdo {\n\t\tsctp_assoc_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_hashbucket);\n\t\tif ((sctp_assoc_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_assoc_hashtable = (struct sctp_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_assoc_hashtable && --order > 0);\n\tif (!sctp_assoc_hashtable) {\n\t\tpr_err(\"Failed association hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ahash_alloc;\n\t}\n\tfor (i = 0; i < sctp_assoc_hashsize; i++) {\n\t\trwlock_init(&sctp_assoc_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_assoc_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the endpoint hash table.  */\n\tsctp_ep_hashsize = 64;\n\tsctp_ep_hashtable =\n\t\tkmalloc(64 * sizeof(struct sctp_hashbucket), GFP_KERNEL);\n\tif (!sctp_ep_hashtable) {\n\t\tpr_err(\"Failed endpoint_hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ehash_alloc;\n\t}\n\tfor (i = 0; i < sctp_ep_hashsize; i++) {\n\t\trwlock_init(&sctp_ep_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_ep_hashtable[i].chain);\n\t}\n\n\t/* Allocate and initialize the SCTP port hash table.  */\n\tdo {\n\t\tsctp_port_hashsize = (1UL << order) * PAGE_SIZE /\n\t\t\t\t\tsizeof(struct sctp_bind_hashbucket);\n\t\tif ((sctp_port_hashsize > (64 * 1024)) && order > 0)\n\t\t\tcontinue;\n\t\tsctp_port_hashtable = (struct sctp_bind_hashbucket *)\n\t\t\t__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);\n\t} while (!sctp_port_hashtable && --order > 0);\n\tif (!sctp_port_hashtable) {\n\t\tpr_err(\"Failed bind hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_bhash_alloc;\n\t}\n\tfor (i = 0; i < sctp_port_hashsize; i++) {\n\t\tspin_lock_init(&sctp_port_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_port_hashtable[i].chain);\n\t}\n\n\tpr_info(\"Hash tables configured (established %d bind %d)\\n\",\n\t\tsctp_assoc_hashsize, sctp_port_hashsize);\n\n\tsctp_sysctl_register();\n\n\tINIT_LIST_HEAD(&sctp_address_families);\n\tsctp_v4_pf_init();\n\tsctp_v6_pf_init();\n\n\tstatus = register_pernet_subsys(&sctp_defaults_ops);\n\tif (status)\n\t\tgoto err_register_defaults;\n\n\tstatus = sctp_v4_protosw_init();\n\tif (status)\n\t\tgoto err_protosw_init;\n\n\tstatus = sctp_v6_protosw_init();\n\tif (status)\n\t\tgoto err_v6_protosw_init;\n\n\tstatus = register_pernet_subsys(&sctp_ctrlsock_ops);\n\tif (status)\n\t\tgoto err_register_ctrlsock;\n\n\tstatus = sctp_v4_add_protocol();\n\tif (status)\n\t\tgoto err_add_protocol;\n\n\t/* Register SCTP with inet6 layer.  */\n\tstatus = sctp_v6_add_protocol();\n\tif (status)\n\t\tgoto err_v6_add_protocol;\n\nout:\n\treturn status;\nerr_v6_add_protocol:\n\tsctp_v4_del_protocol();\nerr_add_protocol:\n\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\nerr_register_ctrlsock:\n\tsctp_v6_protosw_exit();\nerr_v6_protosw_init:\n\tsctp_v4_protosw_exit();\nerr_protosw_init:\n\tunregister_pernet_subsys(&sctp_defaults_ops);\nerr_register_defaults:\n\tsctp_v4_pf_exit();\n\tsctp_v6_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\nerr_bhash_alloc:\n\tkfree(sctp_ep_hashtable);\nerr_ehash_alloc:\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\nerr_ahash_alloc:\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\nerr_percpu_counter_init:\n\tkmem_cache_destroy(sctp_chunk_cachep);\nerr_chunk_cachep:\n\tkmem_cache_destroy(sctp_bucket_cachep);\n\tgoto out;\n}",
                        "cve_id": "CVE-2015-5283"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1030,
            "cve_id": "CVE-2016-3134",
            "code_snippet": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static bool check_underflow(const struct ipt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(&e->ip))\n\t\treturn false;\n\tt = ipt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
                        "code_after_change": "static bool check_underflow(const struct ipt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = ipt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1031,
            "cve_id": "CVE-2016-3134",
            "code_snippet": "static int mark_source_chains(const struct xt_table_info *newinfo,\n\t\t\t      unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t * to 0 as we leave), and comefrom to save source hook bitmask.\n\t */\n\tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct arpt_entry *e\n\t\t\t= (struct arpt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)arpt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {\n\t\t\t\tpr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom\n\t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t * big jump.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct arpt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ip6t_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct ip6t_entry) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 &&\n\t\t\t     unconditional(&e->ipv6)) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ip6t_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
                        "code_after_change": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ip6t_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ip6t_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1032,
            "cve_id": "CVE-2016-3134",
            "code_snippet": "static int\ncheck_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
                        "code_after_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int\ncheck_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->target_offset,\n\t\t\t\t\t    e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}",
                        "code_after_change": "static inline int\ncheck_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t\t    e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "NO"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 0
        },
        {
            "id": 1033,
            "cve_id": "CVE-2016-3134",
            "code_snippet": "static inline int\nget_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (unconditional(s) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int\nget_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
                        "code_after_change": "static inline int\nget_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (unconditional(s) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1034,
            "cve_id": "CVE-2016-3134",
            "code_snippet": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ipt_entry *e = (struct ipt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ipt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ipt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ip6t_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct ip6t_entry) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 &&\n\t\t\t     unconditional(&e->ipv6)) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ip6t_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
                        "code_after_change": "static int\nmark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ip6t_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ip6t_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
                        "code_after_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1113,
            "cve_id": "CVE-2016-4998",
            "code_snippet": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int\ncheck_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->target_offset,\n\t\t\t\t\t    e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}",
                        "code_after_change": "static inline int\ncheck_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t\t    e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1114,
            "cve_id": "CVE-2016-4998",
            "code_snippet": "static int\ncheck_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "code_after_change": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
                        "cve_id": "CVE-2016-3134"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
                        "code_after_change": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
                        "cve_id": "CVE-2016-4998"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1201,
            "cve_id": "CVE-2016-8632",
            "code_snippet": "int tipc_enable_l2_media(struct net *net, struct tipc_bearer *b,\n\t\t\t struct nlattr *attr[])\n{\n\tstruct net_device *dev;\n\tchar *driver_name = strchr((const char *)b->name, ':') + 1;\n\n\t/* Find device with specified name */\n\tdev = dev_get_by_name(net, driver_name);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tif (tipc_mtu_bad(dev, 0)) {\n\t\tdev_put(dev);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Associate TIPC bearer with L2 bearer */\n\trcu_assign_pointer(b->media_ptr, dev);\n\tmemset(&b->bcast_addr, 0, sizeof(b->bcast_addr));\n\tmemcpy(b->bcast_addr.value, dev->broadcast, b->media->hwaddr_len);\n\tb->bcast_addr.media_id = b->media->type_id;\n\tb->bcast_addr.broadcast = 1;\n\tb->mtu = dev->mtu;\n\tb->media->raw2addr(b, &b->addr, (char *)dev->dev_addr);\n\trcu_assign_pointer(dev->tipc_ptr, b);\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int tipc_udp_enable(struct net *net, struct tipc_bearer *b,\n\t\t\t   struct nlattr *attrs[])\n{\n\tint err = -EINVAL;\n\tstruct udp_bearer *ub;\n\tstruct udp_media_addr remote = {0};\n\tstruct udp_media_addr local = {0};\n\tstruct udp_port_cfg udp_conf = {0};\n\tstruct udp_tunnel_sock_cfg tuncfg = {NULL};\n\tstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\n\n\tub = kzalloc(sizeof(*ub), GFP_ATOMIC);\n\tif (!ub)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ub->rcast.list);\n\n\tif (!attrs[TIPC_NLA_BEARER_UDP_OPTS])\n\t\tgoto err;\n\n\tif (nla_parse_nested(opts, TIPC_NLA_UDP_MAX,\n\t\t\t     attrs[TIPC_NLA_BEARER_UDP_OPTS],\n\t\t\t     tipc_nl_udp_policy))\n\t\tgoto err;\n\n\tif (!opts[TIPC_NLA_UDP_LOCAL] || !opts[TIPC_NLA_UDP_REMOTE]) {\n\t\tpr_err(\"Invalid UDP bearer configuration\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_LOCAL], &local,\n\t\t\t\t  &ub->ifindex);\n\tif (err)\n\t\tgoto err;\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_REMOTE], &remote, NULL);\n\tif (err)\n\t\tgoto err;\n\n\tb->bcast_addr.media_id = TIPC_MEDIA_TYPE_UDP;\n\tb->bcast_addr.broadcast = 1;\n\trcu_assign_pointer(b->media_ptr, ub);\n\trcu_assign_pointer(ub->bearer, b);\n\ttipc_udp_media_addr_set(&b->addr, &local);\n\tif (local.proto == htons(ETH_P_IP)) {\n\t\tstruct net_device *dev;\n\n\t\tdev = __ip_dev_find(net, local.ipv4.s_addr, false);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tudp_conf.family = AF_INET;\n\t\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n\t\tudp_conf.use_udp_checksums = false;\n\t\tub->ifindex = dev->ifindex;\n\t\tb->mtu = dev->mtu - sizeof(struct iphdr)\n\t\t\t- sizeof(struct udphdr);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (local.proto == htons(ETH_P_IPV6)) {\n\t\tudp_conf.family = AF_INET6;\n\t\tudp_conf.use_udp6_tx_checksums = true;\n\t\tudp_conf.use_udp6_rx_checksums = true;\n\t\tudp_conf.local_ip6 = in6addr_any;\n\t\tb->mtu = 1280;\n#endif\n\t} else {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto err;\n\t}\n\tudp_conf.local_udp_port = local.port;\n\terr = udp_sock_create(net, &udp_conf, &ub->ubsock);\n\tif (err)\n\t\tgoto err;\n\ttuncfg.sk_user_data = ub;\n\ttuncfg.encap_type = 1;\n\ttuncfg.encap_rcv = tipc_udp_recv;\n\ttuncfg.encap_destroy = NULL;\n\tsetup_udp_tunnel_sock(net, ub->ubsock, &tuncfg);\n\n\t/**\n\t * The bcast media address port is used for all peers and the ip\n\t * is used if it's a multicast address.\n\t */\n\tmemcpy(&b->bcast_addr.value, &remote, sizeof(remote));\n\tif (tipc_udp_is_mcast_addr(&remote))\n\t\terr = enable_mcast(ub, &remote);\n\telse\n\t\terr = tipc_udp_rcast_add(b, &remote);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tif (ub->ubsock)\n\t\tudp_tunnel_sock_release(ub->ubsock);\n\tkfree(ub);\n\treturn err;\n}",
                        "code_after_change": "static int tipc_udp_enable(struct net *net, struct tipc_bearer *b,\n\t\t\t   struct nlattr *attrs[])\n{\n\tint err = -EINVAL;\n\tstruct udp_bearer *ub;\n\tstruct udp_media_addr remote = {0};\n\tstruct udp_media_addr local = {0};\n\tstruct udp_port_cfg udp_conf = {0};\n\tstruct udp_tunnel_sock_cfg tuncfg = {NULL};\n\tstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\n\n\tub = kzalloc(sizeof(*ub), GFP_ATOMIC);\n\tif (!ub)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ub->rcast.list);\n\n\tif (!attrs[TIPC_NLA_BEARER_UDP_OPTS])\n\t\tgoto err;\n\n\tif (nla_parse_nested(opts, TIPC_NLA_UDP_MAX,\n\t\t\t     attrs[TIPC_NLA_BEARER_UDP_OPTS],\n\t\t\t     tipc_nl_udp_policy))\n\t\tgoto err;\n\n\tif (!opts[TIPC_NLA_UDP_LOCAL] || !opts[TIPC_NLA_UDP_REMOTE]) {\n\t\tpr_err(\"Invalid UDP bearer configuration\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_LOCAL], &local,\n\t\t\t\t  &ub->ifindex);\n\tif (err)\n\t\tgoto err;\n\n\terr = tipc_parse_udp_addr(opts[TIPC_NLA_UDP_REMOTE], &remote, NULL);\n\tif (err)\n\t\tgoto err;\n\n\tb->bcast_addr.media_id = TIPC_MEDIA_TYPE_UDP;\n\tb->bcast_addr.broadcast = 1;\n\trcu_assign_pointer(b->media_ptr, ub);\n\trcu_assign_pointer(ub->bearer, b);\n\ttipc_udp_media_addr_set(&b->addr, &local);\n\tif (local.proto == htons(ETH_P_IP)) {\n\t\tstruct net_device *dev;\n\n\t\tdev = __ip_dev_find(net, local.ipv4.s_addr, false);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tudp_conf.family = AF_INET;\n\t\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n\t\tudp_conf.use_udp_checksums = false;\n\t\tub->ifindex = dev->ifindex;\n\t\tif (tipc_mtu_bad(dev, sizeof(struct iphdr) +\n\t\t\t\t      sizeof(struct udphdr))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tb->mtu = dev->mtu - sizeof(struct iphdr)\n\t\t\t- sizeof(struct udphdr);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (local.proto == htons(ETH_P_IPV6)) {\n\t\tudp_conf.family = AF_INET6;\n\t\tudp_conf.use_udp6_tx_checksums = true;\n\t\tudp_conf.use_udp6_rx_checksums = true;\n\t\tudp_conf.local_ip6 = in6addr_any;\n\t\tb->mtu = 1280;\n#endif\n\t} else {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto err;\n\t}\n\tudp_conf.local_udp_port = local.port;\n\terr = udp_sock_create(net, &udp_conf, &ub->ubsock);\n\tif (err)\n\t\tgoto err;\n\ttuncfg.sk_user_data = ub;\n\ttuncfg.encap_type = 1;\n\ttuncfg.encap_rcv = tipc_udp_recv;\n\ttuncfg.encap_destroy = NULL;\n\tsetup_udp_tunnel_sock(net, ub->ubsock, &tuncfg);\n\n\t/**\n\t * The bcast media address port is used for all peers and the ip\n\t * is used if it's a multicast address.\n\t */\n\tmemcpy(&b->bcast_addr.value, &remote, sizeof(remote));\n\tif (tipc_udp_is_mcast_addr(&remote))\n\t\terr = enable_mcast(ub, &remote);\n\telse\n\t\terr = tipc_udp_rcast_add(b, &remote);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tif (ub->ubsock)\n\t\tudp_tunnel_sock_release(ub->ubsock);\n\tkfree(ub);\n\treturn err;\n}",
                        "cve_id": "CVE-2016-8632"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1204,
            "cve_id": "CVE-2016-8633",
            "code_snippet": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (length > IEEE1394_GASP_HDR_SIZE &&\n\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&\n\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION\n#endif\n\t    ))\n\t\tfwnet_incoming_packet(dev, buf_ptr + 2,\n\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,\n\t\t\t\t      gasp_source_id(buf_ptr),\n\t\t\t\t      context->card->generation, true);\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\t/* A datagram fragment has been received, now the fun begins. */\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
                        "code_after_change": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\tif (len <= RFC2374_UNFRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\n\t/* A datagram fragment has been received, now the fun begins. */\n\n\tif (len <= RFC2374_FRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tif (fg_off + len > dg_size)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
                        "cve_id": "CVE-2016-8633"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1345,
            "cve_id": "CVE-2017-12762",
            "code_snippet": "char *\nisdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\n\tif (p) {\n\t\t/* Slave-Name MUST not be empty or overflow 'newname' */\n\t\tif (strscpy(newname, p + 1, sizeof(newname)) <= 0)\n\t\t\treturn NULL;\n\t\t*p = 0;\n\t\t/* Master must already exist */\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\t/* Master must be a real interface, not a slave */\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\t/* Master must not be started yet */\n\t\tif (isdn_net_device_started(n))\n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int\nisdn_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(file_inode(file));\n\tisdn_ctrl c;\n\tint drvidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\tcase IIOCGETDVR:\n\t\t\treturn (TTY_DV +\n\t\t\t\t(NET_DV << 8) +\n\t\t\t\t(INF_DV << 16));\n\t\tcase IIOCGETCPS:\n\t\t\tif (arg) {\n\t\t\t\tulong __user *p = argp;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCNETGPN:\n\t\t\t/* Get peer phone number of a connected\n\t\t\t * isdn network interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefore, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\tcase IIOCNETDWRSET:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\treturn (-EINVAL);\n\t\tcase IIOCNETLCR:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\treturn -ENODEV;\n\t\tcase IIOCNETAIF:\n\t\t\t/* Add a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\ts = name;\n\t\t\t} else {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETASL:\n\t\t\t/* Add a slave to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETDIF:\n\t\t\t/* Delete a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETSCF:\n\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGCF:\n\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETANM:\n\t\t\t/* Add a phone-number to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGNM:\n\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDNM:\n\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDIL:\n\t\t\t/* Force dialing of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase IIOCNETALN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_dial_slave(name);\n\t\tcase IIOCNETDLN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\tcase IIOCNETHUP:\n\t\t\t/* Force hangup of a network-interface */\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_net_force_hangup(name);\n\t\t\tbreak;\n\t\tcase IIOCSETVER:\n\t\t\tdev->net_verbose = arg;\n\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\treturn 0;\n\t\tcase IIOCSETGST:\n\t\t\tif (arg)\n\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\telse\n\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\treturn 0;\n\t\tcase IIOCSETBRJ:\n\t\t\tdrvidx = -1;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drvidx == -1)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (iocts.arg)\n\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\telse\n\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\treturn 0;\n\t\tcase IIOCSIGPRF:\n\t\t\tdev->profd = current;\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase IIOCGETPRF:\n\t\t\t/* Get all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t\t ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t}\n\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETPRF:\n\t\t\t/* Set all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t\t   ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETMAP:\n\t\tcase IIOCGETMAP:\n\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\tif (arg) {\n\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\tsnprintf(bname, sizeof(bname), \"%s%s\",\n\t\t\t\t\t\t\t strlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t dev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t (i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCDBGVAR:\n\t\t\tif (arg) {\n\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tc.driver = drvidx;\n\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\tc.arg = cmd;\n\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\tret = isdn_command(&c);\n\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}",
                        "code_after_change": "static int\nisdn_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(file_inode(file));\n\tisdn_ctrl c;\n\tint drvidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\tcase IIOCGETDVR:\n\t\t\treturn (TTY_DV +\n\t\t\t\t(NET_DV << 8) +\n\t\t\t\t(INF_DV << 16));\n\t\tcase IIOCGETCPS:\n\t\t\tif (arg) {\n\t\t\t\tulong __user *p = argp;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCNETGPN:\n\t\t\t/* Get peer phone number of a connected\n\t\t\t * isdn network interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefore, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\tcase IIOCNETDWRSET:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\treturn (-EINVAL);\n\t\tcase IIOCNETLCR:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\treturn -ENODEV;\n\t\tcase IIOCNETAIF:\n\t\t\t/* Add a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\ts = name;\n\t\t\t} else {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETASL:\n\t\t\t/* Add a slave to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbname[sizeof(bname)-1] = 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETDIF:\n\t\t\t/* Delete a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETSCF:\n\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGCF:\n\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETANM:\n\t\t\t/* Add a phone-number to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETGNM:\n\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDNM:\n\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif (ret) return ret;\n\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCNETDIL:\n\t\t\t/* Force dialing of a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase IIOCNETALN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_dial_slave(name);\n\t\tcase IIOCNETDLN:\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\tcase IIOCNETHUP:\n\t\t\t/* Force hangup of a network-interface */\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn isdn_net_force_hangup(name);\n\t\t\tbreak;\n\t\tcase IIOCSETVER:\n\t\t\tdev->net_verbose = arg;\n\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\treturn 0;\n\t\tcase IIOCSETGST:\n\t\t\tif (arg)\n\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\telse\n\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\treturn 0;\n\t\tcase IIOCSETBRJ:\n\t\t\tdrvidx = -1;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drvidx == -1)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (iocts.arg)\n\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\telse\n\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\treturn 0;\n\t\tcase IIOCSIGPRF:\n\t\t\tdev->profd = current;\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase IIOCGETPRF:\n\t\t\t/* Get all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t\t ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t}\n\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETPRF:\n\t\t\t/* Set all Modem-Profiles */\n\t\t\tif (arg) {\n\t\t\t\tchar __user *p = argp;\n\t\t\t\tint i;\n\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t\t   ISDN_MODEM_NUMREG))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCSETMAP:\n\t\tcase IIOCGETMAP:\n\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\tif (arg) {\n\n\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t\t   sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\tsnprintf(bname, sizeof(bname), \"%s%s\",\n\t\t\t\t\t\t\t strlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t dev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t (i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tcase IIOCDBGVAR:\n\t\t\tif (arg) {\n\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (arg) {\n\t\t\t\tint i;\n\t\t\t\tchar *p;\n\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tiocts.drvid[sizeof(iocts.drvid) - 1] = 0;\n\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tdrvidx = 0;\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tc.driver = drvidx;\n\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\tc.arg = cmd;\n\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\tret = isdn_command(&c);\n\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}",
                        "cve_id": "CVE-2017-12762"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1379,
            "cve_id": "CVE-2017-15126",
            "code_snippet": "static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\t/*\n\t\t\t\t * fork_nctx can be freed as soon as\n\t\t\t\t * we drop the lock, unless we take a\n\t\t\t\t * reference on it.\n\t\t\t\t */\n\t\t\t\tuserfaultfd_ctx_get(fork_nctx);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tif (!list_empty(&fork_event)) {\n\t\t\t/*\n\t\t\t * The fork thread didn't abort, so we can\n\t\t\t * drop the temporary refcount.\n\t\t\t */\n\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\n\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t       wq.entry);\n\t\t\t/*\n\t\t\t * If fork_event list wasn't empty and in turn\n\t\t\t * the event wasn't already released by fork\n\t\t\t * (the event is allocated on fork kernel\n\t\t\t * stack), put the event back to its place in\n\t\t\t * the event_wq. fork_event head will be freed\n\t\t\t * as soon as we return so the event cannot\n\t\t\t * stay queued there no matter the current\n\t\t\t * \"ret\" value.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\n\t\t\t/*\n\t\t\t * Leave the event in the waitqueue and report\n\t\t\t * error to userland if we failed to resolve\n\t\t\t * the userfault fork.\n\t\t\t */\n\t\t\tif (likely(!ret))\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Here the fork thread aborted and the\n\t\t\t * refcount from the fork thread on fork_nctx\n\t\t\t * has already been released. We still hold\n\t\t\t * the reference we took before releasing the\n\t\t\t * lock above. If resolve_userfault_fork\n\t\t\t * failed we've to drop it because the\n\t\t\t * fork_nctx has to be freed in such case. If\n\t\t\t * it succeeded we'll hold it because the new\n\t\t\t * uffd references it.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t}\n\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}",
                        "code_after_change": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}",
                        "cve_id": "CVE-2017-15126"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1392,
            "cve_id": "CVE-2017-16526",
            "code_snippet": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tif (rc->uwbd.task)\n\t\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}",
                        "code_after_change": "void uwbd_start(struct uwb_rc *rc)\n{\n\tstruct task_struct *task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (IS_ERR(task)) {\n\t\trc->uwbd.task = NULL;\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\t} else {\n\t\trc->uwbd.task = task;\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n\t}\n}",
                        "cve_id": "CVE-2017-16526"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1437,
            "cve_id": "CVE-2017-16996",
            "code_snippet": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno, int off,\n\t\t\t    int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* ctx accesses must be at a fixed offset, so that we can\n\t\t * determine what type of data were returned.\n\t\t */\n\t\tif (reg->off) {\n\t\t\tverbose(env,\n\t\t\t\t\"dereference of modified ctx ptr R%d off=%d+%d, ctx+const is allowed, ctx+const+const is not\\n\",\n\t\t\t\tregno, reg->off, off - reg->off);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env,\n\t\t\t\t\"variable ctx access var_off=%s off=%d size=%d\",\n\t\t\t\ttn_buf, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE)\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\telse\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\tregs[value_regno].id = 0;\n\t\t\tregs[value_regno].off = 0;\n\t\t\tregs[value_regno].range = 0;\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* stack accesses must be at a fixed offset, so that we can\n\t\t * determine what type of data were returned.\n\t\t * See check_stack_read().\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"variable stack access var_off=%s off=%d size=%d\",\n\t\t\t\ttn_buf, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\toff += reg->var_off.value;\n\t\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\t\tverbose(env, \"invalid stack off=%d size=%d\\n\", off,\n\t\t\t\tsize);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (env->prog->aux->stack_depth < -off)\n\t\t\tenv->prog->aux->stack_depth = -off;\n\n\t\tif (t == BPF_WRITE)\n\t\t\terr = check_stack_write(env, state, off, size,\n\t\t\t\t\t\tvalue_regno);\n\t\telse\n\t\t\terr = check_stack_read(env, state, off, size,\n\t\t\t\t\t       value_regno);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str[reg->type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (base_type(reg->type) == PTR_TO_MEM) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\n\t\tif (type_may_be_null(reg->type)) {\n\t\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\t\treg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && rdonly_mem) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && value_regno >= 0 && (t == BPF_READ || rdonly_mem))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf, &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (base_type(reg_type) == PTR_TO_BTF_ID) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = func(env, reg);\n\t\terr = update_stack_depth(env, state, off);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_BTF_ID) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BUF) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\t\tconst char *buf_info;\n\t\tu32 *max_access;\n\n\t\tif (rdonly_mem) {\n\t\t\tif (t == BPF_WRITE) {\n\t\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tbuf_info = \"rdonly\";\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tbuf_info = \"rdwr\";\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  buf_info, max_access);\n\n\t\tif (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
                        "code_after_change": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (base_type(reg->type) == PTR_TO_MEM) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\n\t\tif (type_may_be_null(reg->type)) {\n\t\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\t\treg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && rdonly_mem) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && value_regno >= 0 && (t == BPF_READ || rdonly_mem))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ptr_off_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf, &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (base_type(reg_type) == PTR_TO_BTF_ID) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = func(env, reg);\n\t\terr = update_stack_depth(env, state, off);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_BTF_ID) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BUF) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\t\tconst char *buf_info;\n\t\tu32 *max_access;\n\n\t\tif (rdonly_mem) {\n\t\t\tif (t == BPF_WRITE) {\n\t\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tbuf_info = \"rdonly\";\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tbuf_info = \"rdwr\";\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  buf_info, max_access);\n\n\t\tif (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
                        "cve_id": "CVE-2021-4204"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1491,
            "cve_id": "CVE-2017-18222",
            "code_snippet": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
                        "code_after_change": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-18222"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1546,
            "cve_id": "CVE-2017-5547",
            "code_snippet": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = brightness;\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}",
                        "code_after_change": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-5547"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1549,
            "cve_id": "CVE-2017-5548",
            "code_snippet": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar *build;\n\tint ret;\n\n\tbuild = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);\n\tif (!build)\n\t\treturn -ENOMEM;\n\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\n\tkfree(build);\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\treturn ret;\n}",
                        "code_after_change": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(3, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-5548"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1618,
            "cve_id": "CVE-2017-7895",
            "code_snippet": "int\nnfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tstruct kvec *tail = rqstp->rq_arg.tail;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\tif ((void *)p > head->iov_base + head->iov_len)\n\t\treturn 0;\n\t/*\n\t * The count must equal the amount of data passed.\n\t */\n\tif (args->count != args->len)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "int\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
                        "code_after_change": "int\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
                        "cve_id": "CVE-2017-7895"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1623,
            "cve_id": "CVE-2017-8062",
            "code_snippet": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tint ret = 0;\n\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\n\tif (i && !state->initialized) {\n\t\tmutex_lock(&d->data_mutex);\n\n\t\tstate->data[0] = 0xde;\n\t\tstate->data[1] = 0;\n\n\t\tstate->initialized = 1;\n\t\t/* reset board */\n\t\tret = dvb_usb_generic_rw(d, state->data, 2, NULL, 0, 0);\n\t\tmutex_unlock(&d->data_mutex);\n\t}\n\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\two = (rbuf == NULL || rlen == 0); /* write-only */\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}",
                        "code_after_change": "static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t\t\t\t\t\tint num)\n{\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tstruct dw2102_state *state;\n\n\tif (!d)\n\t\treturn -ENODEV;\n\n\tstate = d->priv;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\tif (mutex_lock_interruptible(&d->data_mutex) < 0) {\n\t\tmutex_unlock(&d->i2c_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\tswitch (num) {\n\tcase 1:\n\t\tswitch (msg[0].addr) {\n\t\tcase SU3000_STREAM_CTRL:\n\t\t\tstate->data[0] = msg[0].buf[0] + 0x36;\n\t\t\tstate->data[1] = 3;\n\t\t\tstate->data[2] = 0;\n\t\t\tif (dvb_usb_generic_rw(d, state->data, 3,\n\t\t\t\t\tstate->data, 0, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tbreak;\n\t\tcase DW2102_RC_QUERY:\n\t\t\tstate->data[0] = 0x10;\n\t\t\tif (dvb_usb_generic_rw(d, state->data, 1,\n\t\t\t\t\tstate->data, 2, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tmsg[0].buf[1] = state->data[0];\n\t\t\tmsg[0].buf[0] = state->data[1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* always i2c write*/\n\t\t\tstate->data[0] = 0x08;\n\t\t\tstate->data[1] = msg[0].addr;\n\t\t\tstate->data[2] = msg[0].len;\n\n\t\t\tmemcpy(&state->data[3], msg[0].buf, msg[0].len);\n\n\t\t\tif (dvb_usb_generic_rw(d, state->data, msg[0].len + 3,\n\t\t\t\t\t\tstate->data, 1, 0) < 0)\n\t\t\t\terr(\"i2c transfer failed.\");\n\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/* always i2c read */\n\t\tstate->data[0] = 0x09;\n\t\tstate->data[1] = msg[0].len;\n\t\tstate->data[2] = msg[1].len;\n\t\tstate->data[3] = msg[0].addr;\n\t\tmemcpy(&state->data[4], msg[0].buf, msg[0].len);\n\n\t\tif (dvb_usb_generic_rw(d, state->data, msg[0].len + 4,\n\t\t\t\t\tstate->data, msg[1].len + 1, 0) < 0)\n\t\t\terr(\"i2c transfer failed.\");\n\n\t\tmemcpy(msg[1].buf, &state->data[1], msg[1].len);\n\t\tbreak;\n\tdefault:\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet.\");\n\t\tbreak;\n\t}\n\tmutex_unlock(&d->data_mutex);\n\tmutex_unlock(&d->i2c_mutex);\n\treturn num;\n}",
                        "cve_id": "CVE-2017-8063"
                    },
                    "vul_output": "NO"
                },
                {
                    "vul_knowledge": {
                        "code_before_change": "static int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tobuf[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\t/* attach demod */\n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.spec_inv = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.agc_inv = 0;\n\tm88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;\n\tm88ds3103_pdata.envelope_mode = 0;\n\tm88ds3103_pdata.lnb_hv_pol = 1;\n\tm88ds3103_pdata.lnb_en_pol = 0;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x68;\n\tboard_info.platform_data = &m88ds3103_pdata;\n\trequest_module(\"m88ds3103\");\n\tclient = i2c_new_device(&d->i2c_adap, &board_info);\n\tif (client == NULL || client->dev.driver == NULL)\n\t\treturn -ENODEV;\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);\n\n\tstate->i2c_client_demod = client;\n\n\t/* attach tuner */\n\tts2020_config.fe = adap->fe_adap[0].fe;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"ts2022\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x60;\n\tboard_info.platform_data = &ts2020_config;\n\trequest_module(\"ts2020\");\n\tclient = i2c_new_device(i2c_adapter, &board_info);\n\n\tif (client == NULL || client->dev.driver == NULL) {\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\t/* delegate signal strength measurement to tuner */\n\tadap->fe_adap[0].fe->ops.read_signal_strength =\n\t\t\tadap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;\n\n\tstate->i2c_client_tuner = client;\n\n\t/* hook fe: need to resync the slave fifo when signal locks */\n\tstate->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;\n\n\tstate->last_lock = 0;\n\n\treturn 0;\n}",
                        "code_after_change": "static int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\tstruct i2c_adapter *i2c_adapter;\n\tstruct i2c_client *client;\n\tstruct i2c_board_info board_info;\n\tstruct m88ds3103_platform_data m88ds3103_pdata = {};\n\tstruct ts2020_config ts2020_config = {};\n\n\tmutex_lock(&d->data_mutex);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x80;\n\tstate->data[2] = 0x0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x02;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 0;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0xe;\n\tstate->data[1] = 0x83;\n\tstate->data[2] = 1;\n\n\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\n\tstate->data[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\tmutex_unlock(&d->data_mutex);\n\n\t/* attach demod */\n\tm88ds3103_pdata.clk = 27000000;\n\tm88ds3103_pdata.i2c_wr_max = 33;\n\tm88ds3103_pdata.ts_mode = M88DS3103_TS_CI;\n\tm88ds3103_pdata.ts_clk = 16000;\n\tm88ds3103_pdata.ts_clk_pol = 0;\n\tm88ds3103_pdata.spec_inv = 0;\n\tm88ds3103_pdata.agc = 0x99;\n\tm88ds3103_pdata.agc_inv = 0;\n\tm88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_ENABLED;\n\tm88ds3103_pdata.envelope_mode = 0;\n\tm88ds3103_pdata.lnb_hv_pol = 1;\n\tm88ds3103_pdata.lnb_en_pol = 0;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"m88ds3103\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x68;\n\tboard_info.platform_data = &m88ds3103_pdata;\n\trequest_module(\"m88ds3103\");\n\tclient = i2c_new_device(&d->i2c_adap, &board_info);\n\tif (client == NULL || client->dev.driver == NULL)\n\t\treturn -ENODEV;\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\treturn -ENODEV;\n\t}\n\tadap->fe_adap[0].fe = m88ds3103_pdata.get_dvb_frontend(client);\n\ti2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);\n\n\tstate->i2c_client_demod = client;\n\n\t/* attach tuner */\n\tts2020_config.fe = adap->fe_adap[0].fe;\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrlcpy(board_info.type, \"ts2022\", I2C_NAME_SIZE);\n\tboard_info.addr = 0x60;\n\tboard_info.platform_data = &ts2020_config;\n\trequest_module(\"ts2020\");\n\tclient = i2c_new_device(i2c_adapter, &board_info);\n\n\tif (client == NULL || client->dev.driver == NULL) {\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(client->dev.driver->owner)) {\n\t\ti2c_unregister_device(client);\n\t\tdvb_frontend_detach(adap->fe_adap[0].fe);\n\t\treturn -ENODEV;\n\t}\n\n\t/* delegate signal strength measurement to tuner */\n\tadap->fe_adap[0].fe->ops.read_signal_strength =\n\t\t\tadap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;\n\n\tstate->i2c_client_tuner = client;\n\n\t/* hook fe: need to resync the slave fifo when signal locks */\n\tstate->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\n\tadap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;\n\n\tstate->last_lock = 0;\n\n\treturn 0;\n}",
                        "cve_id": "CVE-2017-8062"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1629,
            "cve_id": "CVE-2017-8068",
            "code_snippet": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, buf, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\telse if (ret <= size)\n\t\tmemcpy(data, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
                        "code_after_change": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(&data, 1, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, buf, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}",
                        "cve_id": "CVE-2017-8068"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1726,
            "cve_id": "CVE-2018-1120",
            "code_snippet": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\n\t/* Ensure the process spawned far enough to have an environment. */\n\tif (!mm || !mm->env_end)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!mmget_not_zero(mm))\n\t\tgoto free;\n\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\n\t\tthis_len = env_end - (env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (env_start + src), page, this_len, FOLL_ANON);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t _count, loff_t *pos)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tchar *page;\n\tunsigned long count = _count;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tunsigned long len1, len2, len;\n\tunsigned long p;\n\tchar c;\n\tssize_t rv;\n\n\tBUG_ON(*pos < 0);\n\n\ttsk = get_proc_task(file_inode(file));\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(tsk);\n\tput_task_struct(tsk);\n\tif (!mm)\n\t\treturn 0;\n\t/* Check if process spawned far enough to have cmdline. */\n\tif (!mm->env_end) {\n\t\trv = 0;\n\t\tgoto out_mmput;\n\t}\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page) {\n\t\trv = -ENOMEM;\n\t\tgoto out_mmput;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\targ_start = mm->arg_start;\n\targ_end = mm->arg_end;\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\tBUG_ON(arg_start > arg_end);\n\tBUG_ON(env_start > env_end);\n\n\tlen1 = arg_end - arg_start;\n\tlen2 = env_end - env_start;\n\n\t/* Empty ARGV. */\n\tif (len1 == 0) {\n\t\trv = 0;\n\t\tgoto out_free_page;\n\t}\n\t/*\n\t * Inherently racy -- command line shares address space\n\t * with code and data.\n\t */\n\trv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);\n\tif (rv <= 0)\n\t\tgoto out_free_page;\n\n\trv = 0;\n\n\tif (c == '\\0') {\n\t\t/* Command line (set of strings) occupies whole ARGV. */\n\t\tif (len1 <= *pos)\n\t\t\tgoto out_free_page;\n\n\t\tp = arg_start + *pos;\n\t\tlen = len1 - *pos;\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count;\n\t\t\tint nr_read;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Command line (1 string) occupies ARGV and\n\t\t * extends into ENVP.\n\t\t */\n\t\tstruct {\n\t\t\tunsigned long p;\n\t\t\tunsigned long len;\n\t\t} cmdline[2] = {\n\t\t\t{ .p = arg_start, .len = len1 },\n\t\t\t{ .p = env_start, .len = len2 },\n\t\t};\n\t\tloff_t pos1 = *pos;\n\t\tunsigned int i;\n\n\t\ti = 0;\n\t\twhile (i < 2 && pos1 >= cmdline[i].len) {\n\t\t\tpos1 -= cmdline[i].len;\n\t\t\ti++;\n\t\t}\n\t\twhile (i < 2) {\n\t\t\tp = cmdline[i].p + pos1;\n\t\t\tlen = cmdline[i].len - pos1;\n\t\t\twhile (count > 0 && len > 0) {\n\t\t\t\tunsigned int _count, l;\n\t\t\t\tint nr_read;\n\t\t\t\tbool final;\n\n\t\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\t\tnr_read = access_remote_vm(mm, p, page, _count, 0);\n\t\t\t\tif (nr_read < 0)\n\t\t\t\t\trv = nr_read;\n\t\t\t\tif (nr_read <= 0)\n\t\t\t\t\tgoto out_free_page;\n\n\t\t\t\t/*\n\t\t\t\t * Command line can be shorter than whole ARGV\n\t\t\t\t * even if last \"marker\" byte says it is not.\n\t\t\t\t */\n\t\t\t\tfinal = false;\n\t\t\t\tl = strnlen(page, nr_read);\n\t\t\t\tif (l < nr_read) {\n\t\t\t\t\tnr_read = l;\n\t\t\t\t\tfinal = true;\n\t\t\t\t}\n\n\t\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\t\trv = -EFAULT;\n\t\t\t\t\tgoto out_free_page;\n\t\t\t\t}\n\n\t\t\t\tp\t+= nr_read;\n\t\t\t\tlen\t-= nr_read;\n\t\t\t\tbuf\t+= nr_read;\n\t\t\t\tcount\t-= nr_read;\n\t\t\t\trv\t+= nr_read;\n\n\t\t\t\tif (final)\n\t\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\t/* Only first chunk can be read partially. */\n\t\t\tpos1 = 0;\n\t\t\ti++;\n\t\t}\n\t}\n\nout_free_page:\n\tfree_page((unsigned long)page);\nout_mmput:\n\tmmput(mm);\n\tif (rv > 0)\n\t\t*pos += rv;\n\treturn rv;\n}",
                        "code_after_change": "static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t _count, loff_t *pos)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tchar *page;\n\tunsigned long count = _count;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tunsigned long len1, len2, len;\n\tunsigned long p;\n\tchar c;\n\tssize_t rv;\n\n\tBUG_ON(*pos < 0);\n\n\ttsk = get_proc_task(file_inode(file));\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(tsk);\n\tput_task_struct(tsk);\n\tif (!mm)\n\t\treturn 0;\n\t/* Check if process spawned far enough to have cmdline. */\n\tif (!mm->env_end) {\n\t\trv = 0;\n\t\tgoto out_mmput;\n\t}\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page) {\n\t\trv = -ENOMEM;\n\t\tgoto out_mmput;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\targ_start = mm->arg_start;\n\targ_end = mm->arg_end;\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\n\tBUG_ON(arg_start > arg_end);\n\tBUG_ON(env_start > env_end);\n\n\tlen1 = arg_end - arg_start;\n\tlen2 = env_end - env_start;\n\n\t/* Empty ARGV. */\n\tif (len1 == 0) {\n\t\trv = 0;\n\t\tgoto out_free_page;\n\t}\n\t/*\n\t * Inherently racy -- command line shares address space\n\t * with code and data.\n\t */\n\trv = access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_ANON);\n\tif (rv <= 0)\n\t\tgoto out_free_page;\n\n\trv = 0;\n\n\tif (c == '\\0') {\n\t\t/* Command line (set of strings) occupies whole ARGV. */\n\t\tif (len1 <= *pos)\n\t\t\tgoto out_free_page;\n\n\t\tp = arg_start + *pos;\n\t\tlen = len1 - *pos;\n\t\twhile (count > 0 && len > 0) {\n\t\t\tunsigned int _count;\n\t\t\tint nr_read;\n\n\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\tnr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);\n\t\t\tif (nr_read < 0)\n\t\t\t\trv = nr_read;\n\t\t\tif (nr_read <= 0)\n\t\t\t\tgoto out_free_page;\n\n\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\tp\t+= nr_read;\n\t\t\tlen\t-= nr_read;\n\t\t\tbuf\t+= nr_read;\n\t\t\tcount\t-= nr_read;\n\t\t\trv\t+= nr_read;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Command line (1 string) occupies ARGV and\n\t\t * extends into ENVP.\n\t\t */\n\t\tstruct {\n\t\t\tunsigned long p;\n\t\t\tunsigned long len;\n\t\t} cmdline[2] = {\n\t\t\t{ .p = arg_start, .len = len1 },\n\t\t\t{ .p = env_start, .len = len2 },\n\t\t};\n\t\tloff_t pos1 = *pos;\n\t\tunsigned int i;\n\n\t\ti = 0;\n\t\twhile (i < 2 && pos1 >= cmdline[i].len) {\n\t\t\tpos1 -= cmdline[i].len;\n\t\t\ti++;\n\t\t}\n\t\twhile (i < 2) {\n\t\t\tp = cmdline[i].p + pos1;\n\t\t\tlen = cmdline[i].len - pos1;\n\t\t\twhile (count > 0 && len > 0) {\n\t\t\t\tunsigned int _count, l;\n\t\t\t\tint nr_read;\n\t\t\t\tbool final;\n\n\t\t\t\t_count = min3(count, len, PAGE_SIZE);\n\t\t\t\tnr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);\n\t\t\t\tif (nr_read < 0)\n\t\t\t\t\trv = nr_read;\n\t\t\t\tif (nr_read <= 0)\n\t\t\t\t\tgoto out_free_page;\n\n\t\t\t\t/*\n\t\t\t\t * Command line can be shorter than whole ARGV\n\t\t\t\t * even if last \"marker\" byte says it is not.\n\t\t\t\t */\n\t\t\t\tfinal = false;\n\t\t\t\tl = strnlen(page, nr_read);\n\t\t\t\tif (l < nr_read) {\n\t\t\t\t\tnr_read = l;\n\t\t\t\t\tfinal = true;\n\t\t\t\t}\n\n\t\t\t\tif (copy_to_user(buf, page, nr_read)) {\n\t\t\t\t\trv = -EFAULT;\n\t\t\t\t\tgoto out_free_page;\n\t\t\t\t}\n\n\t\t\t\tp\t+= nr_read;\n\t\t\t\tlen\t-= nr_read;\n\t\t\t\tbuf\t+= nr_read;\n\t\t\t\tcount\t-= nr_read;\n\t\t\t\trv\t+= nr_read;\n\n\t\t\t\tif (final)\n\t\t\t\t\tgoto out_free_page;\n\t\t\t}\n\n\t\t\t/* Only first chunk can be read partially. */\n\t\t\tpos1 = 0;\n\t\t\ti++;\n\t\t}\n\t}\n\nout_free_page:\n\tfree_page((unsigned long)page);\nout_mmput:\n\tmmput(mm);\n\tif (rv > 0)\n\t\t*pos += rv;\n\treturn rv;\n}",
                        "cve_id": "CVE-2018-1120"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 1950,
            "cve_id": "CVE-2018-7740",
            "code_snippet": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tstruct resv_map *resv_map;\n\tlong gbl_reserve;\n\n\t/* This should never happen */\n\tif (from > to) {\n\t\tVM_WARN(1, \"%s called with a negative range\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Only apply hugepage reservation if asked. At fault time, an\n\t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n\t */\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tresv_map = inode_resv_map(inode);\n\n\t\tchg = region_chg(resv_map, from, to);\n\n\t} else {\n\t\tresv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * There must be enough pages in the subpool for the mapping. If\n\t * the subpool has a minimum size, there may be some global\n\t * reservations already in place (gbl_reserve).\n\t */\n\tgbl_reserve = hugepage_subpool_get_pages(spool, chg);\n\tif (gbl_reserve < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n\t */\n\tret = hugetlb_acct_memory(h, gbl_reserve);\n\tif (ret < 0) {\n\t\t/* put back original number of pages, chg */\n\t\t(void)hugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE) {\n\t\tlong add = region_add(resv_map, from, to);\n\n\t\tif (unlikely(chg > add)) {\n\t\t\t/*\n\t\t\t * pages in this range were added to the reserve\n\t\t\t * map between region_chg and region_add.  This\n\t\t\t * indicates a race with alloc_huge_page.  Adjust\n\t\t\t * the subpool and reserve counts modified above\n\t\t\t * based on the difference.\n\t\t\t */\n\t\t\tlong rsv_adjust;\n\n\t\t\trsv_adjust = hugepage_subpool_put_pages(spool,\n\t\t\t\t\t\t\t\tchg - add);\n\t\t\thugetlb_acct_memory(h, -rsv_adjust);\n\t\t}\n\t}\n\treturn 0;\nout_err:\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\t/* Don't call region_abort if region_chg failed */\n\t\tif (chg >= 0)\n\t\t\tregion_abort(resv_map, from, to);\n\tif (vma && is_vma_resv_set(vma, HPAGE_RESV_OWNER))\n\t\tkref_put(&resv_map->refs, resv_map_release);\n\treturn ret;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tint write = (gup_flags & FOLL_WRITE);\n\tint foreign = (gup_flags & FOLL_REMOTE);\n\n\tif (vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn -EFAULT;\n\n\tif (write) {\n\t\tif (!(vm_flags & VM_WRITE)) {\n\t\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\t\treturn -EFAULT;\n\t\t\t/*\n\t\t\t * We used to let the write,force case do COW in a\n\t\t\t * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could\n\t\t\t * set a breakpoint in a read-only mapping of an\n\t\t\t * executable, without corrupting the file (yet only\n\t\t\t * when that file had been opened for writing!).\n\t\t\t * Anon pages in shared mappings are surprising: now\n\t\t\t * just reject it.\n\t\t\t */\n\t\t\tif (!is_cow_mapping(vm_flags))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (!(vm_flags & VM_READ)) {\n\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\treturn -EFAULT;\n\t\t/*\n\t\t * Is there actually any vma we can reach here which does not\n\t\t * have VM_MAYREAD set?\n\t\t */\n\t\tif (!(vm_flags & VM_MAYREAD))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * gups are always data accesses, not instruction\n\t * fetches, so execute=false here\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
                        "code_after_change": "static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tint write = (gup_flags & FOLL_WRITE);\n\tint foreign = (gup_flags & FOLL_REMOTE);\n\n\tif (vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn -EFAULT;\n\n\tif (gup_flags & FOLL_ANON && !vma_is_anonymous(vma))\n\t\treturn -EFAULT;\n\n\tif (write) {\n\t\tif (!(vm_flags & VM_WRITE)) {\n\t\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\t\treturn -EFAULT;\n\t\t\t/*\n\t\t\t * We used to let the write,force case do COW in a\n\t\t\t * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could\n\t\t\t * set a breakpoint in a read-only mapping of an\n\t\t\t * executable, without corrupting the file (yet only\n\t\t\t * when that file had been opened for writing!).\n\t\t\t * Anon pages in shared mappings are surprising: now\n\t\t\t * just reject it.\n\t\t\t */\n\t\t\tif (!is_cow_mapping(vm_flags))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (!(vm_flags & VM_READ)) {\n\t\tif (!(gup_flags & FOLL_FORCE))\n\t\t\treturn -EFAULT;\n\t\t/*\n\t\t * Is there actually any vma we can reach here which does not\n\t\t * have VM_MAYREAD set?\n\t\t */\n\t\tif (!(vm_flags & VM_MAYREAD))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * gups are always data accesses, not instruction\n\t * fetches, so execute=false here\n\t */\n\tif (!arch_vma_access_permitted(vma, write, false, foreign))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
                        "cve_id": "CVE-2018-1120"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 3281,
            "cve_id": "CVE-2021-4204",
            "code_snippet": "static int check_func_arg(struct bpf_verifier_env *env, u32 arg,\n\t\t\t  struct bpf_call_arg_meta *meta,\n\t\t\t  const struct bpf_func_proto *fn)\n{\n\tu32 regno = BPF_REG_1 + arg;\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tenum bpf_arg_type arg_type = fn->arg_type[arg];\n\tenum bpf_reg_type type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\terr = check_reg_arg(env, regno, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into helper function\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type_is_pkt_pointer(type) &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(env, \"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (base_type(arg_type) == ARG_PTR_TO_MAP_VALUE ||\n\t    base_type(arg_type) == ARG_PTR_TO_UNINIT_MAP_VALUE) {\n\t\terr = resolve_map_arg_type(env, meta, &arg_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (register_is_null(reg) && type_may_be_null(arg_type))\n\t\t/* A NULL register has a SCALAR_VALUE type, so skip\n\t\t * type checking.\n\t\t */\n\t\tgoto skip_type_check;\n\n\terr = check_reg_type(env, regno, arg_type, fn->arg_btf_id[arg]);\n\tif (err)\n\t\treturn err;\n\n\tif (type == PTR_TO_CTX) {\n\t\terr = check_ptr_off_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\nskip_type_check:\n\tif (reg->ref_obj_id) {\n\t\tif (meta->ref_obj_id) {\n\t\t\tverbose(env, \"verifier internal error: more than one arg with ref_obj_id R%d %u %u\\n\",\n\t\t\t\tregno, reg->ref_obj_id,\n\t\t\t\tmeta->ref_obj_id);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tmeta->ref_obj_id = reg->ref_obj_id;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tif (meta->map_ptr) {\n\t\t\t/* Use map_uid (which is unique id of inner map) to reject:\n\t\t\t * inner_map1 = bpf_map_lookup_elem(outer_map, key1)\n\t\t\t * inner_map2 = bpf_map_lookup_elem(outer_map, key2)\n\t\t\t * if (inner_map1 && inner_map2) {\n\t\t\t *     timer = bpf_map_lookup_elem(inner_map1);\n\t\t\t *     if (timer)\n\t\t\t *         // mismatch would have been allowed\n\t\t\t *         bpf_timer_init(timer, inner_map2);\n\t\t\t * }\n\t\t\t *\n\t\t\t * Comparing map_ptr is enough to distinguish normal and outer maps.\n\t\t\t */\n\t\t\tif (meta->map_ptr != reg->map_ptr ||\n\t\t\t    meta->map_uid != reg->map_uid) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"timer pointer in R1 map_uid=%d doesn't match map pointer in R2 map_uid=%d\\n\",\n\t\t\t\t\tmeta->map_uid, reg->map_uid);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tmeta->map_ptr = reg->map_ptr;\n\t\tmeta->map_uid = reg->map_uid;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(env, \"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->key_size, false,\n\t\t\t\t\t      NULL);\n\t} else if (base_type(arg_type) == ARG_PTR_TO_MAP_VALUE ||\n\t\t   base_type(arg_type) == ARG_PTR_TO_UNINIT_MAP_VALUE) {\n\t\tif (type_may_be_null(arg_type) && register_is_null(reg))\n\t\t\treturn 0;\n\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(env, \"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->raw_mode = (arg_type == ARG_PTR_TO_UNINIT_MAP_VALUE);\n\t\terr = check_helper_mem_access(env, regno,\n\t\t\t\t\t      meta->map_ptr->value_size, false,\n\t\t\t\t\t      meta);\n\t} else if (arg_type == ARG_PTR_TO_PERCPU_BTF_ID) {\n\t\tif (!reg->btf_id) {\n\t\t\tverbose(env, \"Helper has invalid btf_id in R%d\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->ret_btf = reg->btf;\n\t\tmeta->ret_btf_id = reg->btf_id;\n\t} else if (arg_type == ARG_PTR_TO_SPIN_LOCK) {\n\t\tif (meta->func_id == BPF_FUNC_spin_lock) {\n\t\t\tif (process_spin_lock(env, regno, true))\n\t\t\t\treturn -EACCES;\n\t\t} else if (meta->func_id == BPF_FUNC_spin_unlock) {\n\t\t\tif (process_spin_lock(env, regno, false))\n\t\t\t\treturn -EACCES;\n\t\t} else {\n\t\t\tverbose(env, \"verifier internal error\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (arg_type == ARG_PTR_TO_TIMER) {\n\t\tif (process_timer_func(env, regno, meta))\n\t\t\treturn -EACCES;\n\t} else if (arg_type == ARG_PTR_TO_FUNC) {\n\t\tmeta->subprogno = reg->subprogno;\n\t} else if (arg_type_is_mem_ptr(arg_type)) {\n\t\t/* The access to this pointer is only checked when we hit the\n\t\t * next is_mem_size argument below.\n\t\t */\n\t\tmeta->raw_mode = (arg_type == ARG_PTR_TO_UNINIT_MEM);\n\t} else if (arg_type_is_mem_size(arg_type)) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* This is used to refine r0 return value bounds for helpers\n\t\t * that enforce this value as an upper bound on return values.\n\t\t * See do_refine_retval_range() for helpers that can refine\n\t\t * the return value. C type of helper is u32 so we pull register\n\t\t * bound from umax_value however, if negative verifier errors\n\t\t * out. Only upper bounds can be learned because retval is an\n\t\t * int type and negative retvals are allowed.\n\t\t */\n\t\tmeta->msize_max_value = reg->umax_value;\n\n\t\t/* The register is SCALAR_VALUE; the access check\n\t\t * happens using its boundaries.\n\t\t */\n\t\tif (!tnum_is_const(reg->var_off))\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\tif (reg->smin_value < 0) {\n\t\t\tverbose(env, \"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->umin_value == 0) {\n\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t      meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (reg->umax_value >= BPF_MAX_VAR_SIZ) {\n\t\t\tverbose(env, \"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t      reg->umax_value,\n\t\t\t\t\t      zero_size_allowed, meta);\n\t\tif (!err)\n\t\t\terr = mark_chain_precision(env, regno);\n\t} else if (arg_type_is_alloc_size(arg_type)) {\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"R%d is not a known constant'\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmeta->mem_size = reg->var_off.value;\n\t} else if (arg_type_is_int_ptr(arg_type)) {\n\t\tint size = int_ptr_type_to_size(arg_type);\n\n\t\terr = check_helper_mem_access(env, regno, size, false, meta);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_ptr_alignment(env, reg, 0, size, true);\n\t} else if (arg_type == ARG_PTR_TO_CONST_STR) {\n\t\tstruct bpf_map *map = reg->map_ptr;\n\t\tint map_off;\n\t\tu64 map_addr;\n\t\tchar *str_ptr;\n\n\t\tif (!bpf_map_is_rdonly(map)) {\n\t\t\tverbose(env, \"R%d does not point to a readonly map'\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"R%d is not a constant address'\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (!map->ops->map_direct_value_addr) {\n\t\t\tverbose(env, \"no direct value access support for this map type\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_map_access(env, regno, reg->off,\n\t\t\t\t       map->value_size - reg->off, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmap_off = reg->off + reg->var_off.value;\n\t\terr = map->ops->map_direct_value_addr(map, &map_addr, map_off);\n\t\tif (err) {\n\t\t\tverbose(env, \"direct value access on string failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tstr_ptr = (char *)(long)(map_addr);\n\t\tif (!strnchr(str_ptr + map_off, map->value_size - map_off, 0)) {\n\t\t\tverbose(env, \"string is not zero-terminated\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn err;\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (base_type(reg->type) == PTR_TO_MEM) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\n\t\tif (type_may_be_null(reg->type)) {\n\t\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\t\treg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && rdonly_mem) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && value_regno >= 0 && (t == BPF_READ || rdonly_mem))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ctx_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf, &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (base_type(reg_type) == PTR_TO_BTF_ID) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = func(env, reg);\n\t\terr = update_stack_depth(env, state, off);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_BTF_ID) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BUF) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\t\tconst char *buf_info;\n\t\tu32 *max_access;\n\n\t\tif (rdonly_mem) {\n\t\t\tif (t == BPF_WRITE) {\n\t\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tbuf_info = \"rdonly\";\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tbuf_info = \"rdwr\";\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  buf_info, max_access);\n\n\t\tif (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
                        "code_after_change": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (base_type(reg->type) == PTR_TO_MEM) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\n\t\tif (type_may_be_null(reg->type)) {\n\t\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\t\treg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && rdonly_mem) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && value_regno >= 0 && (t == BPF_READ || rdonly_mem))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ptr_off_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf, &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (base_type(reg_type) == PTR_TO_BTF_ID) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = func(env, reg);\n\t\terr = update_stack_depth(env, state, off);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_BTF_ID) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BUF) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\t\tconst char *buf_info;\n\t\tu32 *max_access;\n\n\t\tif (rdonly_mem) {\n\t\t\tif (t == BPF_WRITE) {\n\t\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tbuf_info = \"rdonly\";\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tbuf_info = \"rdwr\";\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  buf_info, max_access);\n\n\t\tif (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
                        "cve_id": "CVE-2021-4204"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        },
        {
            "id": 3795,
            "cve_id": "CVE-2022-3625",
            "code_snippet": "static int devlink_param_set(struct devlink *devlink,\n\t\t\t     const struct devlink_param *param,\n\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tif (!param->set || devlink->reload_failed)\n\t\treturn -EOPNOTSUPP;\n\treturn param->set(devlink, param->id, ctx);\n}",
            "detect_result": [
                {
                    "vul_knowledge": {
                        "code_before_change": "static int devlink_param_get(struct devlink *devlink,\n\t\t\t     const struct devlink_param *param,\n\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tif (!param->get)\n\t\treturn -EOPNOTSUPP;\n\treturn param->get(devlink, param->id, ctx);\n}",
                        "code_after_change": "static int devlink_param_get(struct devlink *devlink,\n\t\t\t     const struct devlink_param *param,\n\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tif (!param->get || devlink->reload_failed)\n\t\treturn -EOPNOTSUPP;\n\treturn param->get(devlink, param->id, ctx);\n}",
                        "cve_id": "CVE-2022-3625"
                    },
                    "vul_output": "YES"
                }
            ],
            "detection_model": "gpt-4o-mini",
            "final_result": 1
        }
    ]
}